{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier{\*\falt Courier New};}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f790\froman\fcharset238\fprq2 Times New Roman CE;}{\f791\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f793\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f794\froman\fcharset162\fprq2 Times New Roman Tur;}{\f795\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f796\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f797\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f798\fswiss\fcharset238\fprq2 Arial CE;}{\f799\fswiss\fcharset204\fprq2 Arial Cyr;}{\f801\fswiss\fcharset161\fprq2 Arial Greek;}{\f802\fswiss\fcharset162\fprq2 Arial Tur;}{\f803\fswiss\fcharset177\fprq2 Arial (Hebrew);}
{\f804\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f805\fswiss\fcharset186\fprq2 Arial Baltic;}{\f806\fmodern\fcharset238\fprq1 Courier New CE;}{\f807\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f809\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f810\fmodern\fcharset162\fprq1 Courier New Tur;}{\f811\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f812\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f813\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;
\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;
\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{
\s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{
\s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 2;}{
\s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 3;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 footnote text;}{\*\cs16 \additive \f0\super \sbasedon10 footnote reference;}{\*\cs17 \additive \f0\ul\cf2 
\sbasedon10 Hyperlink;}{\s18\ql \li0\ri0\sa120\sl360\slmult1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext18 Body Text;}{\*\cs19 \additive 
\f6\fs22\chshdng0\chcfpat0\chcbpat0 \sbasedon10 Code Inline;}{\s20\ql \li720\ri720\sl360\slmult1\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 
\f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 \sbasedon0 \snext20 Code Listing;}{\s21\ql \li360\ri0\sa120\sl360\slmult1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext21 Body Text 2;}{\s22\ql \li0\ri0\sb120\sa120\sl360\slmult1\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext22 API Name;}{\s23\ql \li0\ri0\sl360\slmult1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
\sbasedon18 \snext23 Table;}}{\*\listtable{\list\listtemplateid-1734441242\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat4\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\f0\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-720\li1440\jclisttab\tx1440 }{\listname ;}\listid107166021}{\list\listtemplateid68354049\listsimple{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid156653440}{\list\listtemplateid1944737318\listhybrid{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160
\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689
\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0
{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid241331705}{\list\listtemplateid1693582972\listsimple{\listlevel
\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat5\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-720\li1440\jclisttab\tx1440 }{\listname 
;}\listid298150666}{\list\listtemplateid68354049\listsimple{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid663700731}{\list\listtemplateid290347014\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat3\levelspace0\levelindent0{\leveltext
\'01\'00;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1080\jclisttab\tx1080 }{\listname ;}\listid956595244}{\list\listtemplateid1252801822{\listlevel\levelnfc1\levelnfcn1\leveljc0\leveljcn0\levelfollow1
\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0
{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel
\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2
\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext
\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listname 
;}\listid1621105010}{\list\listtemplateid1668292118\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360
\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }
{\listname ;}\listid1789619211}}{\*\listoverridetable{\listoverride\listid298150666\listoverridecount0\ls1}{\listoverride\listid107166021\listoverridecount0\ls2}{\listoverride\listid956595244\listoverridecount0\ls3}{\listoverride\listid663700731
\listoverridecount0\ls4}{\listoverride\listid156653440\listoverridecount0\ls5}{\listoverride\listid1621105010\listoverridecount0\ls6}{\listoverride\listid1621105010\listoverridecount9{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel
\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat
\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}\ls7}{\listoverride\listid1789619211\listoverridecount0\ls8}{\listoverride\listid241331705\listoverridecount0\ls9}}{\*\revtbl {Unknown;}}{\info
{\title #$K+NQC Programmer's Guide}{\author John Hansen}{\operator John Hansen}{\creatim\yr2001\mo10\dy10\hr11\min57}{\revtim\yr2007\mo10\dy11\hr19\min22}{\version340}{\edmins1196}{\nofpages106}{\nofwords19490}{\nofchars111094}
{\*\company Aspect Communications, Inc.}{\nofcharsws136431}{\vern8247}}\margl1417\margr1417\margt1417\margb1417 \widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180
\dghorigin1701\dgvorigin1984\dghshow1\dgvshow1\jexpand\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0{\*\ftnsep \pard\plain 
\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\chftnsep 
\par }}{\*\ftnsepc \pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\chftnsepc 
\par }}{\*\aftnsep \pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\chftnsep 
\par }}{\*\aftnsepc \pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\chftnsepc 
\par }}\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}
{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQCProgrammersGuide}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  NQC Programmer\rquote s Guide}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  NQC;guide;programmer;dave baum}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{\f1\fs40 NQC Programmer's Guide
\par }{\f1\fs28 Version 3.1 r5, by Dave Baum & John Hansen
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 \page }{\cs16\f1\super #{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Contents}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Contents}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  contents}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{\b\f1\fs28 Contents
\par }{\f1 i }{\f1\uldb Title page}{\v\f1 IDH_NQCProgrammersGuide}{\f1 
\par ii }{\f1\uldb Contents}{\v\f1 IDH_NQC_Contents}{\f1 
\par 1 }{\f1\uldb Introduction}{\v\f1 IDH_NQC_Introduction}{\f1 
\par 2 }{\f1\uldb The NQC Language}{\v\f1 IDH_NQC_Language}{\f1 
\par 2.1 }{\f1\uldb Lexical Rules}{\v\f1 IDH_NQC_LexicalRules}{\f1 
\par 2.1.1 }{\f1\uldb Comments}{\v\f1 IDH_NQC_Comments}{\f1 
\par 2.1.2 }{\f1\uldb Whitespace}{\v\f1 IDH_NQC_Whitespace}{\f1 
\par 2.1.3 }{\f1\uldb Numerical Constants}{\v\f1 IDH_NQC_NumericConstants}{\f1 
\par 2.1.4 }{\f1\uldb Identifiers and Keywords}{\v\f1 IDH_NQC_IdentKeywords}{\f1 
\par 2.2 }{\f1\uldb Program Structure}{\v\f1 IDH_NQC_ProgStructure}{\f1 
\par 2.2.1 }{\f1\uldb Tasks}{\v\f1 IDH_NQC_Tasks}{\f1 
\par 2.2.2 }{\f1\uldb Functions}{\v\f1 IDH_NQC_Functions}{\f1 
\par 2.2.3 }{\f1\uldb Subroutines}{\v\f1 IDH_NQC_Subroutines}{\f1 
\par 2.2.4 }{\f1\uldb Variables}{\v\f1 IDH_NQC_Variables}{\f1 
\par 2.2.5 }{\f1\uldb Arrays}{\v\f1 IDH_NQC_Arrays}{\f1 
\par 2.3 }{\f1\uldb Statements}{\v\f1 IDH_NQC_Statements}{\f1 
\par 2.3.1 }{\f1\uldb Variable Declaration}{\v\f1 IDH_NQC_VarDeclarations}{\f1 
\par 2.3.2 }{\f1\uldb Assignment}{\v\f1 IDH_NQC_Assignment}{\f1 
\par 2.3.3 }{\f1\uldb Control Structures}{\v\f1 IDH_NQC_ControlStructures}{\f1 
\par 2.3.4 }{\f1\uldb Access Control and Events}{\v\f1 IDH_NQC_AccessControlEvents}{\f1 
\par 2.3.5 }{\f1\uldb Other Statements}{\v\f1 IDH_NQC_OtherStatements}{\f1 
\par 2.4 }{\f1\uldb Expressions}{\v\f1 IDH_NQC_Expressions}{\f1 
\par 2.4.1 }{\f1\uldb Conditions}{\v\f1 IDH_NQC_Conditions}{\f1 
\par 2.5 }{\f1\uldb The Preprocessor}{\v\f1 IDH_NQC_Preprocessor}{\f1 
\par 2.5.1 }{\f1\uldb #include}{\v\f1 IDH_NQC_Include}{\f1 
\par 2.5.2 }{\f1\uldb #define}{\v\f1 IDH_NQC_Define}{\f1 
\par 2.5.3 }{\f1\uldb Conditional Compilation}{\v\f1 IDH_NQC_CondCompilation}{\f1 
\par 2.5.4 }{\f1\uldb Program Initialization}{\v\f1 IDH_NQC_ProgInitialization}{\f1 
\par 2.5.5 }{\f1\uldb Reserving Storage}{\v\f1 IDH_NQC_ReservingStorage}{\f1 
\par 3 }{\f1\uldb NQC API}{\v\f1 IDH_NQC_API}{\f1 
\par 3.1 }{\f1\uldb Sensors}{\v\f1 IDH_NQC_Sensors}{\f1 
\par 3.1.1 }{\f1\uldb Types and Modes RCX, CyberMaster}{\v\f1 IDH_NQC_SensorTypes}{\f1 
\par 3.1.2 }{\f1\uldb Sensor Information}{\v\f1 IDH_NQC_SensorInfo}{\f1 
\par 3.1.3 }{\f1\uldb Scout Light Sensor Scout}{\v\f1 IDH_NQC_ScoutLightSensor}{\f1 
\par 3.1.4 }{\f1\uldb Spybotics Sensors Spy}{\v\f1 IDH_NQC_SpyboticSensors}{\f1 
\par 3.2 }{\f1\uldb Outputs}{\v\f1 IDH_NQC_Outputs}{\f1 
\par 3.2.1 }{\f1\uldb Primitive Calls}{\v\f1 IDH_NQC_OutputsPrimitive}{\f1 
\par 3.2.2 }{\f1\uldb Convenience Calls}{\v\f1 IDH_NQC_OutputsConvenience}{\f1 
\par 3.2.3 }{\f1\uldb Global Control RCX2, Scout}{\v\f1 IDH_NQC_OutputsGlobal}{\f1 
\par 3.2.4 }{\f1\uldb Spybotic Outputs}{\v\f1 IDH_NQC_SpyboticOutputs}{\f1 
\par 3.3 }{\f1\uldb Sound}{\v\f1 IDH_NQC_Sound}{\f1 
\par 3.4 }{\f1\uldb LCD Display RCX}{\v\f1 IDH_NQC_Display}{\f1 
\par }{\f1\lang1036\langfe1033\langnp1036 3.5 }{\f1\uldb\lang1036\langfe1033\langnp1036 Communication}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_Communication}{\f1\lang1036\langfe1033\langnp1036 
\par 3.5.1 }{\f1\uldb\lang1036\langfe1033\langnp1036 Messages RCX, Scout}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_Messages}{\f1\lang1036\langfe1033\langnp1036 
\par 3.5.2 }{\f1\uldb\lang1036\langfe1033\langnp1036 Serial RCX2}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_Serial}{\f1\lang1036\langfe1033\langnp1036 
\par 3.5.3 }{\f1\uldb\lang1036\langfe1033\langnp1036 VLL Scout}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_VLL}{\f1\lang1036\langfe1033\langnp1036 
\par 3.6 }{\f1\uldb\lang1036\langfe1033\langnp1036 Timers}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_Timers}{\f1\lang1036\langfe1033\langnp1036 
\par 3.7 }{\f1\uldb\lang1036\langfe1033\langnp1036 Counters RCX2, Scout, Spy}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_Counters}{\f1\lang1036\langfe1033\langnp1036 
\par 3.8 }{\f1\uldb\lang1036\langfe1033\langnp1036 Access Control RCX2, Scout, Spy}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_AccessControl}{\f1\lang1036\langfe1033\langnp1036 
\par 3.9 }{\f1\uldb\lang1036\langfe1033\langnp1036 Events RCX2, Scout, Spy}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_Events}{\f1\lang1036\langfe1033\langnp1036 
\par 3.9.1 }{\f1\uldb\lang1036\langfe1033\langnp1036 RCX2 Events RCX2, Spy}{\v\f1\lang1036\langfe1033\langnp1036 IDH_NQC_RCX2Events}{\f1\lang1036\langfe1033\langnp1036 
\par }{\f1 3.9.2 }{\f1\uldb Scout Events Scout}{\v\f1 IDH_NQC_ScoutEvents}{\f1 
\par 3.10 }{\f1\uldb Data Logging RCX}{\v\f1 IDH_NQC_Datalogging}{\f1 
\par 3.11 }{\f1\uldb General Features}{\v\f1 IDH_NQC_General}{\f1 
\par 3.12 }{\f1\uldb RCX Specific Features}{\v\f1 IDH_NQC_RCXSpecific}{\f1 
\par 3.13 }{\f1\uldb Scout Specific Features}{\v\f1 IDH_NQC_ScoutSpecific}{\f1 
\par 3.14 }{\f1\uldb CyberMaster Specific Features}{\v\f1 IDH_NQC_CyberMasterSpecific}{\f1 
\par 3.15 }{\f1\uldb Spybotic Specific Features}{\v\f1 IDH_NQC_SpyboticSpecific}{\f1\uldb 
\par }{\f1 3.16 }{\f1\uldb Swan Specific Features}{\v\f1 IDH_NQC_SwanSpecific}{\f1 
\par 4 }{\f1\uldb Technical Details}{\v\f1 IDH_NQC_TechnicalDetails}{\f1 
\par 4.1 }{\f1\uldb The asm statement}{\v\f1 IDH_NQC_ASM}{\f1 
\par 4.2 }{\f1\uldb Data Sources}{\v\f1 IDH_NQC_DataSources}{\f1 
\par }\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Introduction}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Introduction}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  introduction;language}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{1 Introduction
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
NQC stands for Not Quite C, and is a simple language for programming several LEGO MINDSTORMS products. Some of the NQC features d
epend on which MINDSTORMS product you are using. This product is referred to as the target for NQC. Presently, NQC supports six different targets: RCX, RCX2 (an RCX running 2.0 firmware), CyberMaster, Scout, Spybotics, and Swan (an RCX running Dick Swan's
 enhanced firmware).
\par All of the targets have a bytecode interpreter (provided by LEGO) which can be used to execute programs. The NQC compiler translates a source program into LEGO bytecodes, which can then be executed on the target itself. Although the pre
processor and control structures of NQC are very similar to C, NQC is not a general purpose language \endash  there are many restrictions that stem from limitations of the LEGO bytecode interpreter.
\par Logically, NQC is defined as two separate pieces. The NQC langua
ge describes the syntax to be used in writing programs. The NQC API describes the system functions, constants, and macros that can be used by programs. This API is defined in a special file built in to the compiler. By default, this file is always process
ed before compiling a program.
\par This document describes both the NQC language and the NQC API. In short, it provides the information needed to write NQC programs. Since there are several different interfaces for NQC, this document does not describe how to us
e any specific NQC implementation. Refer to the documentation provided with the NQC tool, such as the NQC User Manual for information specific to that implementation.
\par For up-to-date information and documentation for NQC, visit the NQC Web Site at }{\field\fldedit{\*\fldinst {\f1  HYPERLINK "http://bricxcc.sourceforge.net/nqc" }{\f1 {\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b02000000170000002300000068007400740070003a002f002f0062007200690063007800630063002e0073006f00750072006300650066006f007200670065002e006e00650074002f006e00710063000000e0c9ea79f9bace118c8200aa004ba90b460000006800740074007000
3a002f002f0062007200690063007800630063002e0073006f00750072006300650066006f007200670065002e006e00650074002f006e0071006300000000000000}}}{\fldrslt {\cs17\f1\ul\cf2 http://bricxcc.sourceforge.net/nqc}}}{\f1 
\par }\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Language}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  The NQC Language}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  language}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2 The NQC Language
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This section describes the NQC language itself. This includes the lexical rules used by the compiler, the structure programs, statements, and expressions, and the operation of the preprocessor.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_LexicalRules}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Lexical Rules}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  lexical rules}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}
{\f1  cc}}}{2.1 Lexical Rules
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The lexical rules describe how NQC breaks a source file into individual tokens. This includes the way comments are written, then handling of whitespace, and valid characters for identifiers.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Comments}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Comments}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  comments}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.1.1 Comments
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Two forms of comments are supported in NQC. The first form (traditional C comments) begin with /* and end with */. They may span multiple lines, but do not nest:
\par }\pard \ql \fi-360\li1080\ri0\sb120\sa120\widctlpar\faauto\adjustright\rin0\lin1080\itap0 {\f2 /* this is a comment */
\par }\pard \ql \fi-360\li1080\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin1080\itap0 {\f2 /* this is a two\line line comment * /
\par /* another comment...\line /* trying to nest...\line  \tab ending the inner comment... */\line this text is no longer a comment! */
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The second form of comments begins with // and ends with a newline (sometimes known as C++ style comments).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 // a single line comment
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Comments are ignored by the compiler. Their only purpose is to allow the programmer to document the source code.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Whitespace}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Whitespace}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  whitespace}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.1.2 Whitespace
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Whitespace (spaces, tabs, and newlines) is used to separate tokens an
d to make programs more readable. As long as the tokens are distinguishable, adding or subtracting whitespace has no effect on the meaning of a program. For example, the following lines of code both have the same meaning:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x=2;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 2;
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Some of the C++ operat
ors consist of multiple characters. In order to preserve these tokens whitespace must not be inserted within them. In the example below, the first line uses a right shift operator ('>>'), but in the second line the added space causes the '>' symbols to be
 interpreted as two separate tokens and thus generate an error.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 1 >> 4; / / set x to 1 right shifted by 4 bits
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 1 > > 4; // error
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_NumericConstants}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Numerical Constants}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  numerical constants; constants}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.1.3 Numerical Constants

\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Nu
merical constants may be written in either decimal or hexadecimal form. Decimal constants consist of one or more decimal digits. Hexadecimal constants start with 0x or 0X followed by one or more hexadecimal digits.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 10; // set x to 10
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 0x10; // set x to 16 (10 hex)
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_IdentKeywords}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Identifiers and Keywords}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  identifiers;keywords}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.1.4 Identifiers and Keywords
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Identifiers are used for variable, task, and function names. The first character of an identifier must be an upper or lower c
ase letter or the underscore ('_'). Remaining characters may be letters, numbers, and underscore. A number of potential identifiers are reserved for use in the NQC language itself. These reserved words are called keywords and may not be used as identifier
s. A complete list of keywords appears below:
\par }\pard \ql \li720\ri0\widctlpar\tx2520\tx4320\tx6480\faauto\adjustright\rin0\lin720\itap0 {\f2 __event_src\tab __res\tab __taskid\tab abs
\par __nolist\tab __sensor\tab __type\tab acquire
\par asm\tab do\tab int\tab sub
\par break\tab else\tab monitor\tab switch
\par case\tab false\tab repeat\tab task
\par catch\tab for\tab return\tab true
\par const\tab goto\tab sign\tab void
\par continue\tab if\tab start\tab while
\par default\tab inline\tab stop
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_ProgStructure}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Program Structure}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  structure}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.2 Program Structure
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 An NQC program is
 composed of code blocks and global variables. There are three distinct types of code blocks: tasks, inline functions, and subroutines. Each type of code block has its own unique features and restrictions, but they all share a common structure.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Tasks}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Tasks}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 tasks}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.2.1 Tasks
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The RCX implicitly supports multi-tasking, thus an NQC task directly corresponds to an RCX task. Tasks are defined using the task keyword using the following syntax:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 task }{\i\f2 name}{\f2 ()
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 // the task's code is placed here
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
The name of the task may be any legal identifier. A program must always have at least one task - named "main" - which is started whenever the program is run. The maximum number of tasks depends on the target - the RCX supports 10 tasks, CyberMas
ter supports 4, Scout supports 6, and Spybotics supports 8.
\par The body of a task consists of a list of statements. Tasks may be started and stopped using the start and stop statements (described in the section titled }{\i\f1 Statements}{\f1 ). There is also an RCX API command, }{\f2 StopAllTasks}{\f1 
, which stops all currently running tasks.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Functions}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{
2.2.2 Functions
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
It is often helpful to group a set of statements together into a single function, which can then be called as needed. NQC supports functions with arguments, but not return values. Functions are defined using the following syntax:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 void }{\i\f2 name}{\f2 (}{\i\f2 argument_list}{\f2 )
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 // body of the function
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The keyword void is an artifact of NQC's heritage - in C functions are specified with the type of 
data they return. Functions that do not return data are specified to return void. Returning data is not supported in NQC, thus all functions are declared using the void keyword.
\par }\pard \ql \li0\ri0\sb120\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The argument list may be empty, or may contain one or more argument definition
s. An argument is defined by its type followed by its name. Multiple arguments are separated by commas. All values in the RCX are represented as 16 bit signed integers. However NQC supports six different argument types which correspond to different argume
nt passing semantics and restrictions:
\par }\pard \ql \li720\ri0\widctlpar\tx2160\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Type\tab Meaning\tab Restriction
\par }{\f1 int\tab pass by value\tab none
\par const int\tab pass by value\tab only constants may be used
\par int&\tab pass by reference\tab only variables may be used
\par const int &\tab pass by reference\tab function cannot modify argument
\par }\pard\plain \s23\ql \li720\ri0\widctlpar\tx2160\tx4320\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 int*\tab pass pointer\tab only pointers may be used
\par const int *\tab pass pointer\tab function cannot modify pointer argument
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Arguments of type }{\f2 int}{\f1  are passed by value from the calling function to the c
allee. This usually means that the compiler must allocate a temporary variable to hold the argument. There are no restrictions on the type of value that may be used. However, since the function is working with a copy of the actual argument, any changes it
 makes to the value will not be seen by the caller. In the example below, the function }{\f2 foo}{\f1  attempts to set the value of its argument to 2. This is perfectly legal, but since }{\f2 foo}{\f1 
 is working on a copy of the original argument, the variable }{\f2 y}{\f1  from main task remains unchanged.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 void foo(int x)
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 2;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par 
\par task main()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int y = 1; // y is now equal to 1
\par foo(y); // y is still equal to 1!
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The second type of argument, }{\f2 const int}{\f1 , is also passed by value, but with the restriction that only constant values (e.g. numbe
rs) may be used. This is rather important since there are a number of RCX functions that only work with constant arguments.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 void foo(const int x)
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 PlaySound(x); // ok
\par x = 1; // error - cannot modify argument
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par 
\par task main()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 foo(2);   // ok
\par foo(4*5); // ok - expression is still constant
\par foo(x);   // error - x is not a constant
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The third type, }{\f2 int &}{\f1 , passes arguments by reference rather than by value. This allows the calle
e to modify the value and have those changes visible in the caller. However, only variables may be used when calling a function using int & arguments:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 void foo(int &x)
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 2;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par 
\par task main()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int y = 1; // y is equal to 1
\par foo(y);    // y is now equal to 2
\par foo(2);    // error - only variables allowed
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The fourth type, }{\f2 const int &}{\f1 
, is rather unusual. It is also passed by reference, but with the restriction that the callee is not allowed to modify the value. Because of this restriction, the compiler is able
 to pass anything (not just variables) to functions using this type of argument. In general this is the most efficient way to pass arguments in NQC.
\par There is one important difference between }{\f2 int}{\f1  arguments and }{\f2 const int &}{\f1  arguments. An }{\f2 int}{\f1  argument is passe
d by value, so in the case of a dynamic expression (such as a sensor reading), the value is read once then saved. With }{\f2 const int &}{\f1  arguments, the expression will be re-read each time it is used in the function:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 void foo(int x)
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 if (x == x) // this will always be true
\par }\pard \ql \fi720\li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 PlaySound(SOUND_CLICK);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par 
\par void bar(const int &x)
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 if (x == x) // may not be true. value could change
\par }\pard \ql \fi720\li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 PlaySound(SOUND_CLICK);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par 
\par task main()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 foo(SENSOR_1); // will play sound
\par bar(2);        // will play sound
\par bar(SENSOR_1); // may not play sound
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The last two types, }{\cs19\f6\fs22 int *}{\f1  and }{\cs19\f6\fs22 const int *}{\f1 , pass pointer arguments.  Proper usage of pointer arguments requires that they be de-referenced.

\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 void foo(int * p)\line \{\line \tab *p = 4;\line \}\line \line task main()\line \{\line \tab int x = 2;\line \tab int* y = &x; // y contains the address of x\line \tab foo(y);
\tab // x = 4\line \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Functions must be invoked with the correct number (and type) of arguments. The example below shows several different legal and illegal calls to function }{\f2 foo}{\f1 :
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 void foo(int bar, const int baz)
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 // do something here...
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par 
\par task main ()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int x;     // declare variable x
\par foo(1, 2); // ok
\par foo(x, 2); // ok
\par foo(2, x); // error \endash  2nd argument not constant!
\par foo(2);    // error - wrong number of arguments!
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 NQC functions are always expanded as inline functions. T
his means that each call to a function results in another copy of the function's code being included in the program. Unless used judiciously, inline functions can lead to excessive code size.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Subroutines}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Subroutines}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  subroutines}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.2.3 Subroutines
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Unlike inline functions, subroutines allow a single copy of some code to be shared between several different callers. This makes subroutines much more space efficient than inline functions, but due to some limitations in the RCX, subrouti
nes have some significant restrictions. First of all, subroutines cannot use any arguments. Second, a subroutine cannot call another subroutine. Last, the maximum number of subroutines is limited to 8 for the RCX, 4 for CyberMaster, 3 for Scout, and 32 fo
r
 Spybotics. In addition, when using RCX 1.0 or CyberMaster, if the subroutine is called from multiple tasks then it cannot have any local variables or perform calculations that require temporary variables. These significant restrictions make subroutines l
ess desirable than functions; therefore their use should be minimized to those situations where the resultant savings in code size is absolutely necessary. The syntax for a subroutine appears below:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 sub }{\i\f2 name}{\f2 ()
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 // body of subroutine
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Variables}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Variables}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  variables}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.2.4 Variables
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
All variables in NQC are of one of two types - specifically 16 bit signed integers or pointers to 16 bit signed integers. Variables are declared using the }{\cs19\f6\fs22 int}{\f1  keyword followed by a comma separated list of va
riable names (each with an optional '*' pointer indicator in front of the name) and terminated by a semicolon ('}{\cs19\f6\fs22 ;}{\f1 
').  Optionally, an initial value for each variable may be specified using an equals sign ('=') after the variable name. Several examples appear below:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int x;     // declare x
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int y,z;   // declare y and z
\par int *q, *p = &x; // declare ptrs q and p, p = address of x\line int a=1,b; // declare a and b, initialize a to 1
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Global variables are declared at the program scope (outside any code block). Once dec
lared, they may be used within all tasks, functions, and subroutines. Their scope begins at declaration and ends at the end of the program.
\par }\pard \ql \li0\ri0\sb120\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Local variables may be declared within tasks, functions, and sometimes within subroutines. Such variables are only a
ccessible within the code block in which they are defined. Specifically, their scope begins with their declaration and ends at the end of their code block. In the case of local variables, a compound statement (a group of statements bracketed by }{\f2 \{}{
\f1  and }{\f2 \}}{\f1 ) is considered a block:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int x; // x is global
\par 
\par task main()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int y; // y is local to task main
\par }\pard \ql \li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 x = y; // ok
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{ // begin compound statement
\par }\pard \ql \fi720\li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 int z; // local z declared
\par y = z; // ok
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par y = z; // error - z no longer in scope
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par 
\par task foo()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 1; // ok
\par y = 2; // error - y is not global
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
In many cases NQC must allocate one or more temporary variables for its own use. In some cases a temporary variable is used to hold an intermediate value during a calculation. In other cases it is used to hold a value as
 it is passed to a function. These temporary variables deplete the pool of variables available to the rest of the program. NQC attempts to be as efficient as possible with temporary variables (including reusing them when possible).
\par The RCX (and other targe
ts) provide a number of storage locations which can be used to hold variables in an NQC program. There are two kinds of storage locations - global and local. When compiling a program, NQC assigns each variable to a specific storage location. Programmers f
or the most part can ignore the details of this assignment by following two basic rules:
\par {\listtext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li720\ri0\sb120\widctlpar\jclisttab\tx720\faauto\ls8\adjustright\rin0\lin720\itap0 {\f1  If a variable needs to be in a global location, declare it as a global variable.

\par {\listtext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li720\ri0\widctlpar\jclisttab\tx720\faauto\ls8\adjustright\rin0\lin720\itap0 {\f1  If a variable does not need to be a global variable, make it as local as possible
. This gives the compiler the most flexibility in assigning an actual storage location. 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The number of global and local locations varies by target
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2160\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Target\tab Global\tab Local
\par }\pard \ql \li720\ri0\widctlpar\tx2160\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 RCX (1.0)\tab 32\tab 0
\par CyberMaster\tab 32\tab 0
\par Scout\tab 10\tab 8
\par RCX2\tab 32\tab 16
\par Swan\tab 32\tab 16
\par Spybotics\tab 32\tab 4
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Arrays}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Arrays}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  arrays}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.2.5 Arrays
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The RCX2, Swan, and Spybotics targets support arrays (the other targets do not have suitable support in firmware for arrays). Arrays are declared the same way as ordinary variables, but with the size o
f the array enclosed in brackets. The size must be a constant.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int my_array[3]; // declare an array with three elements
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The elements of an array are identified by their position within the array (called an index). The first element has an index of 0, the second has index 1, etc. For example:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 my_array[0] = 123; // set first element to 123
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 my_array[1] = my_array[2]; // copy third into second
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Currently there are a number of limitations on how arrays can be used. These limitations will likely be removed in future versions of NQC:
\par {\listtext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li720\ri0\sb120\widctlpar\jclisttab\tx720\faauto\ls9\adjustright\rin0\lin720\itap0 {\f1 
An array cannot be an argument to a function. An individual array element, however, can be passed to a function.
\par {\listtext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li720\ri0\widctlpar\jclisttab\tx720\faauto\ls9\adjustright\rin0\lin720\itap0 {\f1 
Neither arrays nor their elements can be used with the increment (++) or decrement (--) operators.
\par {\listtext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}The initial values for an array's elements cannot be specified - an explicit assignment is required within the program itself to set the value of an element.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Statements}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Statements}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  statements}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.3 Statements
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The body of a co
de block (task, function, or subroutine) is composed of statements. Statements are terminated with a semi-colon (';').
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_VarDeclarations}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Variable Declaration}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  variable declaration}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.3.1 Variable Declaration
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Variable declaration, as described in the previous section, is one type of statement. It declares a local variable (with optional initialization) for use within the code block. The syntax for a variable declaration is:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int }{\i\f2 variables}{\f2 ;
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 where variables is a comma separated list of names with optional initial values:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\i\f2 name}{\f2 [=expression]
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Arrays of variables may also be declared (for the RCX2, Swan, and Spybotics only):
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 int }{\i\f2 array}{\f2 [size];
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Assignment}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Assignment}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  assignment}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.3.2 Assignment
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Once declared, variables may be assigned the value of an expression:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\i\f2 variable}{\f2  }{\i\f2 assign_operator}{\f2  }{\i\f2 expression}{\f2 ;
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 There are thirteen different assignment operators. The most basic operator, '=', simply assigns the value of the expression to the variable. The other oper
ators modify the variable's value in some other way as shown in the table below
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx1980\faauto\adjustright\rin0\lin720\itap0 {\b\f2 Operator\tab Action
\par }\pard \ql \li720\ri0\widctlpar\tx1980\faauto\adjustright\rin0\lin720\itap0 {\f2 =\tab Set variable to expression
\par +=\tab Add expression to variable
\par -=\tab Subtract expression from variable
\par *=\tab Multiple variable by expression
\par /=\tab Divide variable by expression
\par %=\tab Set variable to remainder after dividing by expression
\par &=\tab Bitwise AND expression into variable
\par |=\tab Bitwise OR expression into variable
\par ^=\tab Bitwise exclusive OR expression into variable
\par ||=\tab Set variable to absolute value of expression
\par +-=\tab Set variable to sign (-1,+1,0) of expression
\par >>=\tab Right shift variable by a constant amount
\par <<=\tab Left shift variable by a constant amount
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Some examples:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 2; // set x to 2
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 y = 7; // set y to 7
\par x += y; // x is 9, y is still 7
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_ControlStructures}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Control Structures}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  control structures}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.3.3 Control Structures
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The simplest control structure is a compound statement. This is a list of statements enclosed within curly braces ('}{\f2 
\{}{\f1 ' and '}{\f2 \}}{\f1 '):
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 1;
\par y = 2;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Although this may not seem very sig
nificant, it plays a crucial role in building more complicated control structures. Many control structures expect a single statement as their body. By using a compound statement, the same control structure can be used to control multiple statements.

\par The }{\f2 if}{\f1  statement evaluates a condition. If the condition is true it executes one statement (the consequence). An optional second statement (the alternative) is executed if the condition is false. The two syntaxes for an }{\f2 if}{\f1 
 statement are shown below.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 if (}{\i\f2 condition}{\f2 ) }{\i\f2 consequence}{\f2 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 if (}{\i\f2 condition}{\f2 ) }{\i\f2 consequence}{\f2  else }{\i\f2 alternative}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
Note that the condition is enclosed in parentheses. Examples are shown below. Note how a compound statement is used in the last example to allow two statements to be executed as the consequence of the condition.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 if (x == 1) y = 2;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 if (x == 1) y = 3; else y = 4;
\par if (x == 1) \{y = 1; z = 2;\}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 while}{\f1 
 statement is used to construct a conditional loop. The condition is evaluated, and if true the body of the loop is executed, then the condition is tested again. This process continues until the condition becomes false (or a }{\f2 break}{\f1 
 statement is executed). The syntax for a }{\f2 while}{\f1  loop appears below:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 while (}{\i\f2 condition}{\f2 ) }{\i\f2 body}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 It is very common to use a compound statement as the body of a loop:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\lang1036\langfe1033\langnp1036 while (x < 10)
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\lang1036\langfe1033\langnp1036 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\lang1036\langfe1033\langnp1036 x = x+1;
\par y = y*2;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 A variant of the }{\f2 while}{\f1  loop is the }{\f2 do-while}{\f1  loop. Its syntax is:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 do }{\i\f2 body}{\f2  while (}{\i\f2 condition}{\f2 )
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The difference between a }{\f2 while}{\f1  loop and a }{\f2 do-while}{\f1  loop is that the }{\f2 do-while}{\f1  loop always executes the body at least once, whereas the }{\f2 
while}{\f1  loop may not execute it at all. Another kind of loop is the }{\f2 for}{\f1  loop:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 for (}{\i\f2 stmt1}{\f2 ; }{\i\f2 condition}{\f2 ; }{\i\f2 stmt2}{\f2 ) }{\i\f2 body}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 A }{\f2 for}{\f1  loop always executes stmt1, then it repeatedly checks the condition and while it remains true executes the body followed by stmt2. The }{\f2 for}{\f1 
 loop is equivalent to:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\i\f2 stmt1}{\f2 ;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 while (}{\i\f2 condition}{\f2 )
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\i\f2 body
\par stmt2}{\f2 ;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The repeat statement executes a loop a specified number of times:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 repeat (}{\i\f2 expression}{\f2 ) }{\i\f2 body}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The expression determines how many times the body will be executed. Note that it
 is only evaluated a single time, then the body is repeated that number of times. This is different from both the }{\f2 while}{\f1  and }{\f2 do-while}{\f1  loops which evaluate their condition each time through the loop.
\par A }{\f2 switch}{\f1  statement can be used to execute one of several different blocks of code depending on the value of an expression. Each block of code is preceded by one or more }{\f2 case}{\f1  labels. Each }{\f2 case}{\f1 
 must be a constant and unique within the }{\f2 switch}{\f1  statement. The }{\f2 switch}{\f1  statement evaluates the expression then looks for a matching }{\f2 case}{\f1  label. It will then execute any statements following the matching }{\f2 case}{\f1 
 until either a }{\f2 break}{\f1  statement or the end of the }{\f2 switch}{\f1  is reached. A single }{\f2 default}{\f1  label may also be used - it will match any value not already appearing in a }{\f2 case}{\f1  label. Technically, a }{\f2 switch}{\f1 
 statement has the following syntax:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 switch (}{\i\f2 expression}{\f2 ) }{\i\f2 body}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 case}{\f1  and }{\f2 default}{\f1  labels are not statements in themselves - they are }{\i\f1 labels}{\f1 
 that precede statements. Multiple labels can precede the same statement. These labels have the following syntax
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 case }{\i\f2 constant_expression}{\f2  :
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 default :
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 A typical switch statement might look like this:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 switch(x)
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 case 1:
\par }\pard \ql \fi720\li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 // do something when x is 1
\par break;
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 case 2:
\par case 3:
\par }\pard \ql \fi720\li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 // do something else when x is 2 or 3
\par break;
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 default:
\par }\pard \ql \fi720\li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 // do this when x is not 1, 2, or 3
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 break;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 goto}{\f1 
 statement forces a program to jump to the specified location. Statements in a program can be labeled by preceding them with an identifier and a colon. A }{\f2 goto}{\f1  statement then specifies the label which the program should jump to. 
For example, this is how an infinite loop that increments a variable could be implemented using }{\f2 goto}{\f1 :
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 my_loop:
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x++;
\par goto my_loop;
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par The }{\f2 goto}{\f1  statement should be used sparingly and cautiously. In almost every case, control structures such as }{\f2 if}{\f1 , }{\f2 while}{\f1 , and }{\f2 switch}{\f1  make a program much more readable and maintainable than using }{\f2 goto}{
\f1 . Care should be taken to never use a }{\f2 goto}{\f1  to jump into or out of a }{\f2 monitor}{\f1  or }{\f2 acquire}{\f1  statement. This is because }{\f2 monitor}{\f1  and }{\f2 acquire}{\f1 
 have special code that normally gets executed upon entry and exit, and a }{\f2 goto}{\f1  will bypass that code \endash  probably resulting in undesirable behavior.
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 NQC also defines the }{\f2 until}{\f1  macro which provides a convenient alternative to the }{\f2 while}{\f1  loop. The actual definition of }{\f2 until}{\f1  is:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #define until(c) while (!(c))
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 In other words, }{\f2 until}{\f1  will continue looping until the condition becomes true. It is most often used in conjunction with an empty body statement:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 until(SENSOR_1 == 1); // wait for sensor to be pressed
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_AccessControlEvents}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Access Control and Events}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  access control;events}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{2.3.4 Access Control and Events
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The Scout, RCX2, Swan, and Spybotics support access control and event monitoring. Access control allows a task to request ownership of one or more resources. In NQC, access control is provided by the acquire statement, which has two forms:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 acquire ( }{\i\f2 resources}{\f2  ) }{\i\f2 body}{\f2 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 acquire ( }{\i\f2 resources}{\f2  ) }{\i\f2 body}{\f2  catch }{\i\f2 handler}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 where }{\i\f1 resources}{\f1  is a constant that specifies the resources to be acquired and }{\i\f1 body}{\f1  and }{\i\f1 handler}{\f1 
 are statements. The NQC API defines constants for individual resources which may be added together to request multiple resources at the same time. The behavior of the }{\f2 acquire}{\f1 
 statement is as follows: Ownership of the specified resources will be requ
ested. If another task of higher priority already owns the resources, then the request will fail and execution will jump to the handler (if present). Otherwise, the request will succeed, and the body will begin to be executed. While executing the body, if
 
another task of equal or higher priority requests any of the owned resources, then the original task will lose ownership. When ownership is lost, execution will jump to the handler (if present). Once the body has completed, the resources will be returned 
b
ack to the system (so that lower priority tasks may acquire them), and execution will continue with the statement following the acquire statement. If a handler is not specified, then in both the case of a failed request, or a subsequent loss of ownership,
 control will pass to the statement following the }{\f2 acquire}{\f1  statement. For example, the following code acquires a resource for 10 seconds, playing a sound if it cannot complete successfully:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 acquire(ACQUIRE_OUT_A)
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 Wait(1000);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par catch
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 PlaySound(SOUND_UP);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Event monitoring is implemented with the }{\f2 monitor}{\f1  statement, which has a syntax very similar to }{\f2 acquire}{\f1 :
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 monitor ( }{\i\f2 events}{\f2  ) }{\i\f2 body}{\f2 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 monitor ( }{\i\f2 events}{\f2  ) }{\i\f2 body}{\f2  }{\i\f2 handler_list}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Where }{\i\f1 handler_list}{\f1  is one or more handlers of the form
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 catch ( }{\i\f2 catch_events}{\f2  ) }{\i\f2 handler}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The last handler in a handler list can omit the event specification:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 catch }{\i\f2 handler}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\i\f1 Events}{\f1 
 is a constant that determines which events should be monitored. For the Scout, events are predefined, so there are constants such as EVENT_1_PRESSED which can be used
 to specify events. With RCX2, Swan, and Spybotics, the meaning of each event is configured by the programmer. There are 16 events (numbers 0 to 15). In order to specify an event in a monitor statement, the event number must be converted to an event mask 
using the EVENT_MASK() macro. The Scout event constants or event masks may be added together to specify multiple events. Multiple masks can be combined using bitwise OR.
\par The }{\f2 monitor}{\f1  statement will execute the body while monitoring the specified events. If a
ny of the events occur, execution will jump to the first handler for that event (a handler without an event specification handles any event). If no event handler exists for the event, then control will continue at the statement following the }{\f2 monitor
}{\f1  statement. The following example waits for 10 seconds while monitoring events 2, 3, and 4 for RCX2:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 monitor( EVENT_MASK(2) | EVENT_MASK(3) | EVENT_MASK(4) )
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 Wait(1000);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par catch( EVENT_MASK(4) )
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 PlaySound(SOUND_DOWN); // event 4 happened
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par catch
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 PlaySound(SOUND_UP) ; // event 2 or 3 happened
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Note that the }{\f2 acquire}{\f1  and }{\f2 monitor}{\f1 
 statements are only supported for targets that implement access control and event monitoring - specifically the Scout, RCX2, Swan, and Spybotics.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_OtherStatements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Other Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  other statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.3.5 Other Statements
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 A function (or subroutine) call is a statement of the form:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\i\f2 name}{\f2 (}{\i\f2 arguments}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The argumen
ts list is a comma separated list of expressions. The number and type of arguments supplied must match the definition of the function itself. Tasks may be started or stopped with the following statements:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 start }{\i\f2 task_name}{\f2 ;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 stop }{\i\f2 task_name}{\f2 ;
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Within loops (such as a }{\f2 while}{\f1  loop) the }{\f2 break}{\f1  statement can be used to exit the loop and the }{\f2 continue}{\f1 
 statement can be used to skip to the top of the next iteration of the loop. The }{\f2 break}{\f1  statement can also be used to exit a }{\f2 switch}{\f1  statement.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 break;
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 continue;
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 It is possible to cause a function to return before it reaches the end of its code using the }{\f2 return}{\f1  statement.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 return;
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Any expression is also a legal statement when terminated by a semicolon. It is rare to use such a statement since the value of the expression would the
n be discarded. The one notable exception is expressions involving the increment (++) or decrement (--) operators.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x++;
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The empty statement (just a bare semicolon) is also a legal statement.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Expressions}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Expressions}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  expressions}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.4 Expressions
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Earlier versions of NQC made a distinction between expressions and conditions. As of version 2.3, this distinction was eliminated: everything is an expression, and there are now conditional operators for expressions. This is similar to how C/C++
 treats conditional operations.
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\i\f1 Values}{\f1 
 are the most primitive type of expressions. More complicated expressions are formed from values using various operators. The NQC language only has two built in kinds of values: numerical constants and variables. The R
CX API defines other values corresponding to various RCX features such as sensors and timers.
\par Numerical constants in the RCX are represented as 16 bit signed integers. NQC internally uses 32 bit signed math for constant expression evaluation, then reduces 
to 16 bits when generating RCX code. Numeric constants can be written as either decimal (e.g. }{\f2 123}{\f1 ) or hexadecimal (e.g. }{\f2 0xABC}{\f1 
). Presently, there is very little range checking on constants, so using a value larger than expected may have unusual effects.
\par Two special values are predefined: }{\f2 true}{\f1  and }{\f2 false}{\f1 . The value of }{\f2 false}{\f1  is zero, while the value of }{\f2 true}{\f1  is only guaranteed to be non-zero. The same values hold for relational operators (e.g. }{\f2 <}{\f1 
): when the relation is false, the value is 0, otherwise the value is nonzero. 
\par Values may be combined using operators. Several of the operators may only be used in evaluating constant expressions, which means that their operands must either be constants, or expressions involving nothing but constants. The operators are li
sted here in order of precedence (highest to lowest).
\par }\pard \ql \li360\ri0\sb120\widctlpar\tx1440\tx4140\tx5580\tx7380\faauto\adjustright\rin0\lin360\itap0 {\b\f1 Operator\tab Description\tab Associativity\tab Restriction\tab Example
\par }\pard \ql \li360\ri0\widctlpar\tx1440\tx4140\tx5580\tx7380\faauto\adjustright\rin0\lin360\itap0 {\f1 abs()\tab Absolute value\tab n/a\tab \tab abs(x)
\par sign()\tab Sign of operand\tab n/a\tab \tab sign(x)
\par ++, --\tab Increment, decrement\tab left\tab variables only\tab x++ or ++x
\par -\tab Unary minus\tab right\tab \tab -x
\par ~\tab Bitwise negation (unary)\tab right\tab constant only\tab ~123
\par !\tab Logical negation\tab right\tab \tab !x
\par *, /, %\tab Multiplication, division,modulo\tab left\tab \tab x * y
\par +, -\tab Addition, subtraction\tab left\tab \tab x + y
\par <<, >>\tab Left and right shift\tab left\tab shift is constant only\tab 123 << 4
\par <, >,<=, >=\tab relational operators\tab left\tab \tab x < y
\par ==, !=\tab equal to, not equal to\tab left\tab \tab x == 1
\par &\tab Bitwise AND\tab left\tab \tab x & y
\par ^\tab Bitwise XOR\tab left\tab \tab 123 ^ 4
\par |\tab Bitwise OR\tab left\tab \tab x | y
\par &&\tab Logical AND\tab left\tab \tab x && y
\par ||\tab Logical OR\tab left\tab \tab x || y
\par ? :\tab conditional value\tab n/a\tab \tab x==1 ? y : z
\par }\pard \ql \li360\ri0\sb120\widctlpar\tx1440\tx4140\tx5580\tx7380\faauto\adjustright\rin0\lin360\itap0 {\f1 Where needed, parentheses may be used to change the order of evaluation:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx1440\tx4140\tx5580\tx7380\faauto\adjustright\rin0\lin720\itap0 {\f2 x = 2 + 3 * 4; // set x to 14
\par }\pard \ql \li720\ri0\widctlpar\tx1440\tx4140\tx5580\tx7380\faauto\adjustright\rin0\lin720\itap0 {\f2 y = (2 + 3) * 4; // set y to 20
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Conditions}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Conditions}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  conditions}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.4.1 Conditions
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Conditions are generally formed by comparing two expressions. There are also two constant conditions - }{\f2 true}{\f1 
 and }{\f2 false}{\f1  - which always evaluate to true or false respectively. A condition may be negated with the negation operator, or two conditions combined with the AND and OR operators. The table below summarizes the different types of conditions.

\par }\pard \ql \fi-1800\li2520\ri0\sb120\widctlpar\tx2520\faauto\adjustright\rin0\lin2520\itap0 {\b\f1 Condition\tab Meaning
\par }\pard \ql \fi-1800\li2520\ri0\widctlpar\tx2520\faauto\adjustright\rin0\lin2520\itap0 {\f1 true\tab always true
\par false\tab always false
\par expr\tab true if expr is not equal to 0
\par expr1 == expr2\tab true if expr1 equals expr2
\par expr1 != expr2\tab true if expr1 is not equal to expr2
\par expr1 < expr2\tab true if one expr1 is less than expr2
\par expr1 <= expr2\tab true if expr1 is less than or equal to expr2
\par expr1 > expr2\tab true if expr1 is greater than expr2
\par expr1 >= expr2\tab true if expr1 is greater than or equal to expr2
\par ! condition\tab logical negation of a condition - true if condition is false
\par cond1 && cond2\tab logical AND of two conditions (true if and only if both conditions are true)
\par cond1 || cond2\tab logical OR of two conditions (true if and only if at least one of the conditions are true)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Preprocessor}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  The Preprocessor}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  preprocessor}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.5 The Preprocessor
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The preprocessor implements the following directives: }{\f2 #include}{\f1 , }{\f2 #define}{\f1 , }{\f2 #ifdef}{\f1 , }{\f2 
#ifndef}{\f1 , }{\f2 #if}{\f1 , }{\f2 #elif}{\f1 , }{\f2 #else}{\f1 , }{\f2 #endif}{\f1 , }{\f2 #undef}{\f1 . Its implementation is fairly close to a s
tandard C preprocessor, so most things that work in a generic C preprocessor should have the expected effect in NQC. Significant deviations are listed below.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Include}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  #Include}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 #include}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.5.1 #include
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 #include}{\f1 
 command works as expected, with the caveat that the filename must be enclosed in double quotes. There is no notion of a system include path, so enclosing a filename in angle brackets is forbidden.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #include "foo.nqh" // ok
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #include <foo.nqh> // error!
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Define}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  #define}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 #define}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.5.2 #define
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 #define}{\f1 
 command is used for simple macro substitution. Redefinition of a macro is an error (unlike in C where it is a warning). Macros are normally terminated by the end of the line, but the newline may be escaped with the backslash ('\\
') to allow multiline macros:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #define foo(x) do \{ bar(x); \\
\par }\pard \ql \fi720\li2160\ri0\widctlpar\faauto\adjustright\rin0\lin2160\itap0 {\f2   baz(x); \} while( false)
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 #undef}{\f1  directive may be used to remove a macro\rquote s definition.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_CondCompilation}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Conditional Compilation}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  conditional compilation}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.5.3 Conditional Compilation
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Conditional compilation works similar to the C preprocessor. The following preprocessor directives may be used:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #if }{\i\f2 condition}{\f2 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #ifdef }{\i\f2 symbol}{\f2 
\par #ifndef }{\i\f2 symbol}{\f2 
\par #else
\par #elif }{\i\f2 condition}{\f2 
\par #endif
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Conditions in }{\f2 #if}{\f1  directives use the same operators and precedence as in C. The }{\f2 defined()}{\f1  operator is supported.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_ProgInitialization}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Program Initialization}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  program initialization}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{2.5.4 Program Initialization
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The compiler will insert a call to a special initialization function, }{\f2 _init}{\f1 
, at the start of a program. This default function is part of the RCX API and sets all three outputs to full power in the forward direction (but still turned off). The initialization function can be disabled using the }{\f2 #pragma noinit}{\f1  directive:

\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #pragma noinit // don't do any program initialization
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The default initialization function can be replaced with a different function using the }{\f2 #pragma init}{\f1  directive.}{\f2 
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #pragma init }{\i\f2 function}{\f2  // use custom initialization
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_ReservingStorage}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Reserving Storage}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  reserving storage}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.5.5 Reserving Storage
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The NQC compiler automatically assigns variables to storage locations. However, sometimes it is necessary to prevent the compiler from using certain storage locations. This can be done with the }{\f2 #pragma reserve}{\f1  directive:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #pragma reserve }{\i\f2 start}{\f2 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #pragma reserve }{\i\f2 start}{\f2  }{\i\f2 end}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 This directive forces the compiler to ignore one or more storage locations during variable assignment. Start and end must be numbers that refer
 to valid storage locations. If only a start is provided, then that single location is reserved. If start and end are both specified, then the range of locations from start to end (inclusive) are reserved. The most common use of this directive is to reser
ve locations 0, 1, and/or 2 when using counters for RCX2, Swan, and Spybotics. This is because the RCX2, Swan, and Spybotics counters are overlapped with storage locations 0, 1, and 2. For example, if all three counters were going to be used:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #pragma reserve 0 2
\par }\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_API}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  NQC API}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 api}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3 NQC API
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The NQC API defines a set of constants, functions, values, and macros that provide access to various capabilities of the target such as sensors, outputs, timers, and communication. Some features are only available on certain targets. Where appropriate, a 
s
ection's title will indicate which targets it applies to. The RCX2 and Swan firmwares are a superset of RCX features, so if RCX is listed, then the feature works with the original firmware, the 2.0 firmware, and the Swan firmware. If RCX2 is listed, then 
the feature only applies to the 2.0 firmware and the Swan firmware.  If Swan is listed alone, then the feature only applies to the Swan firmware. CyberMaster, Scout, and Spybotics are indicated by CM, Scout, and Spy respectively.
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The API consists of functio
ns, values, and constants. A function is something that can be called as a statement. Typically it takes some action or configures some parameter. Values represent some parameter or quantity and can be used in expressions. Constants are symbolic names for
 values that have special meanings for the target. Often, a set of constants will be used in conjunction with a function. For example, the }{\f2 PlaySound}{\f1 
 function takes a single argument which determines which sound is to be played. Constants, such as }{\f2 SOUND_UP}{\f1 , are defined for each sound.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Sensors}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sensors}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 sensors}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.1 Sensors
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
There are three sensors, which internally are numbered 0, 1, and 2. This is potentially confusing since they are externally labeled as sensors 1, 2, and 3. To help mitigate this confusion, the sensor names }{\f2 SENSOR_1}{\f1 , }{\f2 SENSOR_2}{\f1 , and }
{\f2 SENSOR_3}{\f1  have been defined. These sensor names may be used in any function that requires a sensor as an argument. Furthermore, the names may also be used whenever a program wishes to read the current value of the sensor:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SENSOR_1; // read sensor and store value in x
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_SensorTypes}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Types and Modes}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super 
K}{\f1  sensors; sensors, types; sensors, modes}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.1.1 Types and Modes\tab 
RCX, CM, Spy
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The sensor ports on the RCX are capable of interfaci
ng to a variety of different sensors (other targets don't support configurable sensor types). It is up to the program to tell the RCX what kind of sensor is attached to each port. A sensor's type may be configured by calling }{\f2 SetSensorType}{\f1 
. There are four sensor types, each corresponding to a specific LEGO sensor. A fifth type (}{\f2 SENSOR_TYPE_NONE}{\f1 
) can be used for reading the raw values of generic passive sensors. In general, a program should configure the type to match the actual sensor. If a sensor port is configured as the wrong type, the RCX may not be able to read it accurately.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Sensor Type\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 SENSOR_TYPE_NONE\tab generic passive sensor
\par SENSOR_TYPE_TOUCH\tab a touch sensor
\par SENSOR_TYPE_TEMPERATURE\tab a temperature sensor
\par SENSOR_TYPE_LIGHT\tab a light sensor
\par SENSOR_TYPE_ROTATION\tab a rotation sensor
\par SENSOR_TYPE_ACTIVE_RAW\tab an active sensor with raw output (Swan only)
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The RCX, Swan, CyberMaster, and Spybotics allow a sensor to be configured in different modes. The sensor mode determines how a sensor's raw value is processed.
 Some modes only make sense for certain types of sensors, for example }{\f2 SENSOR_MODE_ROTATION}{\f1  is useful only with rotation sensors. The sensor mode can be set by calling }{\f2 SetSensorMode}{\f1 
. The possible modes are shown below. Note that since CyberMaster does not s
upport temperature or rotation sensors, the last three modes are restricted to the RCX and Swan only. Spybotics is even more restrictive, allowing only raw, boolean, and percentage modes.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Sensor Mode\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 SENSOR_MODE_RAW\tab raw value from 0 to 1023
\par SENSOR_MODE_BOOL\tab boolean value (0 or 1)
\par SENSOR_MODE_EDGE\tab counts number of boolean transitions
\par SENSOR_MODE_PULSE\tab counts number of boolean periods
\par SENSOR_MODE_PERCENT\tab value from 0 to 100
\par }{\f1\lang1031\langfe1033\langnp1031 SENSOR_MODE_FAHRENHEIT\tab degrees F - RCX only
\par }{\f1 SENSOR_MODE_CELSIUS\tab degrees C - RCX only
\par SENSOR_MODE_ROTATION\tab rotation (16 ticks per revolution) - RCX only
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 When using the RCX or Swan, it is common to set both the type and mode at the same time. The }{\f2 SetSensor}{\f1 
 function makes this process a little easier by providing a single function to call and a set of standard type/mode combinations.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3060\tx6120\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Sensor Configuration\tab Type\tab Mode
\par }\pard \ql \li720\ri0\widctlpar\tx3060\tx6120\faauto\adjustright\rin0\lin720\itap0 {\f1 SENSOR_TOUCH\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_BOOL
\par SENSOR_LIGHT\tab SENSOR_TYPE_LIGHT\tab SENSOR_MODE_PERCENT
\par SENSOR_ROTATION\tab SENSOR_TYPE_ROTATION\tab SENSOR_MODE_ROTATION
\par SENSOR_CELSIUS\tab SENSOR_TYPE_TEMPERATURE\tab SENSOR_MODE_CELSIUS
\par }{\f1\lang1031\langfe1033\langnp1031 SENSOR_FAHRENHEIT\tab SENSOR_TYPE_TEMPERATURE\tab SENSOR_MODE_FAHRENHEIT
\par }{\f1 SENSOR_PULSE\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_PULSE
\par SENSOR_EDGE\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_EDGE
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The RCX and Swan provide a boolean conversion f
or all sensors - not just touch sensors. This boolean conversion is normally based on preset thresholds for the raw value. A "low" value (less than 460) is a boolean value of 1. A high value (greater than 562) is a boolean value of 0. This conversion can 
be modified: a }{\i\f1 slope value}{\f1  between 0 and 31 may be added to a sensor's mode when calling }{\f2 SetSensorMode}{\f1 
. If the sensor's value changes more than the slope value during a certain time (3ms), then the sensor's boolean state will change. This allows the boolean
 state to reflect rapid changes in the raw value. A rapid increase will result in a boolean value of 0, a rapid decrease is a boolean value of 1. 
\par Even when a sensor is configured for some other mode (i.e. }{\f2 SENSOR_MODE_PERCENT}{\f1 ), the boolean conversion will still be carried out.
\par }{\b\f1\fs24 SetSensor(sensor, configuration)\tab Function \endash  RCX
\par }{\f1 Set the type and mode of the given sensor to the specified configuration, which must be a special constant containing 
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 both type and mode information.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensor(SENSOR_1, SENSOR_TOUCH);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSensorType(sensor, type)\tab Function \endash  RCX
\par }{\f1 Set a sensor's type, which must be one of the predefined sensor type constants.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorType(SENSOR_1, SENSOR_TYPE_TOUCH);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSensorMode(sensor, mode)\tab Function - RCX, CM, Spy
\par }{\f1 Set a sensor's mode, which should be one of the predefined sensor mode constants. A slope parameter for boolean conversion, if desired, may be added to the mode (RCX and Swan only).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorMode(SENSOR_1, SENSOR_MODE_RAW); // raw mode
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorMode(SENSOR_1, SENSOR_MODE_RAW + 10) ; // slope 10
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClearSensor(sensor)\tab Function - All
\par }{\f1 Clear the value of a sensor - only affects sensors that are configured to measure a cumulative quantity such as rotation or a pulse count.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearSensor(SENSOR_1);
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_SensorInfo}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sensor Information}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  sensors; sensors, information}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.1.2 Sensor Information

\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
There are a number of values that can be inspected for each sensor. For all of these values the sensor must be specified by its sensor number (0, 1, or 2), and not a sensor name (e.g. }{\f2 SENSOR_1}{\f1 ).
\par }{\b\f1\fs24 SensorValue(n)\tab Value - All
\par }{\f1 Returns the processed sensor reading for sensor n, where n is 0, 1, or 2. This is the same value that is returned by the sensor names (e.g. }{\f2 SENSOR_1}{\f1 ).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorValue(0); // read sensor 1
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SensorType(n)\tab Value \endash  All
\par }{\f1 Returns the configured type of sensor n, which must be 0, 1, or 2. Only the RCX has configurable sensors types, other targets will always return the pre-configured type of the sensor.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2\lang1036\langfe1033\langnp1036 x = SensorType(0);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\lang1036\langfe1033\langnp1036 SensorMode(n)\tab Value - RCX, CM, Spy
\par }{\f1 Returns the current sensor mode for sensor n, which must be 0, 1, or 2.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorMode(0);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SensorValueBool(n)\tab Value \endash  RCX
\par }{\f1 Returns the boolean value of sensor n, which must be 0, 1, or 2. Boolean conversion is either done based on preset cutoffs, or a slope parameter specified by calling }{\f2 SetSensorMode}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorValueBool(0);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SensorValueRaw(n) \tab Value - RCX, Scout, Spy
\par }{\f1 Returns the raw value of sensor n, which must be 0, 1, or 2. Raw values may range from 0 to 1023 (RCX, Spy) or 0 to 255 (Scout).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorValueRaw(0);
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_ScoutLightSensor}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Scout Light Sensor}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  light; sensors; sensors, light; sensors, scout}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{
3.1.3 Scout Light Sensor\tab Scout
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 On the Scout, }{\f2 SENSOR_3}{\f1 
 refers to the built-in light sensor. Reading the light sensor's value (with }{\f2 SENSOR_3}{\f1 ) will return one of three levels: 0 (dark), 1 (normal), or 2 (bright). The sensor's raw value can be read with }{\f2 SensorValueRaw(SENSOR_3)}{\f1 
, but bear in mind that brighter light will result in a }{\i\f1 lower}{\f1  raw value. The conversion of the sensor's raw value (between 0 and 1023) to one of the three levels depends on three parameters: }{\i\f1 lower limit}{\f1 , }{\i\f1 upper limit}{
\f1 , and }{\i\f1 hysteresis}{\f1 . The lower limit is the smallest (brightest) raw value that is still considered }{\i\f1 normal}{\f1 . Values below the lower limit will be considered }{\i\f1 bright}{\f1 . The upper limit is the largest (d
arkest) raw value that is considered normal. Values about this limit are considered }{\i\f1 dark}{\f1 .
\par Hysteresis can be used to prevent the level from changing when the raw value hovers near one of the limits. This is accomplished by making it a little harder to leave
 the dark and bright states than it is to enter them. Specifically, the limit for moving from normal to bright will be a little lower than the limit for moving from bright back to normal. The difference between these two limits is the amount of hysteresis
. A symmetrical case holds for the transition between normal and dark.
\par }{\b\f1\fs24 SetSensorLowerLimit(value)\tab Function - Scout
\par }{\f1 Set the light sensor's lower limit. Value may be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorLowerLimit(100);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSensorUpperLimit(value)\tab Function - Scout
\par }{\f1 Set the light sensor's upper limit. Value may be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorUpperLimit(900);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSensorHysteresis(value)\tab Function - Scout
\par }{\f1 Set the light sensor's hysteresis. Value may be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorHysteresis(20);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CalibrateSensor()\tab Function - Scout
\par }{\f1 Reads the current value of the light sensor, then sets the upper and lower limits to 12.5% above and below the current reading, and sets the hysteresis to 3.12% of the reading.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 CalibrateSensor();
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_SpyboticSensors}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Spybotics Sensors}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  touch; light; sensors; sensors, touch; sensors, light; sensors, spybotics}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{3.1.4 Spybotics Sensors\tab Spy
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Spybotics uses built-in sensors instead of externally connected ones. The touch sensor on the front of the Spybotics brick is }{\f2 SENSOR_1}{\f1 
. It is normally configured in percentage mode, so it has a value of 0 when not pressed, and a value of 100 when pressed. 
\par }{\f2 SENSOR_2}{\f1  is the light sensor (the connector on the back of the brick that is used to communicate with a computer). It is normally configured in percentage mode, where higher numbers indicate brighter light.}{\b\i\f1 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Outputs}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Outputs}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 outputs}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.2 Outputs
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_OutputsPrimitive}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Primitive Calls}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super 
K}{\f1  outputs; outputs, primitive calls}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.2.1 Primitive Calls
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 All of t
he functions dealing with outputs take a set of outputs as their first argument. This set must be a constant. The names }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1 
 are used to identify the three outputs. Multiple outputs can be combined by adding individual outputs together. For example, use }{\f2 OUT_A+OUT_B}{\f1 
 to specify outputs A and B together. The set of outputs must always be a compile time constant (it cannot be a variable).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Output Constant\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 OUT_A\tab output A
\par OUT_B\tab output B
\par OUT_C\tab output C
\par OUT_AB\tab OUT_A + OUT_B
\par OUT_AC\tab OUT_A + OUT_C
\par OUT_BC\tab OUT_B + OUT_C
\par OUT_ABC\tab OUT_A + OUT_B + OUT_C
\par OUT_D\tab virtual output D (Swan only)
\par OUT_E\tab virtual output E (Swan only)
\par OUT_F\tab virtual output F (Swan only)
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Each output has three different attributes: mode, direction, and power level. The mode can be set by calling }{\f2 SetOutput(}{\i\f2 outputs}{\f2 , }{\i\f2 mode}{\f2 )}{\f1 
. The mode parameter should be one of the following constants:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Output Mode\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 OUT_OFF\tab output is off (motor is prevented from turning)
\par OUT_ON\tab output is on (motor will be powered)
\par OUT_FLOAT\tab motor can "coast"
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The other two attributes, direction and power level, may be set at any time, but only have an effect when the output is on. The direction is set with the }{\f2 SetDirection(}{
\i\f2 outputs}{\f2 , }{\i\f2 direction}{\f2 )}{\f1  command. The direction parameter should be one of the following constants:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Direction\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 OUT_FWD\tab Set to forward direction
\par OUT_REV\tab Set to reverse direction
\par OUT_TOGGLE\tab Switch direction to the opposite of what it is presently
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The power level can range 0 (lowest) to 7 (highest). The names }{\f2 OUT_LOW}{\f1 , }{\f2 OUT_HALF}{\f1 , and }{\f2 OUT_FULL}{\f1  a
re defined for use in setting power level. The level is set using the }{\f2 SetPower(}{\i\f2 outputs}{\f2 , }{\i\f2 power}{\f2 )}{\f1  function.
\par Be default, all three motors are set to full power and the forward direction (but still turned off) when a program starts.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetOutput(outputs, mode)\tab Function - All
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the outputs to the specified mode. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1 . Mode must be }{\f2 OUT_ON}{\f1 , }{\f2 OUT_OFF}{\f1 
, or }{\f2 OUT_FLOAT}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 SetOutput(OUT_A + OUT_B, OUT_ON); // turn A and B on
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetDirection(outputs, direction)\tab Function - All
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the outputs to the specified direction. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1 . Direction must be }{\f2 OUT_FWD}{\f1 , }{\f2 
OUT_REV}{\f1 , or }{\f2 OUT_TOGGLE}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 SetDirection(OUT_A, OUT_REV); // make A turn backwards
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetPower(outputs, power)\tab Function - All
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Sets the power level of the specified outputs. Power may be an expression, but should result in a value between 0 and 7. The constants }{\f2 OUT_LOW}{\f1 , }{\f2 OUT_HALF}{\f1 
, and }{\f2 OUT_FULL}{\f1  may also be used.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPower(OUT_A, OUT_FULL); // A full power
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPower(OUT_B, x);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OutputStatus(n)\tab Value - All
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Returns the current output setting for motor n. Note that n must be 0, 1, or 2 \endash  not }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , or }{\f2 OUT_C}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = OutputStatus(0); // status of OUT_A
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_OutputsConvenience}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Convenience Calls}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  outputs; outputs, convenience calls}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.2.2 Convenience Calls
\par }\pard\plain \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Since control of outputs is such a common feature of programs, a number of convenience functions are provided that make it easier to work with the outputs. It should be noted that these commands do not provide any new functionality above the }{\f2 
SetOutput}{\f1  and }{\f2 SetDirection}{\f1  commands. They are merely convenient ways to make programs more concise.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 On(outputs)\tab Function - All
\par }{\f1 Turn specified outputs on. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 On(OUT_A + OUT_C); // turn on outputs A and C
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Off(outputs)\tab Function - All
\par }{\f1 Turn specified outputs off. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Off(OUT_A); // turn off output A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Float(outputs)\tab Function - All
\par }{\f1 Make outputs float. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Float(OUT_A); // float output A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Fwd(outputs)\tab Function - All
\par }{\f1 Set outputs to forward direction. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Fwd(OUT_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Rev(outputs)\tab Function - All
\par }{\f1 Set outputs to reverse direction. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Rev(OUT_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Toggle(outputs)\tab Function - All
\par }{\f1 Flip the direction of the outputs. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Toggle(OUT_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnFwd(outputs)\tab Function - All
\par }{\f1 Set outputs to forward direction and turn them on. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnFwd(OUT_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnRev(outputs)\tab Function - All
\par }{\f1 Set outputs to reverse direction and turn them on. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnRev(OUT_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnFor(outputs, time)\tab Function - All
\par }{\f1 Turn outputs on for a specified amount of time, then turn them off. Outputs is one or more of }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , and }{\f2 OUT_C}{\f1  added together. Time is measures 
in 10ms increments (one second = 100) and may be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnFor(OUT_A, x);
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_OutputsGlobal}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Global Control}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K
}{\f1  outputs; outputs, global control}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.2.3 Global Control\tab RCX2, Scout, Spy

\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24\lang1036\langfe1033\langnp1036 SetGlobalOutput(outputs, mode)\tab Function - RCX2, Scout, Spy

\par }{\f1 Disable or re-enable outputs depending on the mode parameter. If mode is }{\f2 OUT_OFF}{\f1 , then the outputs will be turned off and disabled. While disabled any subsequent calls to }{\f2 SetOutput()}{\f1  (including convenience functions such as }
{\f2 On()}{\f1 ) will be ignored. Using a mode of }{\f2 OUT_FLOAT}{\f1  will put the outputs in float mode before disabling them. Outputs can be re-enabled by calling }{\f2 SetGlobalOutput()}{\f1  with a mode of }{\f2 OUT_ON}{\f1 
. Note that enabling an output doesn't immediately turn it on - it just allows future calls to }{\f2 SetOutput()}{\f1  to take effect.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetGlobalOutput(OUT_A, OUT_OFF); // disable output A
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetGlobalOutput(OUT_A, OUT_ON); // enable output A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetGlobalDirection(outputs, direction)\tab Function - RCX2, Scout, Spy
\par }{\f1 Reverses or restores the directions of outputs. The direction parameter should be }{\f2 OUT_FWD}{\f1 , }{\f2 OUT_REV}{\f1 , or }{\f2 OUT_TOGGLE}{\f1 . Normal behavior is a global direction of }{\f2 OUT_FWD}{\f1 . When the global direction is }{\f2 
OUT_REV}{\f1 , then the actual output direction will be the opposite of whatever the regular output calls request. Calling }{\f2 SetGlobalDirection()}{\f1  with }{\f2 OUT_TOGGLE}{\f1  will switch between normal and opposite behavior.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetGlobalDirection(OUT_A, OUT_REV); // opposite direction
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetGlobalDirection(OUT_A, OUT_FWD); // normal direction
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMaxPower(outputs, power)\tab Function - RCX2, Scout, Spy
\par }{\f1 Sets the maximum power level allowed for the outputs. The power level may be a variable, but should have a value between }{\f2 OUT_LOW}{\f1  and }{\f2 OUT_FULL}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMaxPower(OUT_A, OUT_HALF);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GlobalOutputStatus(n)\tab Value - RCX2, Scout, Spy
\par }{\f1 Returns the current global output setting for motor n. Note that n must be 0, 1, or 2 - not }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , or }{\f2 OUT_C}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = GlobalOutputStatus(0); // global status of OUT_A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EnableOutput(outputs)\tab Function - RCX2, Scout, Spy
\par }{\f1 A helper function for enabling the specified outputs.  Use }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , or }{\f2 OUT_C}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 EnableOutput(OUT_A+OUT_B); // enable output OUT_A and OUT_B
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 This is the same as using }{\f2 SetGlobalOutput}{\f1  with the }{\f2 OUT_ON}{\f1  mode.
\par }{\b\f1\fs24 DisableOutput(outputs)\tab Function - RCX2, Scout, Spy
\par }{\f1 A helper function for disabling the specified outputs.  Use }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , or }{\f2 OUT_C}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 DisableOutput(OUT_A+OUT_B); // disable output OUT_A and OUT_B
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 This is the same as using }{\f2 SetGlobalOutput}{\f1  with the }{\f2 OUT_OFF}{\f1  mode.
\par }{\b\f1\fs24 InvertOutput(outputs)\tab Function - RCX2, Scout, Spy
\par }{\f1 A helper function for inverting the direction of the specified outputs.  Use }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , or }{\f2 OUT_C}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 InvertOutput(OUT_A+OUT_B); // reverse direction for OUT_A and OUT_B
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 This is the same as using }{\f2 SetGlobalDirection}{\f1  with the }{\f2 OUT_REV}{\f1  direction.
\par }{\b\f1\fs24 ObvertOutput(outputs)\tab Function - RCX2, Scout, Spy
\par }{\f1 A helper function for returning the direction of the specified outputs to forward.  Use }{\f2 OUT_A}{\f1 , }{\f2 OUT_B}{\f1 , or }{\f2 OUT_C}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ObvertOutput(OUT_A+OUT_B); // normal direction for OUT_A and OUT_B
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 This is the same as using }{\f2 SetGlobalDirection}{\f1  with the }{\f2 OUT_FWD}{\f1  direction.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_SpyboticOutputs}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Spybotics Outputs}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  outputs; outputs, spybotics}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.2.4 Spybotics Outputs\tab Spy

\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Spybotics has two built-in motors. }{\f2 OUT_A}{\f6\fs22  }{\f1 refers to the right motor, and }{\f2 OUT_B}{\f6\fs22 
 }{\f1 is for the left motor. }{\f2 OUT_C}{\f6\fs22  }{\f1 
will send VLL commands out the rear LED (the one used for communication with a computer). This allows a VLL device, such as a Micro-Scout, to be used as a third motor for Spybotics. The same LED may be controlled using the }{\f2 SendVLL() }{\f1 and }{\f2 
SetLight()}{\f1  functions.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Sound}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sound}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 sound}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.3 Sound
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24 PlaySound(sound)\tab Function - All
\par }{\f1 Plays a preset sound. The sound argument must be a constant (except on Spybotics, which allows a variable to be used). The following constants are pre-defined for use with PlaySound: }{\f2 SOUND_CLICK}{\f1 , }{\f2 SOUND_DOUBLE_BEEP}{\f1 , }{\f2 
SOUND_DOWN}{\f1 , }{\f2 SOUND_UP}{\f1 , }{\f2 SOUND_LOW_BEEP}{\f1 , }{\f2 SOUND_FAST_UP}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 PlaySound(SOUND_CLICK);
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The Swan firmware adds two additional sounds: }{\f2 SOUND_SHORT_BLIP}{\f1  and }{\f2 SOUND_EXCEPTION}{\f1 .
\par The Spybotics brick has additional sound support via this function.  It has 64 preset sounds in ROM (numbered 0-63).  The additional 58 constants defined for these sounds are:
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Spybot Sound Effect Constants
\par }{\f1 SOUND_SHOCKED, SOUND_FIRE_LASER, SOUND_FIRE_ELECTRONET, SOUND_FIRE_SPINNER, SOUND_HIT_BY_LASER, SO
UND_HIT_BY_ELECTRONET, SOUND_HIT_BY_SPINNER, SOUND_TAG, SOUND_CRASH, SOUND_FIGHT, SOUND_GOT_IT, SOUND_GENERAL_ALERT, SOUND_OUT_OF_ENERGY_ALERT, SOUND_LOW_ENERGY_ALERT, SOUND_SCORE_ALERT, SOUND_TIME_ALERT, SOUND_PROXIMITY_ALERT, SOUND_DANGER_ALERT, SOUND_B
O
MB_ALERT, SOUND_FINAL_COUNTDOWN, SOUND_TICK_TOCK, SOUND_GOTO, SOUND_SCAN, SOUND_POINT_TO, SOUND_ACTIVATE_SHIELDS, SOUND_ACTIVATE_REFLECT, SOUND_ACTIVATE_CLOAK, SOUND_ACTIVATE_FLASH_BLIND, SOUND_MAGNET, SOUND_QUAD_DAMAGE, SOUND_REPULSE, SOUND_TURBO, SOUND_
F
REEZE, SOUND_SLOW, SOUND_REVERSE, SOUND_DIZZY, SOUND_BOOST, SOUND_DEACTIVATE_SHIELDS, SOUND_DEACTIVATE_REFLECT, SOUND_DEACTIVATE_CLOAK, SOUND_REFLECT, SOUND_EXPLOSION, SOUND_BIG_EXPLOSION, SOUND_PLACE_BOMB, SOUND_HIT_BY_WIND, SOUND_OUCH, SOUND_GEIGER, SOU
ND_WHISTLE, SOUND_IM_IT, SOUND_HELP, SOUND_SIREN, SOUND_BURNT, SOUND_GRINDED, SOUND_SMACKED, SOUND_TRILL_UP, SOUND_TRILL_DOWN, SOUND_YELL, SOUND_WHISPER
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 A special constant, SOUND_NONE, is also defined to indicate that no sound should be played.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PlayTone(frequency, duration)\tab Function - All
\par }{\f1 Plays a single tone of the specified frequency and duration. The frequency is in Hz and can be a variable for RCX2, Scout, and Spybotics, but has to be constant for RCX and CyberMaster. The duration is in 100ths of a second and must be a constant.

\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 PlayTone(440, 50); // Play 'A' for one half second
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MuteSound()\tab Function - RCX2, Scout, Spy
\par }{\f1 Stops all sounds and tones from being played.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 MuteSound();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 UnmuteSound()\tab Function - RCX2, Scout, Spy
\par }{\f1 Restores normal operation of sounds and tones.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 UnmuteSound();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClearSound()\tab Function - RCX2, Spy
\par }{\f1 Removes any pending sounds from the sound buffer.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearSound();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SelectSounds(group) \tab Function - Scout
\par }{\f1 Selects which group of system sounds should be used. The group must be a constant.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SelectSounds(0);
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Display}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  LCD Display}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  display; lcd}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{\i0 3.4 LCD Display\tab RCX}{
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The RCX and Swan have seven different display modes as shown below.  It defaults to }{\f2 DISPLAY_WATCH}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Mode\tab LCD Contents
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 DISPLAY_WATCH\tab show the system "watch"
\par DISPLAY_SENSOR_1\tab show value of sensor 1
\par DISPLAY_SENSOR_2\tab show value of sensor 2
\par DISPLAY_SENSOR_3\tab show value of sensor 3
\par DISPLAY_}{\f2 OUT_A}{\f1 \tab show setting for output A
\par DISPLAY_}{\f2 OUT_B}{\f1 \tab show setting for output B
\par DISPLAY_}{\f2 OUT_C}{\f1 \tab show setting for output C
\par DISPLAY_USER\tab show user selected source (RCX2 or Swan)
\par DISPLAY_EXCEPTION\tab show exceptions (Swan)
\par 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The RCX2 and Swan add an eighth display mode - }{\f2 DISPLAY_USER}{\f1 . User display mode continuously reads a source value and updates the displ
ay. It can optionally display a decimal point at any position within the number. This allows the display to give the illusion of working with fractions even though all values are stored internally as integers. For example, the following call will set the 
user display to show the value 1234 with two digits appearing after the decimal point, resulting in "12.34" appearing on the LCD.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetUserDisplay(1234, 2);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The following short program illustrates the update of the user display:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 task main()
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 \{
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 ClearTimer(0);
\par SetUserDisplay(Timer(0), 0);
\par until(false);
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
Because the user display mode continuously updates the LCD, there are certain restrictions on the source value. If a variable is used it must be assigned to a global storage location. The best way to ensure this 
is to make the variable a global one. There can also be some strange side effects. For example, if a variable is being displayed and later used as the target of a calculation, it is possible for the display to show some intermediate results of the calcula
tion:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 int x;
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 task main()
\par \{
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 SetUserDisplay(x, 0);
\par while(true)
\par \{
\par }\pard \ql \li2160\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin2160\itap0 {\f2 // display may briefly show 1!
\par x = 1 + Timer(0);
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 \}
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SelectDisplay(mode)\tab Function \endash  RCX
\par }{\f1 Select a display mode.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SelectDisplay(DISPLAY_SENSOR_1); // view sensor 1
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetUserDisplay(value, precision)\tab Function - RCX2
\par }{\f1 Set the LCD display to continuously monitor the specified value. Precision specifies the number of digits to the right of the decimal point. A precision of zero shows no decimal point.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetUserDisplay(Timer(0), 0); // view timer 0
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\lang1036\langfe1033\langnp1036 \page }{\cs16\lang1036\langfe1033\super\langnp1036 #
{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Communication}}$
{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Communication}}K{\footnote 
\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  communication}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{\lang1036\langfe1033\langnp1036 
3.5 Communication
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\lang1036\langfe1033\langnp1036 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\lang1036\langfe1033\langnp1036 \page }{
\cs16\lang1036\langfe1033\super\langnp1036 #{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{
\f1\lang1036\langfe1033\langnp1036  IDH_NQC_Messages}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{
\f1\lang1036\langfe1033\langnp1036  Messages}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{
\f1\lang1036\langfe1033\langnp1036  messages}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\lang1036\langfe1033\langnp1036 
3.5.1 Messages\tab RCX, Scout
\par }\pard\plain \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The RCX, Swan, and Scout can send and receive simple messages using IR. A message can have a value from 
0 to 255, but the use of message 0 is discouraged. The most recently received message is remembered and can be accessed as }{\f2 Message()}{\f1 . If no message has been received, }{\f2 Message()}{\f1 
 will return 0. Note that due to the nature of IR communication, receiving is disabled while a message is being transmitted.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClearMessage()\tab Function - RCX, Scout
\par }{\f1 Clear the message buffer. This facilitates detection of the next received message since the program can then wait for }{\f2 Message()}{\f1  to become non-zero:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearMessage(); // clear out the received message
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 until(Message() > 0 ); // wait for next message
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendMessage(message)\tab Function - RCX, Scout
\par }{\f1 Send an IR message. Message may be any expression, but the RCX can only send messages with a value between 0 and 255, so only the lowest 8 bits of the argument are used.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendMessage(3); // send message 3
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendMessage(259); // another way to send message 3
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMessage(message)\tab Function \endash  RCX2
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the IR message. Message may be any expression, but the bricks can only set messages with a value between 0 and 255, so only the lowest 8 bits of the argument are used.

\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMessage(3); // set message 3
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetTxPower(power)\tab Function - RCX, Scout
\par }{\f1 Set the power level for IR transmission. Power should be one of the constants }{\f2 TX_POWER_LO}{\f1  or }{\f2 TX_POWER_HI}{\f1 .
\par }{\b\f1\fs24 MessageParam()\tab Value - Swan
\par }{\f1 Read the message parameter.  The Swan firmware supports a 2 byte message parameter in addition to the single byte supported by the RCX firmware.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MessageParam(); // read the received message parameter value
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendMessageWithParam(const int &m, const int &p) \tab Function - Swan
\par }{\f1 Send an IR message with an additional parameter.  The first parameter is restricted a single byte while the second parameter can be two bytes.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendMessageWithParam(3, 1024);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMessageByteParam(const int m, const int p) \tab Function - Swan
\par }{\f1 Set the IR message and its parameter using constants.  The parameter must be a single byte value.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMessageByteParam(3, 43);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMessageWordParam(const int m, const int p) \tab Function - Swan
\par }{\f1 Set the IR message and its parameter using constants.  The parameter can be 2 bytes.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMessageWordParam(3, 1024);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMessageVariableParam(const int &m, const int &p) \tab Function - Swan
\par }{\f1 Set the IR message and its parameter using variables.  The parameter can be 2 bytes.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMessageVariableParam(x, y);
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Serial}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Serial}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 serial}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.5.2 Serial\tab RCX2, Spy
\par }\pard\plain \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The RCX2, Swan, and Spybotics can transmit serial data out the IR port. 
Prior to transmitting any data, the communication and packet settings must be specified. Then, for each transmission, data should be placed in the transmit buffer, then sent using the }{\f2 SendSerial()}{\f1  function.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 For the RCX2 and Swan the communication settings are set with }{\f2 SetSerialComm}{\f1 .  This determines how bits are sent over IR. Possible values are shown below.

\par }\pard \ql \li720\ri0\sb120\widctlpar\tx5040\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Option\tab Effect
\par }\pard \ql \li720\ri0\widctlpar\tx5040\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f1 SERIAL_COMM_DEFAULT\tab default settings
\par SERIAL_COMM_4800\tab 4800 baud
\par SERIAL_COMM_DUTY25\tab 25% duty cycle
\par SERIAL_COMM_76KHZ\tab 76kHz carrier
\par SERIAL_COMM_RCX\tab same as default
\par SERIAL_COMM_RC\tab 4800/76kHz/25%
\par SERIAL_COMM_SPYBOT\tab 4800/76kHz/25%
\par SERIAL_COMM_9600\tab 9600 baud (Swan)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The default is to send data at 2400 baud using a 50% duty cycle on a 38kHz carrier. To specify multiple options (such as 4800 baud wi
th 25% duty cycle), combine the individual options using bitwise or (}{\f2 SERIAL_COMM_4800 | SERIAL_COMM_DUTY25}{\f1 ).
\par The RCX2 and Swan allow you to set the packet settings with }{\f2 SetSerialPacket}{\f1 .  This controls how bytes are assembled into packets. Possible values are shown below.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Option\tab Effect
\par }\pard \ql \li720\ri0\widctlpar\tx4320\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f1 SERIAL_PACKET_DEFAULT\tab no packet format - just data bytes
\par SERIAL_PACKET_PREAMBLE\tab send a packet preamble
\par SERIAL_PACKET_NEGATED\tab follow each byte with its complement
\par SERIAL_PACKET_CHECKSUM\tab include a checksum for each packet
\par SERIAL_PACKET_RCX\tab standard RCX format (preamble,
\par \tab negated data, and checksum)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Note that negated packets always include a checksum, so the }{\f2 SERIAL_PACKET_CHECKSUM}{\f1  option is only meaningful when }{\f2 SERIAL_PACKET_NEGATED}{\f1 
 is not specified. Likewise the preamble, negated, and checksum settings are implied by }{\f2 SERIAL_PACKET_RCX}{\f1 .
\par The transmit buffer can hold up to 16 data bytes. These bytes may be set using }{\f2 SetSerialData}{\f1 , then transmitted by calling }{\f2 SendSerial}{\f1 . For example, the following code sends two bytes (0x12 and 0x34) out the serial port:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialComm(SERIAL_COMM_DEFAULT);
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialPacket(SERIAL_PACKET_DEFAULT);
\par SetSerialData(0, 0x12);
\par SetSerialData(1, 0x34);
\par SendSerial(0, 2);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Spybotics uses a different mechanism for configuring the serial transmission parameters.  Use }{\f2 SetSerialType}{\f1 
 to specify the transmission type with the constants described in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3618\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Option\tab Effect
\par }\pard \ql \li720\ri0\widctlpar\tx3618\faauto\adjustright\rin0\lin720\itap0 {\f1 SERIAL_TYPE_SPYBOT\tab Spybotics type
\par SERIAL_TYPE_RCX\tab RCX type
\par SERIAL_TYPE_RC\tab RC type
\par SERIAL_TYPE_USER\tab User-defined type
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use }{\f2 SetSerialBaud}{\f1  to specify the baud rate with the constants described in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3618\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Option\tab Effect
\par }\pard \ql \li720\ri0\widctlpar\tx3618\faauto\adjustright\rin0\lin720\itap0 {\f1 SERIAL_BAUD_2400\tab 2400 baud
\par SERIAL_BAUD_4800\tab 4800 baud
\par SERIAL_BAUD_9600\tab 9600 baud
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use }{\f2 SetSerialChannel}{\f1  to specify the transmission channel with the constants described in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3618\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Option\tab Effect
\par }\pard \ql \li720\ri0\widctlpar\tx3618\faauto\adjustright\rin0\lin720\itap0 {\f1 SERIAL_CHANNEL_IR\tab IR channel
\par SERIAL_CHANNEL_PC\tab PC channel (visible light)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use }{\f2 SetSerialPreamblePos}{\f1  to specify the position of the preamble in the 16 bytes of serial data.  Use }{\f2 SetSerialPreambleLen}{\f1 
 to specify the length of the preamble.  Use }{\f2 SetSerialChecksum}{\f1  to specify the checksum type with the constants described in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Option\tab Effect
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 SERIAL_CHECKSUM_NONE\tab No checksum
\par SERIAL_CHECKSUM_SUM\tab Sum checksum
\par SERIAL_CHECKSUM_ZERO_SUM\tab Zero sum checksum
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use }{\f2 SetSerialBiPhase}{\f1  to specify the bi-phase mode with the constants described in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Option\tab Effect
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 SERIAL_BIPHASE_OFF\tab No bi-phase
\par SERIAL_BIPHASE_ON\tab Use bi-phase
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialComm(settings)\tab Function - RCX2
\par }{\f1 Set the communication settings, which determine how the bits are sent over IR
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialComm(SERIAL_COMM_DEFAULT);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialPacket(settings)\tab Function - RCX2
\par }{\f1 Set the packet settings, which control how bytes are assembled into packets.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialPacket(SERIAL_PACKET_DEFAULT);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialData(n, value)\tab Function - RCX2, Spy
\par }{\f1 Set one byte of data in the transmit buffer. N is the index of the byte to set (0-15), and value can be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialData(3, x); // set byte 3 to x
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SerialData(n)\tab Value - RCX2, Spy
\par }{\f1 Returns the value of a byte in the transmit buffer (NOT received data). N must be a constant between 0 and 15.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialData(7) ; // read byte #7
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SerialPacket()\tab Value - RCX2
\par }{\f1 Returns the packet data formatting configuration.
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li360\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin360\itap0 {\f1 bit 0 : Preamble (0x55 0xFF 0x00)
\par bit 1 : Negated (incl. negated checksum)
\par bit 2 : Checksum (if not negated)
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialPacket(); // read packet configuration
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SerialComm()\tab Value - RCX2
\par }{\f1 Returns the UART transmit parameter configuration.  
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li360\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin360\itap0 {\f1 bit 0 : Baudrate (0 == 2400 baud, 1 == 4800 baud)
\par bit 1 : Carrier freq (0 == 38 kHz, 1 == 76 kHz)
\par bit 2 : Dutycycle (0 == 50 %, 1 == 25 %)
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialComm(); // read UART transmit parameters}{\b\f1\fs24  
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSerial(start, count)\tab Function - RCX2, Spy
\par }{\f1 
Use the contents of the transmit buffer to build a packet and send it out the IR port (according to the current packet and communication settings). Start and count are both constants that specify the first byte and the number of bytes within the buffer to
 be sent.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSerial(0, 2); // send first two bytes in buffer
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 InitSpybotComm()\tab Function - RCX2
\par }{\f1 Use this function to configure the serial communication registers in preparation for sending messages using the Spybot protocol.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 InitSpybotComm(); // prepare to send IR using Spybot protocol
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotMsg()\tab Function - RCX2
\par }{\f1 Use this function to send a 7 byte Spybot message which was previously set via a call to }{\f2 SetSpybotMessage}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotMsg(); 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSpybotMessage(mode, myID, addr, cmd, hi, lo)\tab Function - RCX2
\par }{\f1 Use this function to set the contents of a Spybot message.  The message can then be sent repeatedly via calls to }{\f2 SendSpybotMsg}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSpybotMessage(MSG_BROADCAST, 9, 0, CMD_FIRE_LASER, 1, 100); 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotMessage(mode, myID, addr, cmd, hi, lo)\tab Function - RCX2
\par }{\f1 Use this function to send a 7 byte Spybot message.  This function calls }{\f2 InitSpybotComm}{\f1 , }{\f2 SetSpybotMessage}{\f1 , and }{\f2 SendSpybotMsg}{\f1  in sequence.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotMessage(MSG_BROADCAST, 9, 0, CMD_FIRE_LASER, 1, 100);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotCtrlMsg()\tab Function - RCX2
\par }{\f1 Use this function to send a 2 byte Spybot controller message which was previously set via a call to }{\f2 SetSpybotCtrlMessage}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotCtrlMsg(); 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSpybotCtrlMessage(nMyID, nMsg)\tab Function - RCX2
\par }{\f1 Use this function to set the contents of a Spybot controller message.  The message can then be sent repeatedly via calls to }{\f2 SendSpybotCtrlMsg}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSpybotCtrlMessage(ID_CTRL_1, SPY_CTRL_BTN_1); 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotCtrlMessage(nMyID, nMsg)\tab Function - RCX2
\par }{\f1 Use this function to send a 2 byte Spybot controller message.  This function calls }{\f2 InitSpybotComm}{\f1 , }{\f2 SetSpybotCtrlMessage}{\f1 , and }{\f2 SendSpybotCtrlMsg}{\f1  in sequence.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotCtrlMessage(ID_CTRL_1, SPY_CTRL_BTN_1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotCtrlPingMsg()\tab Function - RCX2
\par }{\f1 Use this function to send a 2 byte Spybot controller ping message which was previously set via a call to }{\f2 SetSpybotCtrlPingMessage}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotCtrlPingMsg();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSpybotCtrlPingMessage(nID)\tab Function - RCX2
\par }{\f1 Use this function to set the contents of a Spybot controller ping message.  The message can then be sent repeatedly via calls to }{\f2 SendSpybotCtrlPingMsg}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSpybotCtrlPingMessage(ID_CTRL_1); 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotCtrlPingMessage(nID)\tab Function - RCX2
\par }{\f1 Use this function to send a 2 byte Spybot controller ping message.  This function calls }{\f2 InitSpybotComm}{\f1 , }{\f2 SetSpybotCtrlPingMessage}{\f1 , and }{\f2 SendSpybotCtrlPingMsg}{\f1  in sequence.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotCtrlPingMessage(ID_CTRL_1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotPingMsg()\tab Function - RCX2
\par }{\f1 Use this function to send a 4 byte Spybot ping message which was previously set via a call to }{\f2 SetSpybotPingMessage}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotPingMsg();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSpybotPing(nLinkID, nMyID, nInfo)\tab Function \endash  RCX2
\par }{\f1 Use this function to set the contents of a Spybot ping message.  The message can then be sent repeatedly via calls to }{\f2 SendSpybotPingMsg}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSpybotPingMessage(ID_CTRL_1, ID_MIN_BOT+1, 10);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotPing(nLinkID, nMyID, nInfo)\tab Function - RCX2
\par }{\f1 Use this function to send a 2 byte Spybot ping message.  This function calls }{\f2 InitSpybotComm}{\f1 , }{\f2 SetSpybotPingMessage}{\f1 , and }{\f2 SendSpybotPingMsg}{\f1  in sequence.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotPingMessage(ID_CTRL_1, ID_MIN_BOT+1, 10);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 InitRCComm()\tab Function - RCX2
\par }{\f1 Use this function to configure the serial communication registers in preparation for sending messages using the Spybot RC protocol.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 InitRCComm(); // prepare to send IR using RC protocol
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendRCMsg()\tab Function - RCX2
\par }{\f1 Use this function to send a 4 byte RC message which was previously set via a call to }{\f2 SetRCMessage}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendRCMsg();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetRCMessage(nChannel, nLeft, nRight)\tab Function - RCX2
\par }{\f1 Use this function to set the contents of a Spybot RC message.  The message can then be sent repeatedly via calls to }{\f2 SendRCMsg}{\f1 .
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetRCMessage(RC_CHANNEL_2, RC_CMD_FWD, RC_CMD_FWD);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendRCMessage(nChannel, nLeft, nRight)\tab Function - RCX2
\par }{\f1 Use this function to send a 2 byte Spybot ping message.  This function calls }{\f2 InitRCComm}{\f1 , }{\f2 SetRCMessage}{\f1 , and }{\f2 SendRCMsg}{\f1  in sequence.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendRCMessage(RC_CHANNEL_2, RC_CMD_FWD, RC_CMD_FWD);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DefaultSerialComm()\tab Value - Swan
\par }{\f1 Returns the default UART transmit parameter configuration.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = DefaultSerialComm(); // read the default UART transmit config
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DefaultSerialPacket()\tab Value - Swan
\par }{\f1 Returns the default packet data formatting configuration.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = DefaultSerialPacket(); // read the default packet config
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetDefaultSerialComm(settings)\tab Function - Swan
\par }{\f1 Set the default communication settings, which determine how the bits are sent over IR
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetDefaultSerialComm(SERIAL_COMM_DEFAULT);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetDefaultSerialPacket(settings)\tab Function - Swan
\par }{\f1 Set the default packet settings, which control how bytes are assembled into packets.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetDefaultSerialPacket(SERIAL_PACKET_DEFAULT);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SerialType()\tab Value - Spy
\par }{\f1 Returns the type of the serial transmission.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialType(); // SERIAL_TYPE_USER ??
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialType(type)\tab Function - Spy
\par }{\f1 Sets the type of the serial transmission.  
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialType(SERIAL_TYPE_USER); // set type to user
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use one of the following constants: }{\f2 SERIAL_TYPE_SPYBOT, SERIAL_TYPE_RCX, SERIAL_TYPE_RC, SERIAL_TYPE_USER}{\f1 .  
\par }{\b\f1\fs24 SerialBaud()\tab Value - Spy
\par }{\f1 Returns the baud rate of the serial transmission.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialBaud(); // SERIAL_BAUD_2400 ??
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialBaud(baud)\tab Function - Spy
\par }{\f1 Sets the baud rate of the serial transmission.  
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialBaud(SERIAL_BAUD_2400); // set baud to 2400
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use one of the following constants: }{\f2 SERIAL_BAUD_2400, SERIAL_BAUD_4800, SERIAL_BAUD_9600}{\f1 .  
\par }{\b\f1\fs24 SerialChannel()\tab Value - Spy
\par }{\f1 Returns the transmission channel.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialChannel(); // SERIAL_CHANNEL_PC ??
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialChannel(channel)\tab Function - Spy
\par }{\f1 Sets the transmission channel.  
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialChannel(SERIAL_CHANNEL_IR); // set channel to IR
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use one of the following constants: }{\f2 SERIAL_CHANNEL_IR, SERIAL_CHANNEL_PC}{\f1 .  
\par }{\b\f1\fs24 SerialPreamblePos()\tab Value - Spy
\par }{\f1 Returns the preamble position within the serial data buffer.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialPreamblePos();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialPreamblePos(n)\tab Function - Spy
\par }{\f1 Sets the position of the preamble within the serial data buffer.  
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialPreamblePos(12); // set preamble pos to 12
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SerialPreambleLen()\tab Value - Spy
\par }{\f1 Returns the preamble length.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialPreambleLen();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialPreambleLen(n)\tab Function - Spy
\par }{\f1 Sets the length of the preamble.  
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialPreambleLen(3); // set preamble length to 3
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SerialChecksum()\tab Value - Spy
\par }{\f1 Returns the transmission checksum type.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialChecksum(); // SERIAL_CHECKSUM_SUM ??
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialChecksum(check)\tab Function - Spy
\par }{\f1 Sets the transmission checksum type.  
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialChecksum(SERIAL_CHECKSUM_SUM); // use Sum checksum
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use one of the following constants: }{\f2 SERIAL_CHECKSUM_NONE, SERIAL_CHECKSUM_SUM, SERIAL_CHECKSUM_ZERO_SUM}{\f1 .  
\par }{\b\f1\fs24 SerialBiPhase()\tab Value - Spy
\par }{\f1 Returns the transmission bi-phase mode.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialBiPhase(); // SERIAL_BIPHASE_OFF ??
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSerialBiPhase(mode)\tab Function - Spy
\par }{\f1 Sets the transmission bi-phase mode.  
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSerialBiPhase(SERIAL_BIPHASE_OFF); // no bi-phase
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Use one of the following constants: }{\f2 SERIAL_BIPHASE_OFF, SERIAL_BIPHASE_ON}{\f1 .  
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1031\langfe1033\super\langnp1031 #}{\f1\lang1031\langfe1033\langnp1031  IDH_NQC_VLL}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  VLL}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  vll}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}
}{3.5.3 VLL\tab Scout, Spy
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24 SendVLL(value)\tab Function \endash  Scout, Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Sends a Visible Light Link (VLL) command, which can be used to communicate with the MicroScout or Code Pilot. The specific VLL commands are described in the Scout SDK.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendVLL(4); // send VLL command #4
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Timers}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Timers}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 timers}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.6 Timers}{
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
All targets provide several independent timers with 100ms resolution (10 ticks per second). The Scout provides 3 such timers while the RCX, Swan, CyberMaster, and Spybotics provide 4. The timers wrap around to 0 after 32767 ticks (about 55 minutes). The
 value of a timer can be read using }{\f2 Timer(}{\i\f2 n}{\f2 )}{\f1 
, where n is a constant that determines which timer to use (0-2 for Scout, 0-3 for the others). RCX2, Swan, and Spybotics provides the ability to read the same timers with higher resolution by using }{\f2 FastTimer(}{\i\f2 n}{\f2 )}{\f1 ,
 which returns the timer's value with 10ms resolution (100 ticks per second).
\par }{\b\f1\fs24 ClearTimer(n)\tab Function - All
\par }{\f1 Reset the specified timer to 0.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearTimer(0);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Timer(n)\tab Value - All
\par }{\f1 Return the current value of specified timer (in 100ms resolution).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Timer(T1);
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1\lang1036\langfe1033\langnp1036 Timer constants\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1\lang1036\langfe1033\langnp1036 T1\tab timer 1
\par T2\tab timer 2
\par T3\tab timer 3
\par T4\tab timer 4
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetTimer(n, value)\tab Function - RCX2, Spy
\par }{\f1 Set a timer to a specific value (which may be any expression).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetTimer(0, x);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 FastTimer(n)\tab Value - RCX2, Spy
\par }{\f1 Return the current value of specified timer in 10ms resolution.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = FastTimer(0);
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Counters}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Counters}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 counters}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.7 Counters\tab RCX2, Scout, Spy}{
\par }\pard\plain \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Counters are like very simple variables that can be incremented, decremented, and cleared. Th
e Scout provides two counters (0 and 1), while RCX2, Swan, and Spybotics provide three (0, 1, and 2). In the case of RCX2, Swan, and Spybotics, these counters are overlapped with global storage locations 0-2, so if they are going to be used as counters, a
 }{\f2 #pragma reserve}{\f1  should be used to prevent NQC from using the storage location for a regular variable. For example, to use counter 1:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 #pragma reserve 1
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClearCounter(n)\tab Function - RCX2, Scout, Spy
\par }{\f1 Reset counter n to 0. N must be 0 or 1 for Scout, 0-2 for RCX2, Swan and Spybotics.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearCounter(1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 IncCounter(n)\tab Function - RCX2, Scout, Spy
\par }{\f1 Increment counter n by 1. N must be 0 or 1 for Scout, 0-2 for RCX2, Swan and Spybotics.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 IncCounter(1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DecCounter(n)\tab Function - RCX2, Scout, Spy
\par }{\f1 Decrement counter n by 1. N must be 0 or 1 for Scout, 0-2 for RCX2, Swan and Spybotics.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 DecCounter(1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Counter(n)\tab Value \endash  RCX2, Scout, Spy
\par }{\f1 Return the current value of counter n. N must be 0 or 1 for Scout, 0-2 for RCX2, Swan and Spybotics.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Counter(1);
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_AccessControl}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Access Control}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K
}{\f1  access control}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.8 Access Control\tab RCX2, Scout, Spy}{
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Access control is implemented primarily by the }{\f2 acquire}{\f1  statement. The }{\f2 SetPriority}{\f1 
 function can be used to set a task's priority, and the following constants may be used to specify resources in an acquire statement. Note that the user defined resources are only available on the RCX2 and Swan.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Constant\tab Resource
\par }\pard \ql \li720\ri0\widctlpar\tx3600\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f1 ACQUIRE_}{\f2 OUT_A}{\f1 ,\tab outputs
\par ACQUIRE_}{\f2 OUT_B}{\f1 ,
\par ACQUIRE_}{\f2 OUT_C}{\f1 
\par ACQUIRE_SOUND\tab sound
\par ACQUIRE_LED\tab LEDs (Spybotics only)
\par ACQUIRE_USER_1,\tab user defined - RCX2 and Swan only
\par }{\f1\lang1036\langfe1033\langnp1036 ACQUIRE_USER_2,
\par ACQUIRE_USER_3,
\par ACQUIRE_USER_4
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetPriority(p)\tab Function - RCX2, Scout, Spy
\par }{\f1 Set a task's priority to p, which must be a constant. RCX2, Swan, and Spybotics support priorities 0-255, while Scout supports priorities 0-7. Note that lower numbers are higher priority.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPriority(1);
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Events}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Events}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 events}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.9 Events\tab RCX2, Scout, Spy}{
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Although the RCX2, Swan, Scout, and Spybotics share a common event mechanism, the RCX2, Swan and Spybotics 
provide 16 completely configurable events while the Scout has 15 predefined events. The only functions common to both targets are the commands to inspect or force events.
\par }{\b\f1\fs24 ActiveEvents(task)\tab Value - RCX2, Scout, Spy
\par }{\f1 Return the set of events that have been triggered for a given task.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = ActiveEvents(0);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CurrentEvents() \tab Value - RCX2, Spy
\par }{\f1 Return the set of events that have been triggered for the active task.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = CurrentEvents();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Event(events)\tab Function - RCX2, Scout, Spy
\par }{\f1 Manually triggers the specified events.
 This can be useful in testing event handling of the program, or in other cases simulating an event based on other criteria. Note that the specification of the events themselves is slightly different between brick types. RCX2, Swan, and Spybotics use the 
EVENT_MASK macro to compute an event mask, while Scout has predefined masks.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Event(EVENT_MASK(3)); // triggering an RCX2 event
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Event(EVENT_1_PRESSED); // triggering a Scout event
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_RCX2Events}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  RCX2 Events}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  events; events, RCX2}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036 
 cc}}}{3.9.1 Configurable Events\tab RCX2, Spy
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
RCX2, Swan, and Spybotics provide an extremely flexible event system. There are 16 events, each of which can be mapped to one of several event sources (the stimulus that can trigger the event), and an event type (the criteria for 
triggering). A number of other parameters may also be specified depending on the event type. For all of the configuration calls an event is identified by its event number - a constant from 0 to 15.
\par Legal event sources are sensors, timers, counters, or the message buffer. An event is configured by calling }{\f2 SetEvent(}{\i\f2 event}{\f2 , }{\i\f2 source}{\f2 , }{\i\f2 type}{\f2 )}{\f1 
, where event is a constant event number (0-15), source is the event source itself, and type is one of the types shown below (some combinations of sources and types are illegal).
\par }\pard \ql \li360\ri0\sb120\widctlpar\tx3960\tx7200\tx8640\faauto\adjustright\rin0\lin360\itap0 {\b\f1 Event Type\tab Condition\tab Event Source
\par }\pard \ql \li360\ri0\widctlpar\tx3960\tx7200\tx8640\faauto\adjustright\rin0\lin360\itap0 {\f1 EVENT_TYPE_PRESSED\tab value becomes on\tab sensors only
\par EVENT_TYPE_RELEASED\tab value becomes off\tab sensors only
\par EVENT_TYPE_PULSE\tab value goes from off to on to off\tab sensors only (RCX2)
\par EVENT_TYPE_EDGE\tab value goes from on to off or vice versa\tab sensors only (RCX2)
\par EVENT_TYPE_FASTCHANGE\tab value changes rapidly\tab sensors only (RCX2)
\par EVENT_TYPE_LOW\tab value becomes low\tab any
\par EVENT_TYPE_NORMAL\tab value becomes normal\tab any
\par EVENT_TYPE_HIGH\tab value becomes high\tab any
\par EVENT_TYPE_CLICK\tab value from low to high back to low\tab any
\par EVENT_TYPE_DOUBLECLICK\tab two clicks within a certain time\tab any (RCX2)
\par EVENT_TYPE_MESSAGE\tab new message received\tab Message() only (RCX2)
\par EVENT_TYPE_ENTRY_FOUND\tab world entry found\tab VLL() only (Spy)
\par EVENT_TYPE_MSG_DISCARD\tab Message discarded\tab VLL() only (Spy)
\par EVENT_TYPE_MSG_RECEIVED\tab Message received\tab VLL() only (Spy)
\par EVENT_TYPE_VLL_MSG_RECEIVED\tab VLL message received\tab VLL() only (Spy)
\par EVENT_TYPE_ENTRY_CHANGED\tab World entry changed\tab VLL() only (Spy)
\par EVENT_TYPE_4\tab event type 4\tab any (Swan)
\par EVENT_TYPE_5\tab event type 5\tab any (Swan)
\par EVENT_TYPE_6\tab event type 6\tab any (Swan)
\par EVENT_TYPE_VIRTUAL_MOTOR_CHANGE virtual motor changes\tab any (Swan)
\par EVENT_TYPE_VIRTUAL_MOTOR_POWER virtual motor power\tab any (Swan)
\par EVENT_TYPE_VIRTUAL_SENSOR_DEF\tab virtual sensor def\tab any (Swan)
\par EVENT_TYPE_INFRARED_IDLE\tab infrared goes idle\tab any (Swan)
\par EVENT_TYPE_RESET\tab reset\tab any (Swan)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Th
e first four event types make use of a sensor's boolean value, thus are most useful with touch sensors. For example, to set event #2 to be triggered when a touch sensor on port 1 is pressed, the following call could be made:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEvent(2, SENSOR_1, EVENT_TYPE_PRESSED);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 In order for }{\f2 EVENT_TYPE_PULSE}{\f1  or }{\f2 EVENT_TYPE_EDGE}{\f1  to be used, the sensor must be configured in the }{\f2 SENSOR_MODE_PULSE}{\f1  or }{\f2 
SENSOR_MODE_EDGE}{\f1  respectively.
\par }{\f2 EVENT_TYPE_FASTCHANGE}{\f1  should be used with sensors that have been configured with a slope parameter. When the raw value changes faster than the slope parameter an }{\f2 EVENT_TYPE_FASTCHANGE}{\f1  event will be triggered.
\par The next three types (}{\f2 EVENT_TYPE_LOW}{\f1 , }{\f2 EVENT_TYPE_NORMAL}{\f1 , and }{\f2 EVENT_TYPE_HIGH}{\f1 ) convert an event source's v
alue into one of three ranges (low, normal, or high), and trigger an event when the value moves from one range into another. The ranges are defined by the }{\i\f1 lower limit}{\f1  and }{\i\f1 upper limit}{\f1 
 for the event. When the source value is lower than the lower limit, the source is considered low. When the source value is higher than the upper limit, the source is considered high. The source is normal whenever it is between the limits.
\par The following example configures event #3 to trigger when the sensor on port 2's value goe
s into the high range. The upper limit is set for 80, and the lower limit is set for 50. This configuration is typical of how an event can be triggered when a light sensor detected a bright light.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEvent(3, SENSOR_2, EVENT_TYPE_HIGH);
\par }\pard \ql \li720\ri0\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetLowerLimit(3, 50);
\par SetUpperLimit(3, 80);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
A hysteresis parameter can be used to provide more stable transitions in cases where the source value may jitter. Hysteresis works by making the transition from low to normal a little higher than the transition from normal to low. 
In a sense, it makes it easier to get into the low range than get out of it. A symmetrical case applies to the transition between normal and high.
\par A transition from low to high back to low will trigger a }{\f2 EVENT_TYPE_CLICK}{\f1  event, provided that the entire sequence is faster than the }{\i\f1 click time}{\f1 
 for the event. If two successive clicks occur and the time between clicks is also less than the click time, then an }{\f2 EVENT_TYPE_DOUBLECLICK}{\f1  event will be triggered. The system also keeps track of the total number of clicks for each event.

\par The last event type, }{\f2 EVENT_TYPE_MESSAGE}{\f1 , is only valid when }{\f2 Message()}{\f1  is used as the event source. The event will be triggered whenever a new message arrives (even if its value is the same as a previous message).
\par The }{\f2 monitor}{\f1  statement and some API functions (such as }{\f2 ActiveEvents()}{\f1  or }{\f2 Event()}{\f1 
) need to handle multiple events. This is done by converting each event number to an event mask, and then combining the masks with a bitwise OR. The }{\f2 EVENT_MASK(}{\i\f2 event}{\f2 )}{\f1  macro converts an event number to a
 mask. For example, to monitor events 2 and 3, the following statement could be used:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 monitor(EVENT_MASK(2) | EVENT_MASK(3))
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetEvent(event, source, type)\tab Function - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Configure an event (a number from 0 to 15) to use the specified source and type. Both event and type must be constants, and source should be the actual source expression.

\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEvent(2, Timer(0), EVENT_TYPE_HIGH);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClearEvent(event)\tab Value - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Clear the configuration for the specified event. This prevents it from triggering until it is re-configured.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearEvent(2); // clear event #2
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClearAllEvents()\tab Value - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Clear the configurations for all events.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearAllEvents();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EventState(event)\tab Value - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the state of a given event. States are 0: Low, 1: Normal, 2: High, 3: Undefined, 4: Start calibrating, 5: Calibrating in process.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = EventState(2);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CalibrateEvent(event, lower, upper, hyst)\tab Function - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Calibrate the event by taking an actu
al sensor reading and then applying the specified lower, upper, and hyst ratios to determine actual limits and hysteresis value. The specific formulas for calibration depend on sensor type and are explained in the LEGO SDK. Calibration is not instantaneou
s - }{\f2 EventState()}{\f1  can be checked to determine when the calibration is complete (typically about 50ms).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 CalibrateEvent(2, 50, 50, 20);
\par }\pard \ql \li720\ri0\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 until(EventState(2) != 5); // wait for calibration
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetUpperLimit(event, limit)\tab Function - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the upper limit for the event, where event is a constant event number and limit can be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetUpperLimit(2, x); // set upper limit for #2 to x
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 UpperLimit(event)\tab Value - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current upper limit for the specified event number.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = UpperLimit(2); // get upper limit for event 2
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetLowerLimit(event, limit)\tab Function - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the lower limit for the event, where event is a constant event number and limit can be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetLowerLimit(2, x); // set lower limit for #2 to x
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 LowerLimit(event)\tab Value - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current lower limit for the specified event number.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = LowerLimit(2); // get lower limit for event 2
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetHysteresis(event, value)\tab Function - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the hysteresis for the event, where event is a constant event number and value can be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetHysteresis(2, x);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Hysteresis(event)\tab Value - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current hysteresis for the specified event number.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Hysteresis(2);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetClickTime(event, value)\tab Function - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
Set the click time for the event, where event is a constant event number and value can be any expression. The time is specified in increments of 10ms, so one second would be a value of 100.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetClickTime(2, x);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClickTime(event)\tab Value - RCX2, Spy
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current click time for the specified event number.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = ClickTime(2);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetClickCounter(event, value)\tab Function - RCX2
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the click counter for the event, where event is a constant event number and value can be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetClickCounter(2, x);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClickCounter(event)\tab Value - RCX2
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current click counter for the specified event number.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = ClickCounter(2);
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NQC_ScoutEvents}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Scout Events}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  events; events, scout}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.9.2 Scout Events\tab Scout
\par }\pard\plain \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The Scout provides 15 events, each of which has a predefined meaning as shown in the table below.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3960\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Event Name\tab Condition
\par }\pard \ql \li720\ri0\widctlpar\tx3960\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f1 EVENT_1_PRESSED\tab sensor 1 pressed
\par EVENT_1_RELEASED\tab sensor 1 released
\par EVENT_2_PRESSED\tab sensor 2 pressed
\par EVENT_2_RELEASED\tab sensor 2 released
\par EVENT_LIGHT_HIGH\tab light sensor "high"
\par EVENT_LIGHT_NORMAL\tab light sensor "normal"
\par EVENT_LIGHT_LOW\tab light sensor "low"
\par EVENT_LIGHT_CLICK\tab low to high to low
\par EVENT_LIGHT_DOUBLECLICK\tab two clicks
\par EVENT_COUNTER_0\tab counter 0 over limit
\par EVENT_COUNTER_1\tab counter 1 over limit
\par EVENT_TIMER_0\tab timer 0 over limit
\par EVENT_TIMER_1\tab timer 1 over limit
\par EVENT_TIMER_2\tab timer 2 over limit
\par EVENT_MESSAGE\tab new message received
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The first four events are triggered by touch sensors connected to the two sensor ports. }{\f2 EVENT_LIGHT_HIGH}{\f1 , }{\f2 EVENT_LIGHT_NORMAL}{\f1 , and }{\f2 
EVENT_LIGHT_LOW}{\f1  are triggered by the light sensor's value changing from one range to another. The ranges are defined by }{\f2 SetSensorUpperLimit}{\f1 , }{\f2 SetSensorLowerLimit}{\f1 , and }{\f2 SetSensorHysteresis}{\f1 
 which were described previously.
\par }{\f2 EVENT_LIGHT_CLICK}{\f1  and }{\f2 EVENT_LIGHT_DOUBLECLICK}{\f1  are also triggered by the light sensor. A click is a transition from low to high and back to low within a certain amount of time, called the }{\i\f1 click time}{\f1 .
\par Each counter has a counter limit. When the counter exceeds this limit, }{\f2 EVENT_COUNTER_0}{\f1  or }{\f2 EVENT_COUNTER_1}{\f1  is triggered. Timers also have a limit, and they generate }{\f2 EVENT_TIMER_0}{\f1 , }{\f2 EVENT_TIMER_1}{\f1 , and }{\f2 
EVENT_TIMER_2}{\f1 .
\par }{\f2 EVENT_MESSAGE}{\f1  is triggered whenever a new IR message is received.
\par }{\b\f1\fs24 SetSensorClickTime(value)\tab Function - Scout
\par }{\f1 Set the click time used to generate events from the light sensor. Value should be specified in increments of 10ms, and may be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorClickTime(x);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetCounterLimit(n, value)\tab Function - Scout
\par }{\f1 Set the limit for counter n. N must be 0 or 1, and value may be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetCounterLimit(0, 100); // set counter 0 limit to 100
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetTimerLimit(n, value)\tab Function - Scout
\par }{\f1 Set the limit for timer n. N must be 0, 1, or 2, and value may be any expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetTimerLimit(1, 100); // set timer 1 limit to 100
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\tqr\tx8640\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_Datalogging}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Data Logging}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  data; logging}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.10 Data Logging\tab RCX}{
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The RCX contains a datalog which can be used to store readings from sensors, timers, variables, and the system watch. Before adding data, the datalog first needs to be cre
ated using the CreateDatalog(size) command. The 'size' parameter must be a constant and determines how many data points the datalog can hold.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 CreateDatalog(100); // datalog for 100 points
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Values can then be added to the datalog using AddToDatalog(value). W
hen the datalog is uploaded to a computer it will show both the value itself and the source of the value (timer, variable, etc). The datalog directly supports the following data sources: timers, sensor values, variables, and the system watch. Other data t
y
pes (such as a constant or random number) may also be logged, but in this case NQC will first move the value into a variable and then log the variable. The values will still be captured faithfully in the datalog, but the sources of the data may be a bit m
isleading.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 AddToDatalog(Timer(0)); // add timer 0 to datalog
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 AddToDatalog(x); // add variable 'x'
\par AddToDatalog(7); // add 7 - will look like a variable
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The RCX itself cannot read values back out of the datalog. The datalog must be uploaded to a host compute
r. The specifics of uploading the datalog depend on the NQC environment being used. For example, in the command line version of NQC, the following commands will upload and print the datalog:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 nqc -datalog
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 nqc -datalog_full
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The Swan (and the standard LEGO fi
rmware version 3.30 which is available via the ROBOLAB software) adds the ability to read values and types out of the datalog.  New firmware sources are used to implement this functionality.  Use the DatalogType, DatalogValue, and DatalogByte functions to
 programmatically access these sources.
\par }{\b\f1\fs24 CreateDatalog(size)\tab Function \endash  RCX
\par }{\f1 Create a datalog of the specified }{\i\f1 size}{\f1  (which must be a constant). A size of 0 clears the existing datalog without creating a new one.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 CreateDatalog(100); // datalog for 100 points
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 AddToDatalog(value)\tab Function \endash  RCX
\par }{\f1 Add the }{\i\f1 value}{\f1 , which may be an expression, to the datalog. If the datalog is full the call has no effect.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 AddToDatalog(x);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 UploadDatalog(start, count)\tab Function \endash  RCX
\par }{\f1 Initiate and upload of }{\i\f1 count}{\f1  data points beginning at }{\i\f1 start}{\f1 . This is of relatively little use since the host computer usually initiates the upload.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 UploadDatalog(0, 100); // upload entire 100 point log
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DatalogType(n)\tab Value \endash  Swan (and RCX2+)
\par }{\f1 Read or write the 8-bit datalog type specified by the parameter.  If a variable is used the type is read or written indirectly.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = DatalogType(0);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DatalogValue(n)\tab Value \endash  Swan (and RCX2+)
\par }{\f1 Read or write the 16-bit datalog value specified by the parameter.  If a variable is used the value is read or written indirectly.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = DatalogValue(0);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DatalogByte(n)\tab Value \endash  Swan (and RCX2+)
\par }{\f1 Read or write the 8-bit datalog byte specified by the parameter.  If a variable is used the byte is read or written indirectly.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = DatalogByte(0);
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_General}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  General Features}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  general features}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.11 General Features}{
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24 Wait(time)\tab Function - All
\par }{\f1 Make a task sleep for specified amount of time (in 100ths of a second). The time argument may be an expression or a constant:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Wait(100); // wait 1 second
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Wait(Random(100)); // wait random time up to 1 second
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 StopAllTasks()\tab Function - All
\par }{\f1 Stop all currently running tasks. This will halt the program completely, so any code following this command will be ignored.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 StopAllTasks(); // stop the program
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Random(n)\tab Value - All
\par }{\f1 Return a random number between 0 and n. N must be a constant.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Random(10);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetRandomSeed(n)\tab Function - RCX2, Spy
\par }{\f1 Seed the random number generator with n. N may be an expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetRandomSeed(x); // seed with value of x
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 BatteryLevel()\tab Value - RCX2, Spy
\par }{\f1 Return the battery level in millivolts.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = BatteryLevel();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 FirmwareVersion()\tab Value - RCX2, Spy
\par }{\f1 Return the firmware version as an integer. For example, version 3.2.6 is 326.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = FirmwareVersion();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSleepTime(minutes)\tab Function - All
\par }{\f1 Set the sleep timeout the requested number of minutes (which must be a constant). Specifying 0 minutes disables the sleep feature.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSleepTime(5); // sleep after 5 minutes
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSleepTime(0) ; // disable sleep time
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SleepNow()\tab Function - All
\par }{\f1 Force the device to go to sleep. Only works if the sleep time is non-zero.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SleepNow(); // go to sleep
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Indirect(n)\tab Value - RCX2, Spy
\par }{\f1 Read the value of a variable indirectly.  The parameter is the address of a global variable whose value is the address of the variable you wish to read.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Indirect(0); // the value of the variable pointed to by variable 0
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetIndirectVar(const int &v, const int &n)\tab Value - RCX2, Spy
\par }{\f1 Set the value of a variable indirectly.  The first parameter is the global variable whose value is the address of the variable you wish to set.  The second parameter is the value you wish to set it to.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetIndirectVar(x, 200);
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_RCXSpecific}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  RCX Specific Features}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  rcx specific features}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.12 RCX Specific Features}{

\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24 Program()\tab Value \endash  RCX
\par }{\f1 Number of the currently selected program.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Program();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SelectProgram(n)\tab Function - RCX2
\par }{\f1 Select the specified program and start running it. Note that programs are numbered 0-4 (not 1-5 as displayed on the LCD).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SelectProgram(3);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Watch()\tab Value - RCX
\par }{\f1 Return the value of the system clock in minutes.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Watch();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetWatch(hours, minutes)\tab Function - RCX
\par }{\f1 Set the system watch to the specified number of hours and minutes. Hours must be a constant between 0 and 23 inclusive. Minutes must be a constant between 0 and 59 inclusive.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetWatch(3, 15); // set watch to 3:15
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_ScoutSpecific}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Scout Specific Features}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  scout specific features}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.13 Scout Specific Features}{

\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24 SetScoutRules(motion, touch, light, time, fx)\tab Function - Scout
\par }{\f1 Set the various rules used by the scout in stand-alone mode.
\par }{\b\f1\fs24 ScoutRules(n)\tab Value - Scout
\par }{\f1 Return current setting for one of the rules. N should be a constant between 0 and 4.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = ScoutRules(1); // get setting for rule #1
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetScoutMode(mode)\tab Function - Scout
\par }{\f1 Put the scout into stand-alone (0) or power (1) mode. As a programming call it really only makes sense to put into stand-alone mode since it would already be in power mode to run an NQC program.
\par }{\b\f1\fs24 SetEventFeedback(events)\tab Function - Scout
\par }{\f1 Set which events should be accompanied by audio feedback.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEventFeedback(EVENT_1_PRESSED);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EventFeedback()\tab Value - Scout
\par }{\f1 Return the set of events that have audio feedback.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = EventFeedback();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetLight(mode)\tab Function - Scout
\par }{\f1 Control the Scout's LED. Mode must be LIGHT_ON or LIGHT_OFF.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetLight(LIGHT_ON); // turn on LED
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_CyberMasterSpecific}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  CyberMaster Specific Features}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  cybermaster specific features}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.14 CyberMaster Specific Features}{
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 CyberMaster provides alternate names for the sensors: }{\f2 SENSOR_L}{\f1 , }{\f2 SENSOR_M}{\f1 , and }{
\f2 SENSOR_R}{\f1 . It also provides alternate names for the outputs: }{\f2 OUT_L}{\f1 , }{\f2 OUT_R}{\f1 , }{\f2 OUT_X}{\f1 
. Additionally, the two internal motors have tachometers, which measure 'clicks' and speed as the motors turn. There are about 50 clicks per revolution of the shaft. The tachometers
 can be used, for example, to create a robot which can detect if it has bumped into an object without using any external sensors. The tachometers have maximum values of 32767 and do not differentiate between directions. They will also count up if the shaf
t is turned by hand, including when no program is running.
\par }{\b\f1\fs24 Drive(motor0, motor1)\tab Function - CM
\par }{\f1 Turns on both motors at the power levels specified. If a power level is negative, then the motor will run in reverse. Equivalent to this code:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPower(OUT_L, abs(power0));
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPower(OUT_R, abs(power1));
\par if(power0 < 0)
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 \{ SetDirection(OUT_L, OUT_REV) \}
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 else
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 \{ SetDirection(OUT_L, OUT_FWD) \}
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 if(power1 < 0)
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 \{ SetDirection(OUT_R, OUT_REV) \}
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 else
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 \{ SetDirection(OUT_R, OUT_FWD) \}
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetOutput(OUT_L + OUT_R, OUT_ON);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnWait(motors, n time)\tab Function - CM
\par }{\f1 Turns on the motors specified, all at the same power level then waits for the given time. The time is in 10ths of a second, with a maximum of 255 (or 25.5 seconds). Equivalent to this code:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPower(motors, abs(power));
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 if(power < 0)
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 \{ SetDirection(motors, OUT_REV) \}
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 else
\par }\pard \ql \li1440\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin1440\itap0 {\f2 \{ SetDirection(motors, OUT_FWD) \}
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetOutput(motors, OUT_ON);
\par Wait( time * 10);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnWaitDifferent(motors, n0, n1, n2, time)\tab Function - CM
\par }{\f1 Like OnWait(), except different power levels can be given for each motor.
\par }{\b\f1\fs24 ClearTachoCounter(motors)\tab Function - CM
\par }{\f1 Resets the tachometer for the motor(s) specified.
\par }{\b\f1\fs24 TachoCount(n)\tab Value - CM
\par }{\f1 Returns the current value of the tachometer for a specified motor.
\par }{\b\f1\fs24 TachoSpeed(n)\tab Value - CM
\par }{\f1 Returns the current speed of the tachomete
r for a specified motor. The speed is fairly constant for an unladen motor at any speed, with a maximum value of 90. (This will be lower as your batteries lose power!) The value drops as the load on the motor increases. A value of 0 indicates that the mot
or is stalled.
\par }{\b\f1\fs24 ExternalMotorRunning()\tab Value - CM
\par }{\f1 This is actually a measure of the current being drawn by the motor. The values returned tends to fluctuate slightly, but are, on average, as follows for an unladen motor:
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f1 0 motor is floating
\par }\pard \ql \li720\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f1 1 motor is off
\par }\pard \ql \fi720\li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 \tab <
=7 motor is running at around this power level. This is where the value fluctuates the most (probably related to the PWM method used to drive the motors.) In any case, you should know what power level you set the motor to in the first place. 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The value increases as the load on the motor increases, and a value between 260 and 300 indicates that the motor has stalled.
\par }{\b\f1\fs24 AGC()\tab Value - CM
\par }{\f1 Return the current value of the automatic gain control on the RF receiver. This can be used to give a very rough (and somewhat inaccurate) measure of the distance between the CyberMaster and the RF transmitter.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = AGC();
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_SpyboticSpecific}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Spybotics Specific Features}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  spybotics specific features}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 
3.15 Spybotics Specific Features}{
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24 SetLED(mode, value)\tab Function - Spy
\par }{\f1 A single command, }{\f2 SetLED(}{\i\f2 mode}{\f2 , }{\i\f2 value}{\f2 )}{\f1 
, can be used to control all of the different LEDs on the Spybotics brick. The function takes two arguments, a mode and a value. The mode parameter selects which group of LEDs to control, and how they should be affected.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul LED Mode Constants
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f1 
LED_MODE_ON, LED_MODE_BLINK, LED_MODE_DURATION, LED_MODE_SCALE, LED_MODE_SCALE_BLINK, LED_MODE_SCALE_DURATION, LED_MODE_RED_SCALE, LED_MODE_RED_SCALE_BLINK, LED_MODE_GREEN_SCALE, LED_MODE_GREEN_SCALE_BLINK, 
LED_MODE_YELLOW, LED_MODE_YELLOW_BLINK, LED_MODE_YELLOW_DURATION, LED_MODE_VLL, LED_MODE_VLL_BLINK, LED_MODE_VLL_DURATION
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The meaning of value parameter depends on the mode. Sometimes it is a mask of which LEDs should be controlled (as with }{\f2 LED_MODE_ON}{\f1 ). S
ometimes it is a single value that is used to determine how many LEDs to turn on (as with }{\f2 LED_MODE_SCALE}{\f1 ). 
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul LED Value Constants
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f1 LED_RED1, LED_RED2, LED_RED3, LED_GREEN1, LED_GREEN2, LED_GREEN3, LED_YELLOW, LED_ALL_RED, LED_ALL_GREEN, LED_ALL_RED_GREEN, LED_ALL
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Here is a short program that blinks all six of the top red/green LEDs.
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 task main()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 SetLED(LED_MODE_BLINK, 0x3f);
\par Wait(200);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 LED(mode)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the value of the LED control registers.  Use the LED Mode constants as the parameter.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 x = LED(LED_MODE_ON);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetAnimation(number)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
A more sophisticated way to control the top LEDs is to use animations. An animation is a sequence of LED patterns. Each pattern is displayed for a certain amount of time, then the next pattern is displayed. Animations are activated using the }{\f2 
SetAnimation(number)}{\f1  function. There are 8 pre-defined animations in ROM.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul ROM Animation Constants
\par }\pard \ql \li720\ri0\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f1 ANIMATION_SCAN, ANIMATION_SPARKLE, ANIMATION_FLASH, ANIMATION_RED_TO_GREEN, ANIMATION_GREEN_TO_RED, ANIMATION_POINT_FORWARD, ANIMATION_ALARM, ANIMATION_THINKING

\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Here is a short program that runs a ROM animation.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 task main\line \{\line   SetAnimation(ANIMATION_SCAN);\line   Wait(200);\line \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ANIMATION\tab Resource Declaration - Spy}{\f1  
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 It is also possible to define custom animations. This is done
 with a resource declaration (a new NQC feature). The declaration must be done at the global level (not within a task/sub/function), and must occur before the animation is used in the program. An animation declaration looks like this:
\par 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 ANIMATION }{\i\f2 name}{\f2  \{ }{\i\f2 data}{\f2  ... \};
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par Where }{\i\f1 name}{\f1  is a name you pick for the animation, and }{\i\f1 data}{\f1 
 is a series of bytes that determine the animation's appearance. The data bytes are interpreted in pairs, with the first byte of each pair specifying a mask of the LEDs that should be turne
d on, and the second byte determining how many 10ms ticks that pattern should be displayed for. A pair of 255,0 causes the animation to loop continuously.  You can also use the following two special commands (in a comma-separated list) to define an animat
ion:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Animation Commands
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 AnimateLED(led_mask, time)
\par RepeatAnimation()
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par Once the animation is declared, its name may be used as an argument to }{\f2 SetAnimation()}{\f1 . Here is an example:
\par 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 ANIMATION my_animation \{ 
\par   AnimateLED(1, 10), 
\par   AnimateLED(2, 10), 
\par   AnimateLED(4, 10), 
\par   AnimateLED(2, 10), 
\par   RepeatAnimation()
\par \};
\par 
\par task main()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 SetAnimation(my_animation);
\par Wait(500);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 AnimateLED(led_mask, time)\tab Animation Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 User animations contain LED patterns.  The led_mask parameter is a mask of the LEDs 
that should be turned on (see the LED Value Constants).  The time parameter is the number of 10 ms steps to display the pattern for, ranging from 1 to 255 (2.55 seconds).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 AnimateLED(LED_RED1, 10)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RepeatAnimation()\tab Animation Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Repeat the user animation from the beginning.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 RepeatAnimation()
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SOUNDEFFECT\tab Resource Declaration - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 With Spybotics you can define up to 15 of your own sound effects using a resource declaration. The declaration must be done at the global level (not within a task/sub/functi
on), and must occur before the sound effect is used in the program. A sound effect declaration looks like this:
\par 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 SOUNDEFFECT }{\i\f2 name}{\f2  \{ }{\i\f2 data}{\f2  ... \};
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par Where }{\i\f1 name}{\f1  is a name you pick for the sound effect, and }{\i\f1 data}{\f1  is a series of bytes that determine the sound effect sound. Use the following special commands (in a comma-separated list) to define the sound effect.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul User Sound Effect Commands
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 Gate(on, period)
\par GateOff()
\par Glide(freq1, freq2, time)
\par Vibrato(freq1, freq2, time)
\par WaitEffect(time)
\par FixedWaitEffect(time)
\par Tone(freq, time)
\par FixedTone(freq, time)
\par RepeatEffect()
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par Once the sound effect is declared, its name may be used as an argument to }{\f2 PlaySound()}{\f1 . Here is an example:
\par 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 SOUNDEFFECT my_effect \{ 
\par   Gate(1, 10),
\par   Glide(294, 660, 60),
\par   GateOff(),
\par   WaitEffect(50),
\par   Vibrato(294, 660, 60),
\par   FixedTone(500, 50),
\par   RepeatEffect()
\par \};
\par 
\par task main()
\par \{
\par }\pard \ql \fi720\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 PlaySound(my_effect);
\par Wait(500);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 \}
\par 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Gate(on, period)\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 User sound effects can be changed by turning the sound on and off rapidly
.  The on parameter is that portion of the period during which sound is output.  The period parameter is the length of the gate cycle in 10 ms steps from 1 to 255 (2.55 seconds).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 Gate(1, 10)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GateOff()\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Stop gating the sound effect.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 GateOff()
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Glide(frequency1, frequency2, duration)\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 User sound effects can contain sounds which glide from one frequency to another
.  The two frequency parameters can range from 32 to 20000 Hz.  The duration parameter is the time to glide from the first frequency to the second in 10 ms steps from 1 to 255 (2.55 seconds).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 Glide(294, 660, 60)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Vibrato(frequency1, frequency2, duration)\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
User sound effects can contain vibratos, where the sound alternates rapidly between two frequencies.  The two frequency parameters can range from 32 to 20000 Hz.  The duration parameter is the number of 10 ms steps from 1 to 255 (2.55 seconds).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 Vibrato(294, 660, 60)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WaitEffect(duration)\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 User sound effects can contain wait periods.  The duration parameter is the length of the wait in 10 ms steps from 1 to 255 (2.55 seconds).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 WaitEffect(60)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 FixedWaitEffect(duration)\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
User sound effects can contain fixed wait periods.  The duration parameter is the length of the wait in 10 ms steps from 1 to 255 (2.55 seconds).  This wait period will be unaffected by adjustments to the sound effect time.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 FixedWaitEffect(60)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Tone(frequency, duration)\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
User sound effects can contain simple tones.  The frequency parameter is the tone to be played, ranging from 32 to 20000 Hz.  The duration parameter is the length of the wait in 10 ms steps from 1 to 255 (2.55 seconds).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 Tone(440, 60)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 FixedTone(frequency, duration)\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 User sound effects can contain fixed wait periods.  The frequency parameter is the tone to be played, ranging from 32 to 20000 Hz.  The duration paramete
r is the length of the wait in 10 ms steps from 1 to 255 (2.55 seconds).  This wait period will be unaffected by adjustments to the sound effect sound or time.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 FixedTone(440, 60)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RepeatEffect()\tab Sound Effect Macro - Spy
\par }\pard \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 Repeat the user sound effect from the beginning.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 RepeatEffect()
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EffectSound()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the value of the sound effect frequency adjustment register. 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = EffectSound(); // read the sound effect freq adj
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EffectTime()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the value of the sound effect time adjustment register.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = EffectTime(); // read the sound effect time adj
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetEffectSound(s)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the value of the sound effect frequency adjustment register.  The parameter can range from 0 to 255 where 100 = 1.0 * the frequency.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEffectSound(50); // cut freq in half (50%)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetEffectTime(t)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the value of the sound effect time adjustment register.  The parameter can range from 0 to 255 where 100 = 1.0 * the duration.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEffectTime(50); // cut sound duration in half (50%)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClearWorld()\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Clear the contents of the world relationship table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearWorld(); // empty world table
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 FindWorld(v, relationSource, criteria, threshold)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Sets variable v to the next entry in the world relationship table that matches the criteria specified.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 task main()\line \{\line   int v = -1;\line   ClearWorld();\line   FindWorld(v, SPY_RANGE, REL_GT, RANGE_NOWHERE);\line   while (v != -1)\line   \{\line 
    SetWorldNote(v, 40);\line     SetTargetID(v);\line     FindWorld(v, SPY_RANGE, REL_GT, RANGE_NOWHERE);\line   \}
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul 
\par }{\b\f1\ul\lang1036\langfe1033\langnp1036 Criteria Constants
\par }{\f1\lang1036\langfe1033\langnp1036 REL_GT, REL_LT, REL_EQ, REL_NE
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Target(relationSource)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the value from the specified relation source for the current target.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Target(SPY_RANGE); // get the target range
\par 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Relation Source Constants
\par }{\f1 SPY_TARGETID, SPY_NOTE, SPY_LINKID, SPY_RANGE, SPY_DIRECTION, SPY_ASPECT, SPY_INFO, SPY_SHORTID
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetTargetID(v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the current target based on the value of variable v.  Setting the target to }{\f2 TARGET_NONE}{\f1  stops tracking.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 int x = 5;\line SetTargetID(x); // set the target ID
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul ID Constants
\par }{\f1 TARGET_NONE, ID_NONE, ID_CTRL1, ID_CTRL2, ID_CTRL3, ID_CTRL4, ID_CTRL5, ID_CTRL6, ID_PC, ID_BOT_MIN, ID_BOT_MAX
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetTargetNote(v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the current target's game note.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetTargetNote(50); // set the target's note to 50
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GetWorld(n, t, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set variable v to the value in the relationSource for the specified target.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 GetWorld(SPY_RANGE, t, v); // set v to target t's range
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 World(relationSource, target)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Access the value in the relationSource for the specified target.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = }{\f2\cf2 World}{\f2 (SPY_RANGE, t); // set x to target t's range}{\b\f1\fs24  
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GetWorldAspect(t, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set variable v to the specified target's aspect.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 GetWorldAspect(t, v); // set v to target t's aspect
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Aspect Constants
\par }{\f1 ASPECT_FRONT_LEFT, ASPECT_FRONT, ASPECT_FRONT_RIGHT, ASPECT_BACK_RIGHT, ASPECT_BACK, ASPECT_BACK_LEFT
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WorldAspect(t)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Access the specified target's aspect.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = WorldAspect(t); // set x to target t's aspect
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GetWorldDirection(t, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set variable v to the value in the relationSource for the specified target.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 GetWorldDirection(t, v); // set v to target t's direction
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Direction Constants
\par }{\f1 DIRECTION_LEFT, DIRECTION_LEFT_OF_CENTER, DIRECTION_CENTER, DIRECTION_RIGHT_OF_CENTER, DIRECTION_RIGHT
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WorldDirection(t)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Access the specified target's direction.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = WorldDirection(t); // set x to target t's direction
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GetWorldLinkID(t, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set variable v to the specified target's link ID.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 GetWorldLinkID(t, v); // set v to target t's link ID
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WorldLinkID(t)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Access the specified target's link ID.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = WorldLinkID(t); // set x to target t's link ID
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GetWorldNote(t, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set variable v to the specified target's note.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 GetWorldNote(t, v); // set v to target t's note
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WorldNote(t)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Access the specified target's note.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = WorldNote(t); // set x to target t's note
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GetWorldRange(t, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set variable v to the specified target's range.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 GetWorldRange(t, v); // set v to target t's range
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Range Constants
\par }{\f1 RANGE_NOWHERE, RANGE_ANYWHERE, RANGE_THERE, RANGE_HERE
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WorldRange(t)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Access the specified target's range.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = WorldRange(t); // set x to target t's range
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GetWorldShortID(t, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set variable v to the specified target's short ID.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 GetWorldShortID(t, v); // set v to target t's short ID
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WorldShortID(t)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Access the specified target's short ID.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = WorldShortID(t); // set x to target t's short ID
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetWorldNote(t, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the specified target's note to the value v.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetWorldNote(t, v); // set target t's note
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Pop(n)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Pop n entries off the stack.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Pop(2); // pop 2 entries off the stack
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Push(n)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Push a value onto the stack
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Push(v); // push the contents of variable v onto the stack
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Stack(n)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the value at the specified stack index.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Stack(0); // set x to first stack entry
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetStack(i, v)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the stack entry specified by index to the value v.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetStack(0, 4); // set the first stack entry to 4
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 TimerState(n)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current running state of timer n.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = TimerState(0); // set x to timer 0's state
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetTimerState(n, s)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the running state of the specified timer. 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetTimerState(0, TIMER_STOPPED); // stop timer 0
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul 
\par State Constants
\par }{\f1 TIMER_RUNNING, TIMER_STOPPED
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EEPROM(index)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the value stored at the EEPROM location specified by index (either directly or indirectly).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = EEPROM(10); // read contents of EEPROM location 10
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetEEPROM(index, d)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the EEPROM location specified by index (directly or indirectly) to the value d.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEEPROM(0, 5); // set EEPROM location 0 to 5\line int i = 3;\line SetEEPROM(i, TimerState(0)); // set EEPROM location 3
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CurrentTaskID()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current task ID.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = CurrentTaskID(); // read current task ID
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RxMessageLock()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the receive buffer locking value.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RxMessageLock(); // read the message locking value
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetRxMessageLock(lock)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the receive buffer locking value.  To lock both IR and PC buffers use }{\f2 MSG_IR+MSG_PC.}{\f1 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetRxMessageLock(MSG_IR); // lock the IR message buffer
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Receive Message Locking Constants
\par }{\f1 MSG_NONE, MSG_IR, MSG_PC
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RxMessageIndex()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the index for the latest NewEntry event.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RxMessageIndex();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RxMessageChannel()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the channel containing the latest received message.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RxMessageChannel();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RxMessageID(channel)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Extract an ID from a received IR or PC message and convert it into an index.  The desired channel is }{\f2 MSG_IR}{\f1  or }{\f2 MSG_PC.}{\f1 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RxMessageID(MSG_IR);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RxMessage(channel, byte)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the contents of a received IR or PC message (4 bytes total).  The desired channel is }{\f2 MSG_IR}{\f1  or }{\f2 MSG_PC.  }{\f1 The desired byte is specifi
ed using MSG_INDEX, MSG_COMMAND, MSG_HI_BYTE, or MSG_LO_BYTE.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 if (RxMessage(MSG_IR, MSG_COMMAND) == COMMAND_CONTROLLER)\line \{\line   x = RxMessage(MSG_IR, MSG_HI_BYTE);\line \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PingControl(n)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the value of the ping control registers (n = 0..2).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = PingControl(1); // read the current ping interval
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PingData()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current 8 bit information for ping messages
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = PingData();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetPingData(d)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the 8 bit information for ping messages.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPingData(55); // send the value 55 when pinging
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PingInterval()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current ping interval.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = PingInterval();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetPingInterval(interval)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the ping interval in 10ms steps.  Setting the interval to zero will disable pinging.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPingInterval(0); // disable pings
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PingID()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the Spybotics ping ID number.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = PingID(); // x = my ping ID
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 BeaconControl(n)\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the value of the beacon control registers (n = 0..3).
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = BeaconControl(1); // read the RC receive channel
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 LinkID()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the link ID (0-7; 0 = no link, 1-6 control unit ID, 7 = PC).
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = LinkID(); // read link ID
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul ID Constants
\par }{\f1 ID_NONE, ID_CTRL1, ID_CTRL2, ID_CTRL3, ID_CTRL4, ID_CTRL5, ID_CTRL6, ID_PC
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RCRxChannel()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the RC receive channel.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RCRxChannel(); // read RC receive channel
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetRCRxChannel(channel)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the RC receive channel.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetRCRxChannel(RC_CHANNEL_1);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul RC Channel Constants
\par }{\f1\cf11 RC_CHANNEL_BROADCAST, RC_CHANNEL_1, RC_CHANNEL_2, RC_CHANNEL_3, RC_CHANNEL_DISABLED
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RCTxChannel()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the RC transmit channel.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RCTxChannel(); // read RC transmit channel
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetRCTxChannel(channel)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the RC transmit channel.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetRCTxChannel(RC_CHANNEL_1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RCTxMode()\tab Value - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Return the current RC transmit mode.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RCTxMode(); // read RC transmit mode
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetRCTxMode(mode)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the RC transmit mode.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetRCTxMode(RCTXMODE_SINGLE_SHOT);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul RC Tx Mode Constants
\par }{\f1 RCTXMODE_SINGLE_SHOT, RCTXMODE_CONTINUOUS
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 StartTask(task)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Start a task by numeric value rather than by name.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 StartTask(9); // start task number 9
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 StopTask(task)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Stop a task by numeric value rather than by name.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 StopTask(9); // stop task number 9
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Action(nSound, nDisplay, nMovement, nRepeat, nTime)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 44.  This subroutine plays any combination of sound, LED animation, and movement, like a multimedia presentation.  nSound is the sound to play (0-7
9, -1 = no sound).  nDisplay is the LED animation to play (0-15, -1 = no animation).  nMovement is the Spybot motion (see BasicMove, FancyMove, RandomMove, SlowDownMove, and SpeedUpMove) with -1 meaning no movement.  nRepeat is the number of times to repe
at the motion.  nTime is the time to wait if nMovement = -1, otherwise it is passed on to the movement subroutines.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Action(SOUND_GEIGER, ANIMATION_FLASH, -1, 0, 300);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Disp(display)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 42.  This subroutine displays one of the LED animations.  Passing an undefined user animation will turn the display off (8-15).
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Disp(ANIMATION_FLASH);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 BasicMove(move, time)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 43.  T
his subroutine performs the requested motion for the specified duration.  The motors are not floated or braked and motor power is not restored on exit.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 BasicMove(MOVE_BASIC_AVOID_LEFT, 500);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Basic Motion Constants
\par }{\f1 MOVE_BASIC_FORWARD, MOVE_BASIC_BACKWARD, MOVE_BASIC_SPIN_LEFT, MOVE_BASIC_SPIN_RIGHT, MOVE_BASIC_TURN_LEFT, MOVE_BASIC_TURN_RIGHT, MOVE_BASIC_AVOID_LEFT, MOVE_BASIC_AVOID_RIGHT, MOVE_BASIC_REST, MOVE_BASIC_STOP
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 FancyMove(move, time)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 47.  This subroutin
e performs the requested motion for the specified duration.  The motors are not floated or braked and motor power is not restored on exit.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 FancyMove(MOVE_FANCY_ZIGZAG, 500);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Fancy Motion Constants
\par }{\f1 MOVE_FANCY_ZIGZAG, MOVE_FANCY_SHAKE, MOVE_FANCY_SCAN, MOVE_
FANCY_STEP, MOVE_FANCY_STEP_BACK, MOVE_FANCY_SEARCH, MOVE_FANCY_FAKE_LEFT, MOVE_FANCY_RAKE_RIGHT, MOVE_FANCY_BUG_FORWARD, MOVE_FANCY_LAZY, MOVE_FANCY_WALK, MOVE_FANCY_WALK_BACK, MOVE_FANCY_DANCE
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RandomMove(move, time)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine
 number 46.  This subroutine performs the requested motion for the specified duration.  The motors are not floated or braked and motor power is not restored on exit.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 RandomMove(MOVE_RANDOM_FORWARD, 500);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul Random Motion Constants
\par }{\f1 MOVE_RANDOM_FORWARD, MOVE_RANDOM_BACKWARD, MOVE_RANDOM_SPIN_LEFT, MOVE_RANDOM_SPIN_RIGHT, MOVE_RANDOM_TURN_LEFT, MOVE_RANDOM_TURN_RIGHT, MOVE_RANDOM_REST
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SlowDownMove(move, time)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 48.  This subroutine performs the requested motion for the 
specified duration.  The motors are not floated or braked and motor power is not restored on exit.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SlowDownMove(MOVE_SLOWDOWN_FORWARD, 500);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul SlowDown Motion Constants
\par }{\f1 MOVE_SLOWDOWN_FORWARD, MOVE_SLOWDOWN_BACKWARD, MOVE_SLOWDOWN_SPIN_LEFT, MOVE_SLOWDOWN_SPIN_RIGHT
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SpeedUpMove(move, time)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
Built-in ROM subroutine number 49.  This subroutine performs the requested motion for the specified duration.  The motors are not floated or braked and motor power is not restored on exit.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SpeedUpMove(MOVE_SPEEDUP_FORWARD, 500);
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\ul SpeedUp Motion Constants
\par }{\f1 MOVE_SPEEDUP_FORWARD, MOVE_SPEEDUP_BACKWARD, MOVE_SPEEDUP_SPIN_LEFT, MOVE_SPEEDUP_SPIN_RIGHT
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Sum2Mem(mem, value)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 50.  This subroutine adds value to a 2-byte location in EEPROM.  The value is stored low byte first.  No overflow checking is performed.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Sum2Mem(50, 400);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Sum4Mem(mem, value)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 51.  This subroutine adds value to a 4-byte location in EEPROM.  The value is stored least significant byte first.  No overflow checking is performed.

\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Sum4Mem(50, 400);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendAllRangeMessage (nMessage, nData)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 38.  This subroutine sends nMessage to all Spybot
s in the world relation table that are in the here, there, or anywhere zones with the actual Spybot range as the high byte of each message.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendAllRangeMessage(50, 40);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendRCXMessage (nMessage)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Built-in ROM subroutine number 37.  This subroutine sends an RCX message at 2400 baud with bi-phase encoding and sum checksum.  These messages can be received by an RCX or Scout.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendRCXMessage(50);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SendSpybotMessage(nIndex, nCmd, nHiByte, nLoByte)\tab Function - Spy
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
Built-in ROM subroutine number 34.  This subroutine sends a message to a Spybot.  If nIndex is a controller or PC then it does nothing.  nIndex is the index of the Spybot in the world relation table (0-15), INDEX_LINKCAST, or INDEX_BROADCAST.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SendSpybotMessage(INDEX_LINKCAST, 50, 0, 10);
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_SwanSpecific}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Swan Specific Features}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  swan specific features}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\i0 3.16 Swan Specific Features}{

\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24 SetMotorPowerSigned(const int motor, const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the power of a motor to the specified signed value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMotorPowerSigned(MTR_A, 10);
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The motor can be specified using the following constants.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Motor Constant\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 MTR_A\tab output A
\par MTR_B\tab output B
\par MTR_C\tab output C
\par MTR_D\tab virtual output D
\par MTR_E\tab virtual output E
\par MTR_F\tab virtual output F
\par 
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 There are additional constants for the motor power functions and values.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Motor Power Direction\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 MPD_FWD\tab foward
\par MPD_REV\tab reverse
\par MPD_FLOAT\tab float
\par MPD_OFF\tab off
\par 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Motor State\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 MS_FLOAT\tab float state
\par MS_BRAKE\tab brake state
\par MS_FWD\tab forward state
\par MS_REV\tab reverse state
\par 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Motor Forward Power\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 MTR_FWD_POWER_1\tab forward at power level 1
\par MTR_FWD_POWER_2\tab forward at power level 2
\par MTR_FWD_POWER_3\tab forward at power level 3
\par MTR_FWD_POWER_4\tab forward at power level 4
\par MTR_FWD_POWER_5\tab forward at power level 5
\par MTR_FWD_POWER_6\tab forward at power level 6
\par MTR_FWD_POWER_7\tab forward at power level 7
\par MTR_FWD_POWER_8\tab forward at power level 8
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Motor Reverse Power\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 MTR_REV_POWER_1\tab reverse at power level 1
\par MTR_REV_POWER_2\tab reverse at power level 2
\par MTR_REV_POWER_3\tab reverse at power level 3
\par MTR_REV_POWER_4\tab reverse at power level 4
\par MTR_REV_POWER_5\tab reverse at power level 5
\par MTR_REV_POWER_6\tab reverse at power level 6
\par MTR_REV_POWER_7\tab reverse at power level 7
\par MTR_REV_POWER_8\tab reverse at power level 8
\par 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Motor Float Power\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 MTR_FLOAT_POWER_1\tab float at power level 1
\par MTR_FLOAT_POWER_2\tab float at power level 2
\par MTR_FLOAT_POWER_3\tab float at power level 3
\par MTR_FLOAT_POWER_4\tab float at power level 4
\par MTR_FLOAT_POWER_5\tab float at power level 5
\par MTR_FLOAT_POWER_6\tab float at power level 6
\par MTR_FLOAT_POWER_7\tab float at power level 7
\par MTR_FLOAT_POWER_8\tab float at power level 8
\par 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Motor Brake Power\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 MTR_BRAKE_POWER_1\tab brake at power level 1
\par MTR_BRAKE_POWER_2\tab brake at power level 2
\par MTR_BRAKE_POWER_3\tab brake at power level 3
\par MTR_BRAKE_POWER_4\tab brake at power level 4
\par MTR_BRAKE_POWER_5\tab brake at power level 5
\par MTR_BRAKE_POWER_6\tab brake at power level 6
\par MTR_BRAKE_POWER_7\tab brake at power level 7
\par MTR_BRAKE_POWER_8\tab brake at power level 8
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MotorPowerSigned(const int motor)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the signed power setting of a motor.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MotorPowerSigned(MTR_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMotorBrakePower(const int motor, const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the brake power of a motor to the specified value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMotorBrakePower(MTR_A, 10);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MotorBrakePower(const int motor)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the brake power setting of a motor.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MotorBrakePower(MTR_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMotorPower8(const int motor, const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the power of a motor to the specified value (using a scale from 0 to 7).
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMotorPower8(MTR_A, 7);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MotorPower8(const int n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the power setting of a motor (using a scale from 0 to 7).
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MotorPower8(MTR_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMotorPower128(const int motor, const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the power of a motor to the specified value (using a scale from 0 to 127).
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMotorPower128(MTR_A, 100);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MotorPower128(const int n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the power setting of a motor (using a scale from 0 to 127).
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MotorPower128(MTR_A);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetEventType(const int n, const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the event type of event n to the type specified by v.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEventType(MyEvent, EVENT_TYPE_PRESSED);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EventType(const int n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the event type of an event.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = EventType(MyEvent);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetEventSrc(const int n, const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the event source of event n to the source specified by v.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEventSrc(MyEvent, EST_SENSOR_1);
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Event Source\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 EST_SENSOR_1\tab sensor 1 source
\par }{\f1\lang1036\langfe1033\langnp1036 EST_SENSOR_2\tab sensor 2 source
\par EST_SENSOR_3\tab sensor 3 source
\par }{\f1 EST_TIMER_1\tab timer 1 source
\par }{\f1\lang1036\langfe1033\langnp1036 EST_TIMER_2\tab timer 2 source
\par EST_TIMER_3\tab timer 3 source
\par EST_TIMER_4\tab timer 4 source
\par EST_LAST_IR_MSG\tab IR msg source
\par EST_COUNTER_1\tab counter 1 source
\par EST_COUNTER_2\tab counter 2 source
\par EST_COUNTER_3\tab counter 3 source
\par EST_USER_EVENT_0\tab user event source
\par EST_USER_EVENT_1\tab user event source
\par EST_USER_EVENT_2\tab user event source
\par EST_USER_EVENT_3\tab user event source
\par EST_USER_EVENT_4\tab user event source
\par }{\f1 EST_VIRTUAL_MOTOR\tab virtual motor source
\par EST_VIRTUAL_SENSOR\tab virtual sensor source
\par EST_WAIT_FOR_MSG\tab IR msg source
\par EST_INFRARED_STATUS\tab IR msg source
\par EST_SENSOR_UNUSED\tab sensor source
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EventSrc(const int n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the event source of an event.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = EventSrc(MyEvent);
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par There are also constants for event states
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Event Source\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 ES_BELOW_LOWER\tab below lower threshold
\par ES_BETWEEN\tab between lower and upper thresholds
\par ES_ABOVE_UPPER\tab above upper threshold
\par ES_UNDETERMINED\tab undetermined state
\par 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetEventCounts(const int n, const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the event count of event n to the count specified by v.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetEventCounts(MyEvent, 10);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 EventCounts(const int n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the event counts of an event.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = EventCounts(MyEvent);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ResetMSTimer(const int n)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the specified 1 ms timer back to zero.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ResetMSTimer(T1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MSTimer(const int n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the specified 1 ms timer value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MSTimer(T1); // get the value of timer 1
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WaitMS(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Wait for the specified number of milliseconds.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 WaitMS(T1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 System(const int n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the specified system value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = System(SYS_BATTERY_LEVEL); // get the system value
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSystem(const int n, const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the system item to the specified value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSystem(}{\f1 SYS_OPCODES_PER_TIMESLICE, 10}{\f2 );
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx5040\faauto\adjustright\rin0\lin720\itap0 {\b\f1 System Constants\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx5040\faauto\adjustright\rin0\lin720\itap0 {\f1 SYS_BATTERY_LEVEL\tab battery level
\par SYS_DEBUG_TASK_MODE\tab debug task mode
\par SYS_MEMORY_MAP_ADDRESS\tab memory map address
\par SYS_CURRENT_TASK\tab current task
\par SYS_SERIAL_LINK_STATUS\tab serial link status
\par SYS_OPCODES_PER_TIMESLICE\tab opcodes per timeslice
\par SYS_MOTOR_TRANSITION_DELAY\tab motor transition delay
\par SYS_SENSOR_REFRESH_RATE\tab sensor refresh rate
\par SYS_EXPANDED_RC_MESSAGES\tab expanded remote control messages
\par SYS_LCD_REFRESH_RATE\tab LCD refresh rate
\par SYS_NO_POWER_DOWN_ON_AC\tab power down while on AC
\par SYS_DEFAULT_TASK_STACK_SIZE\tab default task size
\par SYS_TASK_ACQUIRE_PRIORITY\tab task acquire priority
\par SYS_TRANSMITTER_RANGE\tab transmitter range
\par SYS_FLOAT_DURING_INACTIVE_PWM\tab float motors during inactive PWM
\par SYS_ROT_ERRORS_COUNT\tab rotation sensor errors count
\par SYS_ROT_DEBOUNCED_GLITCHES\tab rotation sensor debounce glitches
\par SYS_PREAMBLE_SIZE\tab preamble size
\par SYS_UNSOLICITED_MESSAGE\tab unsolicited messages
\par SYS_EXPANDED_SUBROUTINES\tab expanded subroutines
\par SYS_POWER_DOWN_DELAY\tab power down delay
\par SYS_WATCH_FORMAT\tab watch format
\par SYS_SENSOR_MISSED_CONVERSIONS\tab sensor missed conversions
\par }{\f1\lang1036\langfe1033\langnp1036 SYS_IGNORE_MESSAGES_CPU\tab ignore messages CPU
\par }{\f1 SYS_COMM_ERRORS_TIMEOUT\tab count of timeout errors
\par SYS_COMM_ERRORS_PARITY\tab count of parity errors
\par SYS_COMM_ERRORS_FRAMING\tab count of framing errors
\par SYS_COMM_ERRORS_OVERRUN\tab count of overrun errors
\par SYS_INTER_CHAR_TIMEOUT\tab inter-character timeout
\par SYS_TASK_SCHEDULING_PRIORITY\tab task scheduling priority
\par SYS_VOLUME\tab volume level
\par SYS_SOUND_PLAYING\tab sound playing state
\par SYS_PLAY_SOUNDS\tab enable/disable sound playing
\par SYS_QUEUED_SOUND_COUNT\tab count of sounds waiting to be played
\par SYS_SENSOR_STARTUP_DELAY\tab sensor startup delay
\par SYS_SENSOR_DELAY_CYCLES\tab sensor delay cycles
\par SYS_SENSOR_REFRESH_STATE\tab sensor refresh state
\par SYS_SENSOR_SCAN_COUNT\tab sensor scan count
\par SYS_DATALOG_SIZE\tab datalog size
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ImmediateBatteryLevel()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the immediate battery level.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = ImmediateBatteryLevel();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DebugTaskMode()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the debug task mode.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = DebugTaskMode();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MemoryMapAddress()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the memory map address.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MemoryMapAddress();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CurrentTask()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the current task number.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = CurrentTask();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SerialLinkStatus()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the serial link status.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SerialLinkStatus();
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Serial Link Status Constants\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 SLS_WAIT_FOR_MSG\tab waiting for message
\par SLS_RECEIVING_MSG\tab receiving message
\par SLS_TRANSMITTING\tab transmitting
\par SLS_UNKNOWN\tab unknown
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OpcodesPerTimeslice()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of opcodes to execute per timeslice.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = OpcodesPerTimeslice();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetOpcodesPerTimeslice(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the system item to the specified value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetOpcodesPerTimeslice(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MotorTransitionDelay()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of milliseconds to delay when changing motor direction.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MotorTransitionDelay();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetMotorTransitionDelay(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the motor transition delay to the specified value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetMotorTransitionDelay(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SensorRefreshRate()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the sensor refresh rate.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorRefreshRate();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSensorRefreshRate(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the sensor refresh rate to the specified value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorRefreshRate(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ExpandedRemoteMessages()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read a boolean value indicating whether or not to support expanded remote control messages.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = ExpandedRemoteMessages(); // 0 or 1
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetExpandedRemoteMessages(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Enable or disable expanded remote control messages.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetExpandedRemoteMessages(}{\f1 false}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 LCDRefreshRate()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the LCD refresh rate.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = LCDRefreshRate();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetLCDRefreshRate(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the LCD refresh rate.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetLCDRefreshRate(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 NoPowerDownOnAC()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read a boolean value specifying whether or not to power down while running on AC power.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = NoPowerDownOnAC();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetNoPowerDownOnAC(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Enable or disable power down while running on AC power.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetNoPowerDownOnAC(}{\f1 false}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DefaultStackSize()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the default stack size.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = DefaultStackSize();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetDefaultStackSize(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the default stack size.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetDefaultStackSize(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 TaskAcquirePriority()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the task acquire priority level.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = TaskAcquirePriority();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetTaskAcquirePriority(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the task acquire priority level.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetTaskAcquirePriority(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 TransmitterRange()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the transmitter range value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = TransmitterRange();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 FloatDuringInactivePWM()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read a boolean value specifying whether or not to float motors during inactive pulse width modulation.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = FloatDuringInactivePWM();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetFloatDuringInactivePWM(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Enable or disable floating the motors during inactive pulse width modulation.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetFloatDuringInactivePWM(}{\f1 false}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RotErrorsCount()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the rotation sensor errors count.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RotErrorsCount();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RotDebouncedGlitches()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the rotation sensor debounced glitches.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = RotDebouncedGlitches();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SystemPreambleSize()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the system preamble size.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SystemPreambleSize();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSystemPreambleSize(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the system preamble size.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSystemPreambleSize(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 UnsolicitedMessages()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read a boolean value specifying whether or not to accept unsolicted messages.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = UnsolicitedMessages();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ExpandedSubroutines()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read a boolean value specifying whether or not to allow an expanded number of subroutines.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = ExpandedSubroutines();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetExpandedSubroutines(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Enable or disable support for an expanded number of subroutines.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetExpandedSubroutines(}{\f1 false}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PowerDownDelay()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the power down delay.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = PowerDownDelay();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 WatchFormat()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the watch format.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = WatchFormat();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetWatchFormat(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the watch format.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetWatchFormat(}{\f1 10}{\f2 );
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Watch Format Constants\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 FMT_HHMM\tab hours and minutes
\par FMT_MMSS\tab minutes and seconds
\par FMT_MSSTENTHS\tab minutes, seconds, and tenths of seconds
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 MissedSensorADConversions()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of missed sensor analog to digital conversions.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = MissedSensorADConversions();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 IgnoreMessagesCPU()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read a boolean value specifying whether or not to ignore CPU messages.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = IgnoreMessagesCPU();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CommErrorsTimeout()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of communication timeout errors.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = CommErrorsTimeout();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CommErrorsParity()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of communication parity errors.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = CommErrorsParity();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CommErrorsFraming()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of communication framing errors.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = CommErrorsFraming();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CommErrorsOverrun()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of communication overrun errors.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = CommErrorsOverrun();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 InterCharTimeout()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the inter-character timeout value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = InterCharTimeout();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetInterCharTimeout(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the inter-character timeout value.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetInterCharTimeout(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 TaskSchedulingPriority()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the task scheduling priority.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = TaskSchedulingPriority();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetTaskSchedulingPriority(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the task scheduling priority.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetTaskSchedulingPriority(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Volume()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the system volume level.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = Volume();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetVolume(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the system volume level.  The maximum volume level is MAX_VOLUME.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetVolume(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SoundActive()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read a boolean value specifying whether or not a sound is currently playing.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SoundActive();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PlaySounds()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read a boolean value specifying whether or not to allow sound playing.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = PlaySounds();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetPlaySounds(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Enable or disable support for playing sounds.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetPlaySounds(}{\f1 false}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 QueuedSoundCount()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of sounds currently waiting to be played.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = QueuedSoundCount();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SensorStartupDelay()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the sensor startup delay.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorStartupDelay();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SetSensorStartupDelay(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the sensor startup delay.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 SetSensorStartupDelay(}{\f1 10}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SensorDelayCycles()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the number of sensor delay cycles.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorDelayCycles();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SensorRefreshState()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the sensor refresh state.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorRefreshState();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 SensorScanCount()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the sensor scan count.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = SensorScanCount();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 DatalogSize()\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the datalog size.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = DatalogSize();
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 IntrinsicIndGlobal(const int n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Access the value of an intrinsic indirectly.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = IntrinsicIndGlobal(15);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 GlobalVar(const int &n)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read or write the value of a global variable (either directly or indirectly).
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = GlobalVar(y);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 StackAddress(const int task)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the stack address of the specified task.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = StackAddress(1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 StackSize(const int task)\tab Value - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Read the size of the stack for the specified task.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 x = StackSize(1);
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ClearAll(const int &v)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Clear the specified items.  The constants can be added together to clear multiple items at once.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ClearAll(}{\f1 CLR_TIMERS}{\f2 );
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 ClearAll Constants\tab Meaning
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 CLR_TIMERS\tab clear all timers
\par CLR_INPUTS\tab clear all inputs
\par CLR_VARIABLES\tab clear all variables
\par CLR_TASK_STACK\tab clear all task stacks
\par CLR_EVENTS\tab clear all events
\par CLR_BREAKPOINTS\tab clear all breakpoints
\par CLR_DATALOG\tab clear the datalog
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 BitSet(const int &result, const int &operand)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Set the bit in the result specified by the operand.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 BitSet(}{\f1 x, 0x01}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 BitClear(const int &result, const int &operand)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Clear the bit in the result specified by the operand.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 BitClear(}{\f1 x, 0x01}{\f2 );
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Negate(const int &result, const int &operand)\tab Function - Swan
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Negate the bits in the result specified by the operand.
\par }\pard \ql \li720\ri0\sb120\sa120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Negate(}{\f1 x, 0x01}{\f2 );
\par }\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_TechnicalDetails}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Technical Details}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  technical details}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{4 Technical Details
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This section explains some of the low-level features of NQC. In general, these mechanisms should only be used as a last resort since they may change in future releases. Most programmers will never need to use the features descri
bed below - they are mainly used in the creation of the NQC API file.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_ASM}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  The asm statement}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  asm}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{4.1 The asm statement
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 asm}{\f1  statement is used to define almost all of the NQC API calls. The syntax of the statement is:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 asm \{ item1, item2 ... itemN \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Where an item is one of the following
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\i\f2 constant_expression
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 $ }{\i\f2 expression}{\f2 
\par $ }{\i\f2 expression}{\f2  : }{\i\f2 restrictor}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The statement simply emits the values of each of the items as raw bytecodes. Constant items are the simplest - they result in a single byte o
f raw data (the lower 8 bits of the constant value). For example, the API file defines the following inline function:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 void ClearMessage() \{ asm \{ 0x90 \}; \}
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Whenever ClearMessage() is called by a program, the value 0x90 is emitted as a bytecode.
\par Many API functions take arguments, and these arguments must be encoded into an appropriate effective address for the bytecode interpreter. In the most general case, an effective address contains a }{\i\f1 source code}{\f1 
 followed by a two byte value (least significant byte first
). Source codes are explained in the SDK documentation available from LEGO. However, it is often desirable to encode the value in some other manner - for example to use only a single byte value after the source code, omit the source code itself, or only a
llow certain sources to be used. A }{\i\f1 restrictor}{\f1 
 may be used to control how the effective address is formatted. A restrictor is a 32 bit constant value. The lower 24 bits form a bitmask indicating which sources are valid (bit 0 should be set to allow source 0, etc).
\par The upper 8 bits include formatting flags for the effective address. Note that when no restrictor is specified, this is the same as using a restrictor of 0 (no restriction on sources, and a format of source followed by two value bytes). The API file
 defines the following constants which can be used to build restrictors:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 # define __ASM_SMALL_VALUE 0x01000000
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 # define __ASM_NO_TYPE 0x02000000
\par # define __ASM_NO_LOCAL 0x04000000
\par 
\par # if __RCX == 2
\par }\pard \ql \li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 // no restriction
\par # define __ASM_SRC_BASIC 0
\par # define __ASM_SRC_EXT 0
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 # else
\par }\pard \ql \li1440\ri0\widctlpar\faauto\adjustright\rin0\lin1440\itap0 {\f2 # define __ASM_SRC_BASIC 0x000005
\par # define __ASM_SRC_EXT 0x000015
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 # endif
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 __ASM_SMALL_VALUE}{\f1  flag indicates that a one-byte value should be used instead of a two-byte value. The }{\f2 __ASM_NO_TYPE}{\f1 
 flag indicates that the source code should be omitted. The }{\f2 __ASM_NO_LOCAL}{\f1 
 flag specifies that local variables are not a legal source for the expression. Note that the RCX2 firmware is less restrictive than the other interpreters, thus the definition of }{\f2 __ASM_SRC_BASIC}{\f1  and }{\f2 __ASM_SRC_EXT}{\f1 
 are relaxed in the RCX2 case. The API definition file for NQC contains numerous examples of using restrictors within }{\f2 asm}{\f1  statement. If you are using a command-line version of NQC, you can emit the API file by typing the following command:

\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 nqc -api
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NQC_DataSources}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Data Sources}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  data sources}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{4.2 Data Sources
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The bytecode interpreters use different data sources to represent the various kinds of data (constants, variables, random numbers, sensor values, etc). T
he specific sources depend to a certain extent on which device you are using and are described in the SDK documentation available from LEGO.
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 NQC provides a special operator to represent a data source:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 @ }{\i\f2 constant}{\f2 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The value of this expression is the data sou
rce described by the constant. The lower 16 bits of the constant represent the data value, and the next 8 bits are the source code. For example, the source code for a random number is 4, so the expression for a random number between 0 and 9 would be:

\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 @0x40009
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The NQC API file defines a number of macros which make the use of the }{\f2 @}{\f1  operator transparent to the programmer. For example, in the case of random numbers:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #define Random(n) @(0x40000 + (n))
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Note that since source 0 is the global variable space, the global storage locations can be referenced by number: }{\f2 @0}{\f1 
 refers to storage location 0. If for some reason you need explicit control over where variables are being stored, then you should use }{\f2 #pragma reserve}{\f1  to instruct NQC not to use those storage locations, and then access them manually with the }
{\f2 @}{\f1  operator. For example, the following code snippet reserves location 0 and creates a macro for it called x.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #pragma reserve 0
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #define x(@0)
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }}