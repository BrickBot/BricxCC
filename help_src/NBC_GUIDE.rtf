{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f5\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Helvetica;}
{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier{\*\falt Courier New};}{\f7\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Geneva;}{\f8\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Tms Rmn;}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f17\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}SimSun{\*\falt SimSun};}{\f46\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}@SimSun;}
{\f108\fswiss\fcharset0\fprq2{\*\panose 020b0606020202030204}Arial Narrow;}{\f568\froman\fcharset238\fprq2 Times New Roman CE;}{\f569\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f571\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f572\froman\fcharset162\fprq2 Times New Roman Tur;}{\f573\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f574\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f575\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f576\fswiss\fcharset238\fprq2 Arial CE;}{\f577\fswiss\fcharset204\fprq2 Arial Cyr;}{\f579\fswiss\fcharset161\fprq2 Arial Greek;}{\f580\fswiss\fcharset162\fprq2 Arial Tur;}{\f581\fswiss\fcharset177\fprq2 Arial (Hebrew);}
{\f582\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f583\fswiss\fcharset186\fprq2 Arial Baltic;}{\f584\fmodern\fcharset238\fprq1 Courier New CE;}{\f585\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f587\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f588\fmodern\fcharset162\fprq1 Courier New Tur;}{\f589\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f590\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f591\fmodern\fcharset186\fprq1 Courier New Baltic;}
{\f608\fswiss\fcharset238\fprq2 Helvetica CE;}{\f609\fswiss\fcharset204\fprq2 Helvetica Cyr;}{\f611\fswiss\fcharset161\fprq2 Helvetica Greek;}{\f612\fswiss\fcharset162\fprq2 Helvetica Tur;}{\f613\fswiss\fcharset177\fprq2 Helvetica (Hebrew);}
{\f614\fswiss\fcharset178\fprq2 Helvetica (Arabic);}{\f615\fswiss\fcharset186\fprq2 Helvetica Baltic;}{\f706\fnil\fcharset0\fprq2 SimSun Western{\*\falt SimSun};}{\f938\fnil\fcharset0\fprq2 @SimSun Western;}
{\f1432\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f1433\fswiss\fcharset204\fprq2 Arial Narrow Cyr;}{\f1435\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f1436\fswiss\fcharset162\fprq2 Arial Narrow Tur;}
{\f1439\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 
heading 1;}{\s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 2;}{
\s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 3;}{\s4\ql \fi-864\li864\ri0\sb240\sa60\keepn\widctlpar
\jclisttab\tx864\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin864\itap0 \b\i\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 4;}{\s5\ql \fi-1008\li1008\ri0\sb240\sa120\keep\keepn\widctlpar
\jclisttab\tx1008\aspalpha\aspnum\faauto\outlinelevel4\adjustright\rin0\lin1008\itap0 \b\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 5;}{\s6\ql \fi-1152\li1152\ri0\sb240\sa120\keep\keepn\widctlpar
\jclisttab\tx1152\aspalpha\aspnum\faauto\outlinelevel5\adjustright\rin0\lin1152\itap0 \b\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 6;}{\s7\ql \fi-1296\li1296\ri0\sb240\sa120\keepn\widctlpar
\jclisttab\tx1296\aspalpha\aspnum\faauto\outlinelevel6\adjustright\rin0\lin1296\itap0 \b\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 7;}{\s8\ql \fi-1440\li1440\ri0\sb240\sa60\widctlpar
\jclisttab\tx1440\aspalpha\aspnum\faauto\outlinelevel7\adjustright\rin0\lin1440\itap0 \i\f5\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 8;}{\s9\ql \fi-1584\li1584\ri0\sb240\sa60\widctlpar
\jclisttab\tx1584\aspalpha\aspnum\faauto\outlinelevel8\adjustright\rin0\lin1584\itap0 \b\i\f5\fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 footnote text;}{\*\cs16 \additive \f0\super \sbasedon10 footnote reference;}{\*\cs17 \additive \f0\ul\cf2 
\sbasedon10 Hyperlink;}{\s18\ql \li0\ri0\sa120\sl360\slmult1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext18 Body Text;}{\*\cs19 \additive 
\f6\fs22\chshdng0\chcfpat0\chcbpat0 \sbasedon10 Code Inline;}{\s20\ql \li720\ri720\sl360\slmult1\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 
\f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 \sbasedon0 \snext20 Code Listing;}{\s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext21 Body Text 2;}{\s22\ql \li0\ri0\sb120\sa120\sl360\slmult1\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext22 API Name;}{\s23\ql \li0\ri0\sl360\slmult1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
\sbasedon18 \snext23 Table;}{\*\cs24 \additive \f0\fs24\lang1033\langfe1033\langnp1033\langfenp1033 \sbasedon10 Body Text Indent Char1;}{\s25\ql \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 caption;}{\s26\qc \li0\ri0\sa240\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f108\fs48\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext26 
Title;}{\s27\ql \li720\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext27 Bullet;}{
\s28\ql \li0\ri0\sa240\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext28 Section;}{\s29\ql \fi-360\li360\ri0\sa120\widctlpar\jclisttab\tx360{\*\pn 
\pnlvlbody\ilvl0\ls31\pnrnot0\pndec }\aspalpha\aspnum\faauto\ls31\adjustright\rin0\lin360\itap0 \fs24\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext29 \sautoupd List Bullet;}{\s30\ql \li0\ri0\sa120\widctlpar
\tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext30 header;}{\s31\ql \li0\ri0\sa120\widctlpar
\tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext31 footer;}{\*\cs32 \additive \f0 \sbasedon10 page number;}{
\s33\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 \sautoupd toc 1;}{\*\cs34 \additive \b\f0 \sbasedon10 Strong;}{\*\cs35 \additive 
\f0\fs24\lang1033\langfe1033\langnp1033\langfenp1033 \sbasedon10 Body Text Indent Char;}{\s36\ql \li90\ri0\sb240\sa60\keepn\widctlpar\tx990\tqr\tx8640\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin90\itap0 
\b\f5\fs32\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon3 \snext36 Body Text + Indent;}{\*\cs37 \additive \fs20\loch\f2\hich\af2\dbch\af17 \sbasedon10 HTML Typewriter;}{\*\cs38 \additive \f0\ul\cf12 \sbasedon10 FollowedHyperlink;}{
\s39\ql \li0\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext39 endnote text;}{
\s40\ql \li960\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin960\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 \sautoupd toc 5;}{
\s41\ql \li1200\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin1200\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 \sautoupd toc 6;}{\*\cs42 \additive 
\b\i\f0\fs24\lang1033\langfe1033\langnp1033\langfenp1033 \sbasedon10 Heading 4 Char;}{\*\cs43 \additive \f1\fs24\lang1033\langfe1033\langnp1033\langfenp1033 \sbasedon10 Heading 3 Char;}}{\*\listtable{\list\listtemplateid0\listsimple{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listname ;}\listid-125}
{\list\listtemplateid0\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li360
\jclisttab\tx360 }{\listname ;}\listid-120}{\list\listtemplateid0\listsimple{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid-119}{\list\listtemplateid-1\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext
\'01*;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listname ;}\listid-2}{\list\listtemplateid0{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow1\levelstartat1\levelspace0\levelindent0{\leveltext
\'09Chapter \'00;}{\levelnumbers\'09;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat0\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat0\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel
\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat0\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2
\levelstartat0\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat0\levelspace0\levelindent0{\leveltext
\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat0\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat0\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255
\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat0\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listname ;}\listid1}{\list\listtemplateid-1734441242\listsimple{\listlevel
\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat4\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-720\li1440\jclisttab\tx1440 }{\listname 
;}\listid107166021}{\list\listtemplateid68354049\listsimple{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid156653440}{\list\listtemplateid1944737318\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0
{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid241331705}{\list\listtemplateid1693582972\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0
\levelfollow0\levelstartat5\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-720\li1440\jclisttab\tx1440 }{\listname ;}\listid298150666}{\list\listtemplateid67698719
{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li360\jclisttab\tx360 }{\listlevel\levelnfc0
\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'04\'00.\'01.;}{\levelnumbers\'01\'03;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-432\li792\jclisttab\tx792 }{\listlevel\levelnfc0\levelnfcn0
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'06\'00.\'01.\'02.;}{\levelnumbers\'01\'03\'05;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-504\li1224\jclisttab\tx1224 }{\listlevel\levelnfc0\levelnfcn0
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'08\'00.\'01.\'02.\'03.;}{\levelnumbers\'01\'03\'05\'07;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-648\li1728\jclisttab\tx1728 }{\listlevel\levelnfc0
\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0a\'00.\'01.\'02.\'03.\'04.;}{\levelnumbers\'01\'03\'05\'07\'09;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-792\li2232\jclisttab\tx2232 }
{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0c\'00.\'01.\'02.\'03.\'04.\'05.;}{\levelnumbers\'01\'03\'05\'07\'09\'0b;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 
\fi-936\li2736\jclisttab\tx2736 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0e\'00.\'01.\'02.\'03.\'04.\'05.\'06.;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\f0\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-1080\li3240\jclisttab\tx3240 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'10\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.;}{\levelnumbers
\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-1224\li3744\jclisttab\tx3744 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'12\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08.;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-1440\li4320\jclisttab\tx4320 }{\listname ;}\listid308441429}{\list\listtemplateid68354049
\listsimple{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li360\jclisttab\tx360 }
{\listname ;}\listid663700731}{\list\listtemplateid290347014\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat3\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1080\jclisttab\tx1080 }{\listname ;}\listid956595244}{\list\listtemplateid1252801822{\listlevel\levelnfc1\levelnfcn1\leveljc0\leveljcn0\levelfollow1\levelstartat1\levelspace0\levelindent0{\leveltext
\'02\'00.;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel
\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2
\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext
\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listlevel\levelnfc255
\levelnfcn255\leveljc0\leveljcn0\levelfollow2\levelstartat1\levelspace0\levelindent0{\leveltext\'00;}{\levelnumbers;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 }{\listname ;}\listid1621105010}{\list\listtemplateid-1472415022{\listlevel
\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat2\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li360\jclisttab\tx360 }{\listlevel\levelnfc0
\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat5\levelspace0\levelindent0{\leveltext\'03\'00.\'01;}{\levelnumbers\'01\'03;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li360\jclisttab\tx360 }{\listlevel\levelnfc0
\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'05\'00.\'01.\'02;}{\levelnumbers\'01\'03\'05;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-720\li720\jclisttab\tx720 }{\listlevel
\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'07\'00.\'01.\'02.\'03;}{\levelnumbers\'01\'03\'05\'07;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-1080\li1080
\jclisttab\tx1080 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'09\'00.\'01.\'02.\'03.\'04;}{\levelnumbers\'01\'03\'05\'07\'09;}\f0\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-1080\li1080\jclisttab\tx1080 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'0b\'00.\'01.\'02.\'03.\'04.\'05;}{\levelnumbers
\'01\'03\'05\'07\'09\'0b;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'0d\'00.\'01.\'02.\'03.\'04.\'05.\'06;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-1440\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\'0f\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\f0\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-1800\li1800\jclisttab\tx1800 }{\listlevel
\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'11\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\f0\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-1800\li1800\jclisttab\tx1800 }{\listname ;}\listid1636643281}{\list\listtemplateid-2081125238\listsimple{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0
{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \s29\fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1786537913}{\list\listtemplateid1668292118\listhybrid{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0
\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace360\levelindent0{\leveltext\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace360\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace360\levelindent0{\leveltext\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1789619211}}{\*\listoverridetable{\listoverride\listid-119
\listoverridecount0\ls1}{\listoverride\listid-119\listoverridecount0\ls2}{\listoverride\listid-119\listoverridecount0\ls3}{\listoverride\listid-119\listoverridecount0\ls4}{\listoverride\listid-119\listoverridecount0\ls5}{\listoverride\listid-119
\listoverridecount0\ls6}{\listoverride\listid-119\listoverridecount0\ls7}{\listoverride\listid-119\listoverridecount0\ls8}{\listoverride\listid-119\listoverridecount0\ls9}{\listoverride\listid-119\listoverridecount0\ls10}{\listoverride\listid-119
\listoverridecount0\ls11}{\listoverride\listid-119\listoverridecount0\ls12}{\listoverride\listid-119\listoverridecount0\ls13}{\listoverride\listid-119\listoverridecount0\ls14}{\listoverride\listid-119\listoverridecount0\ls15}{\listoverride\listid-119
\listoverridecount0\ls16}{\listoverride\listid-119\listoverridecount0\ls17}{\listoverride\listid-119\listoverridecount0\ls18}{\listoverride\listid298150666\listoverridecount0\ls19}{\listoverride\listid107166021\listoverridecount0\ls20}
{\listoverride\listid956595244\listoverridecount0\ls21}{\listoverride\listid663700731\listoverridecount0\ls22}{\listoverride\listid156653440\listoverridecount0\ls23}{\listoverride\listid1621105010\listoverridecount0\ls24}{\listoverride\listid1621105010
\listoverridecount9{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel
\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat\levelstartat1}\ls25}{\listoverride\listid1789619211\listoverridecount0\ls26}
{\listoverride\listid241331705\listoverridecount0\ls27}{\listoverride\listid-119\listoverridecount0\ls28}{\listoverride\listid-125\listoverridecount0\ls29}{\listoverride\listid-120\listoverridecount0\ls30}{\listoverride\listid1786537913
\listoverridecount0\ls31}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}
\f7\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720 }}\ls32}{\listoverride\listid1\listoverridecount0\ls33}{\listoverride\listid1\listoverridecount9{\lfolevel\listoverridestartat\levelstartat1}{\lfolevel\listoverridestartat
\levelstartat0}{\lfolevel\listoverridestartat\levelstartat0}{\lfolevel\listoverridestartat\levelstartat0}{\lfolevel\listoverridestartat\levelstartat0}{\lfolevel\listoverridestartat\levelstartat0}{\lfolevel\listoverridestartat\levelstartat0}{\lfolevel
\listoverridestartat\levelstartat0}{\lfolevel\listoverridestartat\levelstartat0}\ls34}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelold
\levelspace0\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f8\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720 }}\ls35}{\listoverride\listid308441429\listoverridecount0\ls36}{\listoverride\listid1636643281
\listoverridecount0\ls37}}{\*\revtbl {Unknown;}}{\info{\title #$K+NQC Programmer's Guide}{\author John Hansen}{\operator John Hansen}{\creatim\yr2007\mo10\dy5\hr14\min46}{\revtim\yr2010\mo5\dy29\hr19\min34}{\printim\yr2007\mo11\dy5\hr7\min4}{\version255}{\edmins1086}
{\nofpages151}{\nofwords29012}{\nofchars165373}{\*\company Aspect Communications, Inc.}{\nofcharsws203089}{\vern8247}}\margl1417\margr1417\margt1417\margb1417 
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1417\dgvorigin1417\dghshow1\dgvshow1
\jexpand\viewkind4\viewscale90\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0{\*\ftnsep \pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\chftnsep 
\par }}{\*\ftnsepc \pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\chftnsepc 
\par }}{\*\aftnsep \pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\chftnsep 
\par }}{\*\aftnsepc \pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\chftnsepc 
\par }}\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}
{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NBCProgrammersGuide}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  NBC Programmer\rquote s Guide}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  NBC;guide;programmer}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{\f1\fs40 NBC Programmer's Guide
\par }{\f1\fs28 Version 1.0.1 b33, by John Hansen
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 \page }{\cs16\f1\super #{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NBC_Contents}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Contents}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  contents}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{\b\f1\fs28 Contents
\par }{\f1 i }{\f1\uldb Title page}{\v\f1 IDH_NBCProgrammersGuide}{\f1 
\par ii }{\f1\uldb Contents}{\v\f1 IDH_NBC_Contents}{\f1 
\par 1 }{\f1\uldb Introduction}{\v\f1 IDH_NBC_Introduction}{\f1 
\par 2 }{\f1\uldb The NBC Language}{\v\f1 IDH_NBC_Language}{\f1 
\par 2.1 }{\f1\uldb Lexical Rules}{\v\f1 IDH_NBC_LexicalRules}{\f1 
\par 2.1.1 }{\f1\uldb Comments}{\v\f1 IDH_NBC_Comments}{\f1 
\par 2.1.2 }{\f1\uldb Whitespace}{\v\f1 IDH_NBC_Whitespace}{\f1 
\par 2.1.3 }{\f1\uldb Numerical Constants}{\v\f1 IDH_NBC_NumericConstants}{\f1 
\par 2.1.4 }{\f1\uldb Identifiers and Keywords}{\v\f1 IDH_NBC_IdentKeywords}{\f1 
\par 2.2 }{\f1\uldb Program Structure}{\v\f1 IDH_NBC_ProgStructure}{\f1 
\par 2.2.1 }{\f1\uldb Threads}{\v\f1 IDH_NBC_Tasks}{\f1 
\par 2.2.2 }{\f1\uldb Subroutines}{\v\f1 IDH_NBC_Subroutines}{\f1 
\par 2.2.3 }{\f1\uldb Macro Functions}{\v\f1 IDH_NBC_MacroFunctions}{\f1 
\par 2.2.4 }{\f1\uldb Data segments}{\v\f1 IDH_NBC_DataSegments}{\f1 
\par 2.2.4.1 }{\f1\uldb Type Definitions}{\v\f1 IDH_NBC_TypeDefinitions}{\f1 
\par 2.2.4.2 }{\f1\uldb Variable Declarations}{\v\f1 IDH_NBC_VariableDeclarations}{\f1 
\par 2.3 }{\f1\uldb The Preprocessor}{\v\f1 IDH_NBC_Preprocessor}{\f1 
\par 2.3.1 }{\f1\uldb #include}{\v\f1 IDH_NBC_Include}{\f1 
\par 2.3.2 }{\f1\uldb #define}{\v\f1 IDH_NBC_Define}{\f1 
\par 2.3.3 }{\f1\uldb ## (Concatenation)}{\v\f1 IDH_NBC_Concatenation}{\f1 
\par 2.3.4 }{\f1\uldb Conditional Compilation}{\v\f1 IDH_NBC_CondCompilation}{\f1 
\par 2.4 }{\f1\uldb Compiler Tokens}{\v\f1 IDH_NBC_CompilerTokens}{\f1 
\par 2.5 }{\f1\uldb Expression Evaluator}{\v\f1 IDH_NBC_ExpressionEvaluator}{\f1 
\par 2.6 }{\f1\uldb IO-Map Address (IOMA) Constants}{\v\f1 IDH_NBC_IOMAPAddresses}{\f1 
\par 2.7 }{\f1\uldb Statements}{\v\f1 IDH_NBC_Statements}{\f1 
\par 2.7.1 }{\f1\uldb Assignment Statements}{\v\f1 IDH_NBC_Assignment}{\f1 
\par 2.7.2 }{\f1\uldb Math Statements}{\v\f1 IDH_NBC_MathStatements}{\f1 
\par 2.7.3 }{\f1\uldb Logic Statements}{\v\f1 IDH_NBC_LogicStatements}{\f1 
\par 2.7.4 }{\f1\uldb Bit Manipulation Statements}{\v\f1 IDH_NBC_BitManipulationStatements}{\f1 
\par 2.7.5 }{\f1\uldb Comparison Statements}{\v\f1 IDH_NBC_ComparisonStatements}{\f1 
\par 2.7.6 }{\f1\uldb Control Flow Statements}{\v\f1 IDH_NBC_ControlFlowStatements}{\f1 
\par 2.7.7 }{\f1\uldb System Call Statements}{\v\f1 IDH_NBC_SystemCallStatements}{\f1 
\par 2.7.8 }{\f1\uldb Timing Statements}{\v\f1 IDH_NBC_TimingStatements}{\f1 
\par 2.7.9 }{\f1\uldb Array Statements}{\v\f1 IDH_NBC_ArrayStatements}{\f1 
\par 2.7.10 }{\f1\uldb String Statements}{\v\f1 IDH_NBC_StringStatements}{\f1 
\par 2.7.11 }{\f1\uldb Scheduling Statements}{\v\f1 IDH_NBC_SchedulingStatements}{\f1 
\par 2.7.12 }{\f1\uldb Input Statements}{\v\f1 IDH_NBC_InputStatements}{\f1 
\par 2.7.13 }{\f1\uldb Output Statements}{\v\f1 IDH_NBC_OutputStatements}{\f1 
\par 2.7.14 }{\f1\uldb Compile-time Statements}{\v\f1 IDH_NBC_CompileTimeStatements}{\f1 
\par 3 }{\f1\uldb NBC API}{\v\f1 IDH_NBC_API}{\f1 
\par 3.1 General Features
\par 3.1.1 }{\f1\uldb Timing Functions}{\v\f1 IDH_NBC_TimingFunctions}{\f1 
\par 3.1.2 }{\f1\uldb Numeric Functions}{\v\f1 IDH_NBC_NumericFunctions}{\f1 
\par 3.1.3 }{\f1\uldb Low-level System Functions}{\v\f1 IDH_NBC_SystemFunctions}{\f1 
\par 3.2 }{\f1\uldb Input Module}{\v\f1 IDH_NBC_InputModule}{\f1 
\par 3.2.1 }{\f1\uldb Types and Modes}{\v\f1 IDH_NBC_SensorTypes}{\f1 
\par 3.2.2 }{\f1\uldb Sensor Information}{\v\f1 IDH_NBC_SensorInfo}{\f1 
\par 3.2.3 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_InputIOMapOffsets}{\f1 
\par 3.3 }{\f1\uldb Output Module}{\v\f1 IDH_NBC_Outputs}{\f1 
\par 3.3.1 }{\f1\uldb Convenience Calls}{\v\f1 IDH_NBC_OutputsConvenience}{\f1 
\par 3.3.2 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_OutputIOMapOffsets}{\f1 
\par 3.4 }{\f1\uldb Sound Module}{\v\f1 IDH_NBC_Sound}{\f1 
\par 3.4.1 }{\f1\uldb High-level functions}{\v\f1 IDH_NBC_SoundHighLevel}{\f1 
\par 3.4.2 }{\f1\uldb Low-level functions}{\v\f1 IDH_NBC_SoundLowLevel}{\f1 
\par 3.4.3 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_SoundIOMapOffsets}{\f1 
\par 3.5 }{\f1\uldb IO Control Module}{\v\f1 IDH_NBC_IOCtrl}{\f1 
\par 3.5.1 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_IOCtrlIOMapOffsets}{\f1 
\par 3.6 }{\f1\uldb Display Module}{\v\f1 IDH_NBC_Display}{\f1 
\par 3.6.1 }{\f1\uldb High-level functions}{\v\f1 IDH_NBC_DisplayHighLevel}{\f1 
\par 3.6.2 }{\f1\uldb Low-level functions}{\v\f1 IDH_NBC_DisplayLowLevel}{\f1 
\par 3.6.3 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_DisplayIOMapOffsets}{\f1 
\par 3.7 }{\f1\uldb Loader Module}{\v\f1 IDH_NBC_Loader}{\f1 
\par 3.7.1 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_LoaderIOMapOffsets}{\f1 
\par 3.8 }{\f1\uldb Command Module}{\v\f1 IDH_NBC_Command}{\f1 
\par 3.8.1 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_CommandIOMapOffsets}{\f1 
\par 3.9 }{\f1\uldb Button Module}{\v\f1 IDH_NBC_Button}{\f1 
\par 3.9.1 }{\f1\uldb High-level functions}{\v\f1 IDH_NBC_ButtonHighLevel}{\f1 
\par 3.9.2 }{\f1\uldb Low-level functions}{\v\f1 IDH_NBC_ButtonLowLevel}{\f1 
\par 3.9.3 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_ButtonIOMapOffsets}{\f1 
\par 3.10 }{\f1\uldb UI Module}{\v\f1 IDH_NBC_UserInterface}{\f1 
\par 3.10.1 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_UIIOMapOffsets}{\f1 
\par 3.11 }{\f1\uldb LowSpeed Module}{\v\f1 IDH_NBC_LowSpeed}{\f1 
\par 3.11.1 }{\f1\uldb High-level functions}{\v\f1 IDH_NBC_LowSpeedHighLevel}{\f1 
\par 3.11.2 }{\f1\uldb Low-level functions}{\v\f1 IDH_NBC_LowSpeedLowLevel}{\f1 
\par 3.11.3 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_LowSpeedIOMapOffsets}{\f1 
\par 3.12 }{\f1\uldb Comm Module}{\v\f1 IDH_NBC_Comm}{\f1 
\par 3.12.1 }{\f1\uldb High-level functions}{\v\f1 IDH_NBC_CommHighLevel}{\f1 
\par 3.12.2 }{\f1\uldb Low-level functions}{\v\f1 IDH_NBC_CommLowLevel}{\f1 
\par 3.12.2.1 }{\f1\uldb USB functions}{\v\f1 IDH_NBC_CommUSB}{\f1 
\par 3.12.2.2 }{\f1\uldb Hi-Speed functions}{\v\f1 IDH_NBC_CommHS}{\f1 
\par 3.12.2.3 }{\f1\uldb Bluetooth functions}{\v\f1 IDH_NBC_CommBT}{\f1 
\par 3.12.3 }{\f1\uldb IOMap Offsets}{\v\f1 IDH_NBC_CommIOMapOffsets}{\f1 
\par 3.13 }{\f1\uldb HiTechnic API Functions}{\v\f1 IDH_NBC_HiTechnic}{\f1 
\par 3.14 }{\f1\uldb Mindsensors API Functions}{\v\f1 IDH_NBC_Mindsensors}{\f1 
\par }\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NBC_Introduction}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Introduction}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  introduction;language}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{1 Introduction
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 NBC stands for NeXT Byte Codes. It is a simple language for programming the LEGO 
MINDSTORMS NXT product. The NXT has a byte-code interpreter (provided by LEGO), which can be used to execute programs. The NBC compiler translates a source program into LEGO NXT byte-codes, which can then be executed on the NXT itself. Although the prepro
cessor and format of NBC programs are similar to assembly, NBC is not a general-purpose assembly language \endash  there are many restrictions that stem from limitations of the LEGO byte-code interpreter.
\par Logically, NBC is defined as two separate pieces. The NBC l
anguage describes the syntax to be used in writing programs. The NBC Application Programming Interface (API) describes the system functions, constants, and macros that can be used by programs. This API is defined in a special file known as a "header file"
 which should be included at the beginning of any NBC program. By default, this file is not automatically included when compiling a program.
\par This document describes both the NBC language and the NBC API. In short, it provides the information needed to write
 NBC programs. Since there are different interfaces for NBC, this document does not describe how to use any specific NBC implementation (such as the command-line compiler or Bricx Command Center). Refer to the documentation provided with the NBC tool, suc
h as the NBC User Manual, for information specific to that implementation.
\par For up-to-date information and documentation for NBC, visit the NBC website at }{\field{\*\fldinst {\f1  HYPERLINK "http://bricxcc.sourceforge.net/nbc/" }{\f1 {\*\datafield 
00d0c9ea79f9bace118c8200aa004ba90b02000000170000002400000068007400740070003a002f002f0062007200690063007800630063002e0073006f00750072006300650066006f007200670065002e006e00650074002f006e00620063002f000000e0c9ea79f9bace118c8200aa004ba90b48000000680074007400
70003a002f002f0062007200690063007800630063002e0073006f00750072006300650066006f007200670065002e006e00650074002f006e00620063002f0000000000000000000000020000}}}{\fldrslt {\cs17\f1\ul\cf2 http://bricxcc.sourceforge.net/nbc/}}}{\f1 .
\par }\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Language}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  The NBC Language}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  language}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2 The NBC Language
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This section describes the NBC language itself. This includes the lexical rules used by the compiler, the structure programs, statements, and expressions, and the operation of the preprocessor.
\par Unlike some assembly languages, NBC is a case-sensi
tive language.  That means that the identifier "xYz" is not the same identifier as "Xyz".  Similarly, the subtract statement begins with the keyword "sub" but "suB", "Sub", or "SUB" are all just valid identifiers \endash  not keywords.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_LexicalRules}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Lexical Rules}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}
{\f1  lexical rules}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{
2.1 Lexical Rules
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The 
lexical rules describe how NBC breaks a source file into individual tokens. This includes the way comments are written, then handling of whitespace, and valid characters for identifiers.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NBC_Comments}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Comments}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  comments}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.1.1 Comments
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Three forms of comments are supported in NBC. The
 first form (traditional C comments) begin with /* and end with */. They may span multiple lines, but do not nest:
\par }\pard \ql \fi-360\li1080\ri0\sb120\sa120\widctlpar\faauto\adjustright\rin0\lin1080\itap0 {\f2 /* this is a comment */
\par }\pard \ql \fi-360\li1080\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin1080\itap0 {\f2 /* this is a two\line line comment * /
\par /* another comment...\line /* trying to nest...\line  \tab ending the inner comment... */\line this text is no longer a comment! */
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The second form of comments begins with // and ends with a newline (sometimes known as C++ style comments).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 // a single line comment
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The third form of comments begins with ; and ends with a newline (sometimes known as assembly language style comments).
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 ; another single line comment
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The compiler ignores comments. Their only purpose is to allow the programmer to document the source code.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Whitespace}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Whitespace}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  whitespace}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.1.2 Whitespace
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Whitespace (spaces, tabs, and newlines) is used to separate tokens and 
to make programs more readable. As long as the tokens are distinguishable, adding or subtracting whitespace has no effect on the meaning of a program. For example, the following lines of code both have the same meaning:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2 set}{\f2  x,2\line }{\b\f2 set}{\f2    x,   2\line 
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Generally, whi
tespace is ignored outside of string constants and constant numeric expressions.  However, unlike in C, NBC statements may not span multiple lines.  Aside from pre-processor macros invocations, each statement in an NBC program must begin and end on the sa
me line.  
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2 add}{\f2  x, x, 2 ; okay\line }{\b\f2 add}{\f2  x,      // error\line     x, 2    // error\line \line }{\b\f2 set}{\f2  x, (2*2)+43-12 ; okay\line }{\b\f2 set}{\f2 
 x, 2 * 2 ; error (constant expression contains whitespace)\line 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_NumericConstants}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Numerical Constants}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  numerical constants; constants}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.1.3 Numerical Constants

\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Numerical constants may be written in either decimal or hexadec
imal form. Decimal constants consist of one or more decimal digits. Hexadecimal constants start with 0x or 0X followed by one or more hexadecimal digits.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2 set}{\f2  x, 10 // set x to 10
\par }{\b\f2 set}{\f2  x, 0x10 ; set x to 16 (10 hex)
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_IdentKeywords}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Identifiers and Keywords}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  identifiers;keywords}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.1.4 Identifiers and Keywords
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Identi
fiers are used for variable, task, function, and subroutine names. The first character of an identifier must be an upper or lower case letter or the underscore ('_'). Remaining characters may be letters, numbers, and an underscore. 
\par A number of potential identifiers are reserved for use in the NBC language itself. These reserved words are called keywords and may not be used as identifiers. A complete list of keywords appears below:
\par }\pard \ql \li720\ri0\widctlpar\tx2520\tx4320\tx6480\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 add\tab sub\tab neg\tab mul
\par div\tab mod\tab and\tab or
\par xor\tab not\tab cmp\tab tst
\par index\tab replace\tab arrsize\tab arrbuild
\par arrsubset\tab arrinit\tab mov\tab set
\par flatten\tab unflatten\tab numtostr\tab strtonum
\par strcat\tab strsubset\tab strtoarr\tab arrtostr
\par jmp\tab brcmp\tab brtst\tab syscall
\par stop\tab exit\tab exitto\tab acquire
\par release\tab subcall\tab subret\tab setin
\par setout\tab getin\tab getout\tab wait
\par gettick\tab thread\tab endt\tab subroutine
\par follows\tab precedes\tab segment\tab ends
\par typedef\tab struct\tab db\tab byte
\par sbyte\tab ubyte\tab dw\tab word
\par sword\tab uword\tab dd\tab dword
\par sdword\tab udword\tab long\tab slong
\par ulong\tab void\tab mutex\tab waitv
\par call\tab return\tab abs\tab sign
\par strindex\tab strreplace\tab strlen\tab shl
\par shr\tab sizeof\tab compchk\tab compif
\par compelse\tab compend\tab Functionof\tab isconst
\par asl\tab asr\tab lsl\tab lsr
\par rotl\tab rotr\tab start\tab stopthread
\par priority\tab cmnt \tab fmtnum\tab compchktype
\par }{\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_ProgStructure}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Program Structure}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  structure}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.2 Program Structure
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
An NBC program is composed of code blocks and global variables in data segments. There are two primary types of code blocks: thread and subroutines. Each of these types of co
de blocks has its own unique features and restrictions, but they share a common structure.  
\par A third type of code block is the preprocessor macro function.  This code block type is used throughout the NBC API.  Macro functions are the only type of code blo
ck, which use a parameter passing syntax similar to what you might see in a language like C or Pascal.
\par Data segment blocks are used to define types and to declare variables.  An NBC program can have zero or more data segments, which can be placed either ou
tside of a code block or within a code block.  Regardless of the location of the data segment, all variables in an NBC program are global.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Tasks}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Threads}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1 
 threads}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.2.1 Threads
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT implicitly supports multi-threading, thus an NBC thread directly corresponds to an NXT thr
ead. Threads are defined using the thread keyword with the following syntax:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 thread name
\par   // the thread's code is placed here
\par endt
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The name of the thread may be any legal identifier. A program must always have at least one thread. If there is a thread na
med "main" then that thread will be the thread that is started whenever the program is run. If none of the threads are named "main" then the very first thread that the compiler encounters in the source code will be the main thread. The maximum number of t
hreads supported by the NXT is 256.
\par The body of a thread consists of a list of statements and optional data segments. Threads may be started by scheduling dependant threads using the precedes or follows statements. You may also start a thread using the star
t statement.  With the standard NXT firmware threads cannot be stopped by another thread.  The only way to stop a thread is by stopping all threads using the stop statement or by a thread stopping on its own via the exit and exitto statements. Using the N
BC/NBC enhanced firmware you can also stop another thread using the stopthread statement.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 thread main
\par   precedes waiter, worker
\par   /* thread body goes here */
\par   // finalize this thread and schedule the threads in the
\par   // specified range to execute
\par   exit // all dependants are automatically scheduled
\par endt
\par 
\par thread waiter
\par   /* thread body goes here */
\par //  exit 
\par   ; exit is optional due to smart compiler finalization
\par endt
\par 
\par thread worker
\par   precedes waiter
\par   /* thread body goes here */
\par   exit // only one dependent \endash  schedule it to execute
\par endt
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Subroutines}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Subroutines}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  subroutines}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.2.2 Subroutines
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Subroutines allow a single copy of some code to be shared between several different callers. This makes subroutines much more space efficient than macro functions. Subroutines are defined using the subroutine keyword with the following syntax:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\noproof subroutine name
\par   // body of subroutine
\par   return // subroutines must end with a return statement
\par ends
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 A subroutine is just a special type of thread that is designed to be called explicitly by other threads or sub
routines.  Its name can be any legal identifier.  Subroutines are not scheduled to run via the same mechanism that is used with threads.  Instead, subroutines and threads execute other subroutines by using the call statement (described in the section titl
ed Statements). 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\noproof thread main
\par   /* body of main thread goes here */
\par   call mySub // compiler handles subroutine return address
\par   exit // finalize execution (details handled by the compiler)
\par endt
\par 
\par subroutine mySub
\par   /* body of subroutine goes here */
\par   return // compiler handles the subroutine return address
\par ends
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
You can pass arguments into and out of subroutines using global variables. If a subroutine is designed to be used by concurrently executing threads then calls to the subroutine must be protected by a
cquiring a mutex prior to the subroutine call and releasing the mutex after the call.
\par You can also call a thread as a subroutine using a slightly different syntax.  This technique is required if you want to call a subroutine which executes two threads simu
ltaneously.  The subcall and subret statements must be used instead of call and return.  You also must provide a global variable to store the return address as shown in the sample code below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\noproof thread main
\par   /* thread body goes here */
\par   acquire ssMutex
\par   call SharedSub ; automatic return address
\par   release ssMutex
\par   // calling a thread as a subroutine
\par   subcall AnotherSub, anothersub_returnaddress
\par   exit
\par endt
\par 
\par subroutine SharedSub
\par   /* subroutine body goes here */
\par   return ; return is required as the last operation
\par ends
\par \tab 
\par thread AnotherSub
\par   /* threads can be subroutines too */
\par   subret anothersub_returnaddress ; manual return address
\par endt
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 After the subroutine completes executing, it returns back to the calling routine and program execution continues with the
 next statement following the subroutine call. The maximum number of threads and subroutines supported by the NXT firmware is 256.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NBC_MacroFunctions}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Macro Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  macros}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1 
 cc}}}{2.2.3 Macro Functions
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 It is often helpful to group a set of statements together into a single function, which can then b
e called as needed. NBC supports macro functions with arguments.  Values may be returned from a macro function by changing the value of one or more of the arguments within the body of the macro function.
\par Macro functions are defined using the following syntax:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #define name(argument_list) \\
\par   // body of the macro function \\
\par   // last line in macro function body has no '\\' at the end
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Please note that the newline escape character ('\\') must be the very last character on the line.  If it is followed by any whit
espace or comments then the macro body is terminated at that point and the next line is not considered to be part of the macro definition.
\par The argument list may be empty, or it may contain one or more argument definitions. An argument to a macro function h
as no type. Each argument is simply defined by its name. Multiple arguments are separated by commas. Arguments to a macro function can either be inputs (constants or variables) for the code in the body of the function to process or they can be outputs (va
riables only) for the code to modify and return.  The following sample shows how to define a macro function to simplify the process of drawing text on the NXT LCD screen:
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\lang3082\langfe1033\langnp3082 #define MyMacro(x, y, berase, msg) \\
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\lang3082\langfe1033\langnp3082   }{\f2 mov dtArgs.Location.X, x \\
\par   mov dtArgs.Location.Y, y \\
\par   mov dtArgs.Options, berase \\
\par   mov dtArgs.Text, msg \\
\par   syscall DrawText, dtArgs
\par \tab 
\par MyMacro(0, 0, TRUE, 'testing')
\par MyMacro(10, 20, FALSE, 'Please Work')
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 NBC macro functions are always expanded inline by the NBC preprocessor. This means that each call to a macro function results in another copy of the function\rquote 
s code being included in the program. Unless used judiciously, inline macro functions can lead to excessive code size.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_DataSegments}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Data Segments}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}
{\f1  data segments}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.2.4 Data Segments
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Data segments contain all type definitions and
 variable declarations. Data segments are defined using the following syntax:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 dseg segment
\par   // type definitions and variable declarations go here
\par dseg ends
\par 
\par thread main
\par   dseg segment
\par     // or here \endash  still global, though
\par   dseg ends
\par endt
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 You can have mu
ltiple data segments in an NBC program. All variables are global regardless of where they are declared. Once declared, they may be used within all threads, subroutines, and macro functions. Their scope begins at the declaration and ends at the end of the 
program.
\par }\pard\plain \s4\ql \fi-864\li864\ri0\sb240\sa60\keepn\widctlpar\jclisttab\tx864\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin864\itap0 \b\i\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 \page }{\cs16\f1\super #{\footnote 
\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_TypeDefinitions}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Type Definitions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  types}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc
}}}{\f1 2.2.4.1 Type Definitions
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Type definitions must be contained within a data segment. They are used to define new type aliases or new aggregate types (i.e., structures). A type alias is defined using the typedef keyword with the following syntax:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 type_alias typedef existing_type 
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
The new alias name may be any valid identifier.  The existing type must be some type already known by the compiler.  It can be a native type or a user-defined type. Once a type alias has been defined it can be used in su
bsequent variable declarations and aggregate type definitions. The following is an example of a simple type alias definition:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 big typedef dword ; big is now an alias for the dword type
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Structure definitions must also be contained within a data segment. Th
ey are used to define a type which aggregates or contains other native or user-defined types. A structure definition is defined using the struct and ends keywords with the following syntax:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 TypeName struct
\par   x byte
\par   y byte
\par TypeName ends
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Structure definit
ions allow you to manage related data in a single combined type. They can be as simple or complex as the needs of your program dictate. The following is an example of a fairly complex structure:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 MyPoint struct
\par   x byte
\par   y byte
\par MyPoint ends
\par ComplexStrut struct
\par   value1 big            // using a type alias
\par   value2 sdword
\par   buffer byte[]         /* array of byte */
\par   blen word
\par   extrastuff MyPoint[]  // array of structs
\par   pt_1 MyPoint          // struct contains struct instances
\par   pt_2 MyPoint
\par ComplexStruct ends
\par 
\par }\pard\plain \s4\ql \fi-864\li864\ri0\sb240\sa60\keepn\widctlpar\jclisttab\tx864\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin864\itap0 \b\i\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 \page }{\cs16\f1\super #{\footnote 
\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_VariableDeclarations}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Variable Declarations}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  variables}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{
\f1  cc}}}{\f1 2.2.4.2 Variable Declarations
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
All variable declarations must be contained within a data segment. They are used to declare variables for use in a code block such as a thread, subroutine, or macro function. A variable is declared using the following syntax:
\par }\pard \ql \fi270\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\i\f2\fs22 var_name}{\f2\fs22  }{\i\f2\fs22 type_name}{\f2\fs22  }{\i\f2\fs22 optional_initialization}{\f2\fs22 
\par }{\i\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
The variable name may be any valid identifier. The type name must be a type or type alias already known by the compiler. The optional initialization format depends on the variable type, but for non-agg
regate (scalar) types the format is simply a constant integer or constant expression (which may not contain whitespace).  See the examples later in this section.
\par The NXT firmware supports several different types of variables which are grouped into two cate
gories: scalar types and aggregate types. Scalar types are a single integer value which may be signed or unsigned and occupy one, two, or four bytes of memory. The keywords for declaring variables of a scalar type are listed in the following table:
\par }\pard \ql \li2160\ri0\widctlpar\tx4500\faauto\adjustright\rin0\lin2160\itap0 {\b\f1 Type Name\tab Information
\par }{\f1 byte, ubyte, db\tab 8 bit unsigned
\par sbyte\tab 8 bit signed
\par word, uword, dw\tab 16 bit unsigned
\par sword\tab 16 bit signed
\par dword, udword, dd\tab 32 bit unsigned
\par sdword\tab 32 bit signed
\par long, ulong\tab 32 bit unsigned (alias for dword, udword)
\par slong\tab 32 bit signed (alias for sdword)
\par }\pard \ql \li2160\ri0\sa120\widctlpar\tx4500\faauto\adjustright\rin0\lin2160\itap0 {\f1 mutex\tab Special type used for exclusive subroutine access
\par }\pard\plain \s25\qc \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs24 {\*\bkmkstart _Toc180913077}Table }{\field{\*\fldinst {\f1\fs24  SEQ Table \\
* ARABIC }}{\fldrslt {\f1\fs24\lang1024\langfe1024\noproof 1}}}{\f1\fs24 . Scalar Types{\*\bkmkend _Toc180913077}
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Examples of scalar variable declarations are as follow:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 dseg }{\b\f2\fs22 segment
\par }\pard \ql \fi270\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 x }{\b\f2\fs22 byte}{\f2\fs22             }{\i\f2\fs22 // initialized to zero by default}{\f2\fs22 
\par y }{\b\f2\fs22 byte}{\f2\fs22  12         }{\i\f2\fs22 ; initialize to 12}{\f2\fs22  
\par z }{\b\f2\fs22 sword}{\f2\fs22  -2048     }{\i\f2\fs22 /* a signed value */}{\f2\fs22 
\par myVar big 0x12345 }{\i\f2\fs22 ; use a type alias}{\f2\fs22 
\par var1 }{\b\f2\fs22 dword}{\f2\fs22  0xFF   }{\i\f2\fs22 ; value is 255}{\f2\fs22 
\par myMutex }{\b\f2\fs22 mutex  }{\f2\fs22    }{\i\f2\fs22 ; mutexes ignore initialization, if present}{\f2\fs22 
\par bTrue }{\b\f2\fs22 byte}{\f2\fs22  1      }{\i\f2\fs22 ; byte variables can be used as booleans}{\f2\fs22 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 dseg }{\b\f2\fs22 ends
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 A
ggregate variables are either structures or arrays of some other type (either scalar or aggregate). Once a user-defined struct type has been defined it may be used to declare a variable of that type. Similarly, user-defined struct types can be used in arr
a
y declarations.  Arrays and structs may be nested (i.e., contained in other arrays or structures) as deeply as the needs of your program dictate, but nesting deeper than 2 or 3 levels may lead to slower program execution due to NXT firmware memory constra
ints.
\par Examples of aggregate variable declarations are as follow:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 dseg }{\b\f2\fs22 segment}{\f2\fs22 
\par }\pard \ql \fi274\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 buffer }{\b\f2\fs22 byte[]}{\f2\fs22  // starts off empty
\par msg }{\b\f2\fs22 byte[]}{\f2\fs22  'Testing' 
\par }{\i\f2\fs22 // msg is an array of byte = 
\par // (0x54, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x00)
\par }{\f2\fs22 data }{\b\f2\fs22 long}{\f2\fs22 [] \{0xabcde, 0xfade0\} }{\i\f2\fs22 ; two values in the array}{\f2\fs22 
\par myStruct ComplexStruct }{\i\f2\fs22 ; declare an instance of a struct}{\f2\fs22 
\par Points MyPoint[] }{\i\f2\fs22 ; declare an array of a structs}{\f2\fs22 
\par msgs }{\b\f2\fs22 byte}{\f2\fs22 [][] }{\i\f2\fs22 ; an array of an array of byte}{\f2\fs22 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 dseg }{\b\f2\fs22 ends
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Byte arrays may be initialized either by using braces containing a list of numeric values (\{val1, val2, ..., valN\}
) or by using a string constant delimited with single-quote characters ('Testing'). Embedded single quote characters are not supported. Arrays of any scalar type other than byte should be initialized using braces. Arrays
 of struct and nested arrays cannot be initialized.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Preprocessor}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Preprocessor}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  preprocessor}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.3 The Preprocessor
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The preprocessor implements the following directives: }{\f2 #include}{\f1 , }{\f2 #define}{\f1 , }{\f2 #ifdef}{\f1 , }{\f2 
#ifndef}{\f1 , }{\f2 #if}{\f1 , }{\f2 #elif}{\f1 , }{\f2 #else}{\f1 , }{\f2 #endif}{\f1 , }{\f2 #undef,##,}{\f1  }{\f2 #line}{\f1 , and }{\f2 #pragma}{\f1 . Its implementation is fairly c
lose to a standard C preprocessor, so most things that work in a generic C preprocessor should have the expected effect in NBC. Significant deviations are listed below.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Include}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1040\langfe1033\super\langnp1040 $}{\f1\lang1040\langfe1033\langnp1040  #include}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1040\langfe1033\super\langnp1040 K}{\f1\lang1040\langfe1033\langnp1040  #include}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1040\langfe1033\super\langnp1040 +}{\f1\lang1040\langfe1033\langnp1040  cc}}}{2.3.1 #include
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 #include}{\f1  command works as expected, with the caveat that the fi
lename must be enclosed in double quotes. There is no notion of a system include path, so enclosing a filename in angle brackets is forbidden.
\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #include "foo.h" // ok
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #include <foo.h> // error!
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 NBC programs can begin with #include "NXTDefs.h" but they don't
 need to. This standard header file includes many important constants and macros which form the core NBC API. Current versions of NBC no longer require that you manually include the NXTDefs.h header file. Unless you specifically tell the compiler to ignor
e the standard system files this header file will automatically be included for you.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1040\langfe1033\super\langnp1040 #}{\f1\lang1040\langfe1033\langnp1040  IDH_NBC_Define}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1040\langfe1033\super\langnp1040 $}{\f1\lang1040\langfe1033\langnp1040  #define}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  #define}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.3.2 #define
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 #define}{\f1 
 command is used for simple macro substitution. Redefinition of a macro is an error (unlike in C where it is a warning). Use #define to define your own constants for use throughout the program.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 #define TurnTime 3000 }{\i\f2\fs22 ; 3 seconds
\par }{\f2 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Macros are normally terminated by the end of the line, but the newline may be escaped with the backslash ('\\') to allow multiline macros (as described in the Macro Funct
ions section above):
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 #define square(x, result) \\
\par   mul result, x, x 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 #undef}{\f1  directive may be used to remove a macro\rquote s definition.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NBC_Concatenation}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Concatenation}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  concatenation}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.3.3 ## (Concatenation)
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The ## directive works similar to the C preprocessor. It is replaced by nothing, which cause
s tokens on either side to be concatenated together. Because it acts as a separator initially, it can be used within macro functions to produce identifiers via combination with parameter values.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NBC_CondCompilation}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Conditional Compilation}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 K}{\f1\lang1036\langfe1033\langnp1036  conditional compilation}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 +}{\f1\lang1036\langfe1033\langnp1036  cc}}}{2.3.4 Conditional Compilation
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Conditional compilation works similar to the C preprocessor. The following preprocessor directives may be used:

\par }\pard \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #if }{\i\f2 condition}{\f2 
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2 #ifdef }{\i\f2 symbol}{\f2 
\par #ifndef }{\i\f2 symbol}{\f2 
\par #else
\par #elif }{\i\f2 condition}{\f2 
\par #endif
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Conditions in }{\f2 #if}{\f1  directives use the same operators and precedence as in C. The }{\f2 defined()}{\f1  operator is supported.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 #}{\f1\lang1036\langfe1033\langnp1036  IDH_NBC_CompilerTokens}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\lang1036\langfe1033\super\langnp1036 $}{\f1\lang1036\langfe1033\langnp1036  Compiler Tokens}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  compiler tokens}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.4 Compiler Tokens
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
NBC supports special tokens, which it replaces on compilation. The tokens are similar to preprocessor #define macros but they are actually handled directly by the compiler rather than the preprocessor.  The supported tokens are as follows:
\par }\pard \ql \fi-2772\li3780\ri0\widctlpar\tx3762\faauto\adjustright\rin0\lin3780\itap0 {\b\f1\fs28 Token\tab Usage
\par }\pard \ql \fi-2772\li3780\ri0\sa120\widctlpar\tx3762\faauto\adjustright\rin0\lin3780\itap0 {\f1 __FILE__\tab This token is replaced with the currently active filename (no path)
\par __LINE__\tab This token is replaced with the current line number
\par __VER__\tab This token is replaced with the compiler version number
\par __THREADNAME__\tab This token is replaced with the current thread name
\par __I__, __J__\tab These tokens are replaced with the current value of I or J.  They are both initialized to zero at the start of each thread or subroutine.
\par __ResetI__, __ResetJ__\tab These tokens are replaced with nothing.  As a side effect the value of I or J is reset to zero.
\par __IncI__, __IncJ__\tab These tokens are replaced with nothing.  As a side effect the value of I or J is incremented by one.
\par __DecI__, __DecJ__\tab These tokens are replaced with nothing.  As a side effect the value of I or J is decremented by one.
\par }\pard\plain \s25\qc \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs24 {\*\bkmkstart _Toc180913078}Table }{\field{\*\fldinst {\f1\fs24  SEQ Table \\
* ARABIC }}{\fldrslt {\f1\fs24\lang1024\langfe1024\noproof 2}}}{\f1\fs24 . Compiler Tokens{\*\bkmkend _Toc180913078}
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The ## preprocessor directive can help make the use of compiler tokens more readable. __THREADNAME__##_##__I__:  would become something like main_1:.  Without the ## directive it would much harder to read the mixture of compiler tokens and underscores.

\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_ExpressionEvaluator}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Expression Evaluator}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  expression evaluator}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{2.5 Expression Evaluator
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Constant expressions are supported by NBC for many statement arguments as well as variable initialization. Expressions are evaluated
 by the compiler when the program is compiled, not at run time. The compiler will return an error if it encounters an expression that contains whitespace. "4+4" is a valid constant expression but "4 + 4" is not.  
\par The expression evaluator supports the following operators:
\par }\pard \ql \li2880\ri0\widctlpar\tx4608\faauto\adjustright\rin0\lin2880\itap0 {\f1 +\tab addition
\par -\tab subtraction
\par *\tab multiplication
\par /\tab division
\par ^\tab exponent 
\par % \tab modulo (remainder)
\par &\tab bitwise and
\par |\tab bitwise or
\par ~\tab bitwise xor
\par <<\tab shift left
\par >>\tab shift right
\par ()\tab grouping subexpressions
\par }\pard \ql \li2880\ri0\sa120\widctlpar\tx4608\faauto\adjustright\rin0\lin2880\itap0 {\f1 PI\tab constant value
\par }\pard\plain \s25\qc \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs24 {\*\bkmkstart _Toc180913079}Table }{\field{\*\fldinst {\f1\fs24  SEQ Table \\
* ARABIC }}{\fldrslt {\f1\fs24\lang1024\langfe1024\noproof 3}}}{\f1\fs24 . Constant Expression Operators{\*\bkmkend _Toc180913079}
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The expression evaluator also supports the following compile-time functions:
\par }\pard \ql \li1440\ri1440\sa120\widctlpar\faauto\adjustright\rin1440\lin1440\itap0 {\f2\fs22 tan(x), sin(x), cos(x)\line sinh(x), cosh(x)\line arctan(x), cotan(x)\line arg(x)\line exp(x), ln(x), log10(x), log2(x), logn(x, n)\line sqr(x), sqrt(x)\line 
trunc(x), int(x), ceil(x), floor(x), heav(x)\line abs(x), sign(x), zero(x), ph(x)\line rnd(x), random(x)\line max(x, y), min(x, y)\line power(x, exp), intpower(x, exp)
\par }\pard\plain \s25\qc \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs24 {\*\bkmkstart _Toc180913080}Table }{\field{\*\fldinst {\f1\fs24  SEQ Table \\
* ARABIC }}{\fldrslt {\f1\fs24\lang1024\langfe1024\noproof 4}}}{\f1\fs24 . Constant Expression Functions{\*\bkmkend _Toc180913080}
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The following example demonstrates how to use a constant expression:
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\i\f2\fs22 // expression value will be truncated to an integer
\par }{\b\f2\fs22 set}{\f2\fs22  val, 3+(PI*2)-sqrt(30)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_IOMAPAddresses}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  IOMAP Addresses}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super 
K}{\f1  iomap addresses}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.6 IO-Map Address (IOMA) Constants
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
IOMA constants provide a simplified means for accessing input and output field values without having to use a variable or an input or out
put statement.  The constants are defined in the NBCCommon.h header file which is included automatically in your NBC program.
\par There are IOMA constants for inputs and IOMA constants for outputs.  They are defined as preprocessor macros.  To specify the port
 for each IOMA you must use a constant such as IN_1 or OUT_A.  You can often substitute an IOMA constant in statements which can accept a scalar variable argument.  The IOMA macros are shown below.
\par }\pard \ql \li2880\ri0\widctlpar\faauto\adjustright\rin0\lin2880\itap0 {\b\f1\fs24 IO-Map Address Macros
\par }{\f1 InputIOType(port)
\par }{\f1\lang1036\langfe1033\langnp1036 InputIOInputMode(port)
\par InputIORawValue(port)
\par InputIONormalizedValue(port)
\par InputIOScaledValue(port)
\par InputIOInvalidData(port)
\par OutputIOUpdateFlags(port)
\par OutputIOOutputMode(port)
\par OutputIOPower(port)
\par OutputIOActualSpeed(port)
\par OutputIOTachoCount(port)
\par OutputIOTachoLimit(port)
\par OutputIORunState(port)
\par OutputIOTurnRatio(port)
\par OutputIORegMode(port)
\par OutputIOOverload(port)
\par OutputIORegPValue(port)
\par OutputIORegIValue(port)
\par }{\f1 OutputIORegDValue(port)
\par OutputIOBlockTachoCount(port)
\par }\pard\plain \s25\ql \li2880\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin2880\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Toc180913081}Table }{\field{\*\fldinst {\f1  SEQ Table \\* ARABIC }
}{\fldrslt {\f1\lang1024\langfe1024\noproof 5}}}{\f1 . IOMA Constant Macros{\*\bkmkend _Toc180913081}
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Statements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7 Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The body of a code block (thread, subroutine, or macro function) is composed of statements. All statements are terminated with the newline character.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Assignment}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Assignment Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  assignment statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.1 Assignment Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Assignment statements enable you to copy values from one variabl
e to another or to simply set the value of a variable.  In NBC there are two ways to assign a new value to a variable.  
\par The }{\f2 mov}{\f1  statement assigns the value of its second argument to its first argument.  The first argument must be the name of a variable.  
It can be of any valid variable type except mutex.  The second argument can be a variable or a numeric or string constant.  If a constant is used, the compiler creates a variable behind the scenes and initializes it to the specified constant value.  

\par Both arguments to the }{\f2 mov}{\f1 
 statement must be of compatible types.  A scalar value can be assigned to another scalar variable, regardless of type, structs can be assigned to struct variables if the structure types are the same, and arrays can be assigned to an ar
ray variable provided that the type contained in the arrays are the same. The syntax of the }{\f2 mov}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 mov}{\f2\fs22  x, y     // set x equal to y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 set}{\f1  statement also assigns its first argument to have the value of its second argument.  The fir
st argument must be the name of a variable.  It must be a scalar type.  The second argument must be a numeric constant or constant expression.  The syntax of the }{\f2 set}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 set x, 10     // set x equal to 10
\par 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Because all arguments must fit into a 2-byte value in the NXT executable, the second argument of the }{\f2 set}{\f1 
 statement is limited to a 16 bit signed or unsigned value (-32768..65535).}{\f2 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_MathStatements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Math Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super 
K}{\f1  math statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.2 Math Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Math statements enable you to perform basic math operations on data in your N
BC programs.  Unlike high level programming languages where mathematical expressions use standard math operators (such as *, -, +, /), in NBC, as with other assembly languages, math operations are expressed as statements with the math operation name comin
g first, followed by the arguments to the operation.  All statements in this family have one output argument and two input arguments except the negate statement, the absolute value statement, and the sign statement.
\par Math statements in NBC differ from tradit
ional assembly math statements because many of the operations can handle arguments of scalar, array, and struct types rather than only scalar types.  If, for example, you multiply an array by a scalar then each of the elements in the resulting array will 
be the corresponding element in the original array multiplied by the scalar value.  
\par Only the absolute value and sign statements require that their arguments are scalar types.  When using the standard NXT firmware these two statements are currently implemen
ted by the compiler since it does not have built-in support for them. If you install the enhanced NBC/NXC firmware and tell the compiler to target it using the \endash 
EF command line switch then these statements will be handled directly by the firmware itself rather than by the compiler.
\par The }{\f2 add}{\f1  statement lets you add two input values together and store the result in the first argument.  The first argument must be a variable but the second and third arguments can be variables, numeric constants, or constant expre
ssions.  The syntax of the }{\f2 add}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 add}{\f2\fs22  x, x, y ; add x and y and store result in x
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 sub}{\f1  statement lets you subtract two input values and store the result in the first argument.  The first argument must be a variable but the second
 and third arguments can be variables, numeric constants, or constant expressions.  The syntax of the }{\f2 sub}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 sub}{\f2\fs22  x, x, y ; subtract y from x and store result in x
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 mul}{\f1  statement lets you multiply two input values and store the re
sult in the first argument.  The first argument must be a variable but the second and third arguments can be variables, numeric constants, or constant expressions.  The syntax of the }{\f2 mul}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 mul}{\f2\fs22  x, x, x ; set x equal to x^2
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 div}{\f1  s
tatement lets you divide two input values and store the result in the first argument.  The first argument must be a variable but the second and third arguments can be variables, numeric constants, or constant expressions.  The syntax of the }{\f2 div}{
\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 div}{\f2\fs22  x, x, 2 ; set x equal to x / 2 (integer division)
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 mod}{\f1 
 statement lets you calculate the modulus value (or remainder) of two input values and store the result in the first argument.  The first argument must be a variable but the secon
d and third arguments can be variables, numeric constants, or constant expressions.  The syntax of the }{\f2 mod}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 mod}{\f2\fs22  x, x, 4 ; set x equal to x % 4 (0..3)
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 neg}{\f1  statement lets you negate an input value and store the result in the fir
st argument.  The first argument must be a variable but the second argument can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 neg}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 neg}{\f2\fs22  x, y ; set x equal to -y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 abs}{\f1  statement lets you take the 
absolute value of an input value and store the result in the first argument.  The first argument must be a variable but the second argument can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 abs}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 abs}{\f2\fs22  x, y ; set x equal to the absolute value of y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 sign}{\f1 
 statement lets you take the sign value (-1, 0, or 1) of an input value and store the result in the first argument.  The first argument must be a variable but the second argument can be a variable, a
 numeric constant, or a constant expression.  The syntax of the }{\f2 abs}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 sign}{\f2\fs22  x, y ; set x equal to -1, 0, or 1
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f2 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_LogicStatements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Logic Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  logic statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.3 Logic Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Logic statements let you perform basic logical operations on data in your NBC program.  As wit
h the math statements, the logical operation name begins the statement and it is followed by the arguments to the logical operation.  All the statements in this family have one output argument and two input arguments except the logical not statement.  Eac
h statement supports arguments of any type, scalar, array, or struct.
\par The }{\f2 and}{\f1  statement lets you bitwise and together two input values and store the result in the first argument.  The first argument must be a variable but the second and third arguments can 
be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 and}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 and}{\f2\fs22  x, x, y  // x = x & y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 or}{\f1  statement lets you bitwise or together two input values and store the result in the first argument.  The first a
rgument must be a variable but the second and third arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 or}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 or}{\f2\fs22  x, x, y  // x = x | y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 xor}{\f1  statement lets you bitwise exclusive or togethe
r two input values and store the result in the first argument.  The first argument must be a variable but the second and third arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 xor}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 xor}{\f2\fs22  x, x, y  // x = x ^ y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 not}{\f1 
 statement lets you logically not its input value and store the result in the first argument.  The first argument must be a variable but the second argument can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 not}{
\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 not}{\f2\fs22  x, x  // x = !x (logical not \endash  not bitwise)
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_BitManipulationStatements}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Bit Manipulation Statements}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  bit manipulation statements}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.4 Bit Manipulation Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Bit manipulation statements enable you to perform basic bitwise operations on data in your NBC programs.  All statements in this family have one output argument and two input arguments except the complement statement.
\par Using the standard NXT firmware the basic shift right and shift left statements (shr and shl) are implemented by the compiler since the firmware does not support s
hift operations at this time. If you install the enhanced NBC/NBC firmware and tell the compiler to target it using the \endash 
EF command line switch, then these operations will be handled directly by the firmware itself rather than by the compiler. The other bit manipulation statements described in this section are only available when targeting the enhanced firmware.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 shr}{\f2\fs22  x, x, y  // x = x >> y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 shl}{\f1  statement lets you shift left an input value by the number of bits specified by the second input argument and s
tore the resulting value in the output argument.  The output (first) argument must be a variable but the second and third arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 shl}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 shl}{\f2\fs22  x, x, y  // x = x << y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 asr}{\f1 
 statement lets you perform an arithmetic right shift operation.  The output (first) argument must be a variable but the second and third arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 asr}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 asr}{\f2\fs22  x, x, y  // x = x >> y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 asl}{\f1 
 statement lets you perform an arithmetic left shift operation.  The output (first) argument must be a variable but the second and third arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 asl}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 asl}{\f2\fs22  x, x, y  // x = x << y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 lsr}{\f1  statement lets you perform a logical right shift operation.  The output (first) argument must be a variable but the second and third arguments can be
 a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 lsr}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 lsr}{\f2\fs22  x, x, y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 lsl}{\f1  statement lets you perform a logical left shift operation.  The output (first) argument must be a variable but the second and t
hird arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 lsl}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 lsl}{\f2\fs22  x, x, y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 rotr}{\f1  statement lets you perform a rotate right operation.  The output (first) argument must be a variable but 
the second and third arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 rotr}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 rotr}{\f2\fs22  x, x, y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 rotl}{\f1  statement lets you perform a rotate left operation.  The output (first) argument must b
e a variable but the second and third arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 rotl}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 rotl}{\f2\fs22  x, x, y
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 cmnt}{\f1  statement lets you perform a bitwise complement operation.  The output
 (first) argument must be a variable but the second can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 cmnt}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 cmnt}{\f2\fs22  x, y // x = ~y
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_ComparisonStatements}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Comparison Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  comparison statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{2.7.5 Comparison Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Comparison statements enable you to 
compare data in your NBC programs. These statements take a comparison code constant as their first argument. Valid comparison constants are listed in the table below. You can use scalar, array, and aggregate types for the compare or test argument(s).

\par }\pard \ql \li1440\ri0\widctlpar\tx3600\tx5040\tx6120\faauto\adjustright\rin0\lin1440\itap0 {\b\f1 Comparison\tab Constant\tab Function\tab Alternative Token
\par }{\f1 Less than\tab LT\tab 0x00\tab <
\par Greater than\tab GT\tab 0x01\tab >
\par Less than or equal\tab LTEQ\tab 0x02\tab <=
\par Greater than or equal\tab GTEQ\tab 0x03\tab >=
\par Equal\tab EQ\tab 0x04\tab ==
\par Not equal\tab NEQ\tab 0x05\tab != or <>
\par }\pard\plain \s25\qc \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs24 {\*\bkmkstart _Ref180390481}{\*\bkmkstart _Toc180913082}Table }{\field{\*\fldinst {
\f1\fs24  SEQ Table \\* ARABIC }}{\fldrslt {\f1\fs24\lang1024\langfe1024\noproof 6}}}{\f1\fs24 {\*\bkmkend _Ref180390481}. Comparison Constants{\*\bkmkend _Toc180913082}
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 cmp}{\f1 
 statement lets you compare two different input sources.  The output (second) argument must be a variable but the remaining arguments can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 cmp}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 cmp}{\f2\fs22  EQ, bXEqualsY, x, y // bXEqualsY = (x == y);}{\b\f2\fs22 
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 tst}{\f1 
 statement lets you compare an input source to zero.  The output (second) argument must be a variable but the remaining argument can be a variable, a numeric constant, or a constant expression.  The syntax of the }{\f2 tst}{\f1  statement is shown below.

\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 tst}{\f2\fs22  GT, bXGTZero, x // bXGTZero = (x > 0);
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_ControlFlowStatements}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Control Flow Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  control flow statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{2.7.6 Control Flow Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Control flow statements enable you to manipulate or control the execution flow of your NBC programs. Some of these statements take a comparison code constant as their first argument. Valid comparison constants are listed in }{\field{\*\fldinst {\f1 
 REF _Ref180390481 \\h }{\f1 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0052006500660031003800300033003900300034003800310000000000000100}}}{\fldrslt {\f1\fs24 Table }{\f1\fs24\lang1024\langfe1024\noproof 6}}}{\f1 
 above. You can use scalar, array, and aggregate types for the compare or test argument(s).
\par The }{\f2 jmp}{\f1  statement lets you unconditionally jump from the current execution point to a new location.  Its only argument is a label that specifies where program execution should resume. The syntax of the }{\f2 jmp}{\f1  statement is shown below.

\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 jmp}{\f2\fs22  LoopStart // jump to the LoopStart label}{\b\f2\fs22 
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 brcmp}{\f1  statement lets you conditionally jump from the current execution point to a new location.  It is like the }{\f2 cmp}{\f1 
 statement except that instead of an output argument it has a label argument that specifies where program execution should resume. The syntax of the }{\f2 brcmp}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 brcmp}{\f2\fs22  EQ, LoopStart, x, y // jump to LoopStart if x == y}{\b\f2\fs22 
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 brtst}{\f1  statement lets you conditionally jump from the current execution point to a new location.  It is like the }{\f2 tst}{\f1 
 statement except that instead of an output argument it has a label argument that specifies where program execution should resume. The syntax of the }{\f2 brtst}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 brtst}{\f2\fs22  GT, lblXGTZero, x // jump to lblXGTZero if x > 0}{\b\f2\fs22 
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 stop}{\f1  statement lets you stop program execution completely, depending on the value of its boolean input argument. The syntax of the }{\f2 stop}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 stop }{\f2\fs22 bProgShouldStop // stop program if flag <> 0}{\b\f2\fs22 
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_SystemCallStatements}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  System Call Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  system call statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{2.7.7 System Call Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 syscall}{\f1  statement enables execution of various system functions via a constant f
unction ID and an aggregate type variable for passing arguments to and from the system function. The syntax of the }{\f2 syscall}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // ptArgs is a struct with input and output args
\par }{\b\f2\fs22 syscall}{\f2\fs22  SoundPlayTone, ptArgs
\par }{\b\f2\fs22 
\par }\pard \ql \li720\ri0\widctlpar\tx3420\faauto\adjustright\rin0\lin720\itap0 {\b\f1\fs28 Function ID\tab Function
\par }{\f1 FileOpenRead\tab 0
\par FileOpenWrite\tab 1
\par FileOpenAppend\tab 2
\par FileRead\tab 3
\par FileWrite\tab 4
\par FileClose\tab 5
\par FileResolveHandle\tab 6
\par FileRename\tab 7
\par FileDelete\tab 8
\par SoundPlayFile\tab 9
\par SoundPlayTone\tab 10
\par SoundGetState\tab 11
\par SoundSetState\tab 12
\par DrawText\tab 13
\par DrawPoint\tab 14
\par DrawLine\tab 15
\par DrawCircle\tab 16
\par DrawRect\tab 17
\par DrawGraphic\tab 18
\par SetScreenMode\tab 19
\par ReadButton\tab 20
\par CommLSWrite\tab 21
\par CommLSRead\tab 22
\par CommLSCheckStatus\tab 23
\par RandomNumber\tab 24
\par GetStartTick\tab 25
\par MessageWrite\tab 26
\par MessageRead\tab 27
\par CommBTCheckStatus\tab 28
\par CommBTWrite\tab 29
\par KeepAlive\tab 31
\par IOMapRead\tab 32
\par {\*\bkmkstart _Toc180913083}IOMapWrite\tab 33
\par IOMapReadByID\tab 34
\par IOMapWriteByID\tab 35
\par DisplayExecuteFunction\tab 36
\par CommExecuteFunction\tab 37
\par LoaderExecuteFunction\tab 38
\par }\pard\plain \s25\ql \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs24 Table }{\field{\*\fldinst {\f1\fs24  SEQ Table \\* ARABIC }}{\fldrslt {
\f1\fs24\lang1024\langfe1024\noproof 7}}}{\f1\fs24 . System Call Function IDs{\*\bkmkend _Toc180913083}
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_TimingStatements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Timing Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  timing statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.8 Timing Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Timing statements enable you to pause the execution of a thread or obtain informati
on about the system tick counter in your NBC programs. When using the standard NXT firmware NBC implements the wait and waitv statements as thread-specific subroutine calls due to them not being implemented. The enhanced NBC/NXC firmware implements these 
statements natively. If needed, you can implement simple wait loops using gettick.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 add}{\f2\fs22  endTick, currTick, waitms
\par Loop:
\par   }{\b\f2\fs22 gettick}{\f2\fs22  currTick
\par }\pard \ql \fi270\li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 brcmp}{\f2\fs22  LT, Loop, currTick, endTick
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 wait}{\f1  statement suspends the current thread for the number of milliseconds specified by its constant argument. The syntax of the }{\f2 wait}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 wait}{\f2\fs22  1000 // wait for 1 second}{\b\f2\fs22 
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 waitv}{\f1  statement acts like }{\f2 wait}{\f1  but it takes a variable argument. If you use a constant argument with }{\f2 waitv}{\f1 
 the compiler will generate a temporary variable for you. The syntax of the }{\f2 waitv}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 waitv}{\f2\fs22  iDelay // wait for the number of milliseconds in iDelay}{\b\f2\fs22 
\par }{\f2\fs22 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 gettick}{\f1  statement suspends the current thread for the number of milliseconds specified by its constant argument. The syntax of the }{\f2 gettick}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 gettick}{\f2\fs22  x // set x to the current system tick count
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_ArrayStatements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Array Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  array statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.9 Array Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Array statements enable you to populate and manipulate arrays in your NBC programs. 
\par The }{\f2 index}{\f1  statement extracts a single element from the source array and returns the value in the output (first) argument. The last argument is the index of the desired element. The syntax of the }{\f2 index}{\f1  statement is shown below.

\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // extract arrayValues[index] and store it in value
\par }{\b\f2\fs22 index}{\f2\fs22  value, arrayValues, index
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 replace}{\f1 
 statement replaces one or more items in a source array and stores the modified array contents in an output array. The array source argument (second) can be the same variable as the array destination (first) argument to replace wi
thout copying the array. The index of the element(s) to be replaced is specified via the third argument. The new value (last) argument can be an array, in which case multiple items are replaced. The syntax of the }{\f2 replace}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // replace arValues[idx] with x in arNew (arValues is unchanged)
\par }{\b\f2\fs22 replace}{\f2\fs22  arNew, arValues, idx, x
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 arrsize}{\f1  statement returns the number of elements in the input array (second) argument in the scalar output (first) argument. The syntax of the }{\f2 arrsize}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 arrsize}{\f2\fs22  nSize, arValues  // nSize == length of array
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 arrinit}{\f1  statement initializes the output array (first) argument using the value (second) and size (third) arguments provided. The syntax of the }{\f2 arrinit}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // initialize arValues with nSize zeros
\par }{\b\f2\fs22 arrinit}{\f2\fs22  arValues, 0, nSize
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 arrsubset}{\f1 
 statement copies a subset of the input array (second) argument to the output array (first) argument. The subset begins at the specified index (third) argument. The number of elemen
ts in the subset is specified using the length (fourth) argument. The syntax of the }{\f2 arrsubset}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // copy the first x elements to arSub
\par }{\b\f2\fs22 arrsubset}{\f2\fs22  arSub, arValues, NA, x
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 arrbuild}{\f1  statement constructs an output array from a variabl
e number of input arrays, scalars, or aggregates. The types of all the input arguments must be compatible with the type of the output array (first) argument. You must provide one or more comma-separated input arguments. The syntax of the }{\f2 arrbuild}{
\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // build data array from 3 sources
\par }{\b\f2\fs22 arrbuild}{\f2\fs22  arData, arStart, arBody, arEnd
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_StringStatements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  String Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  string statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.10 String Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
String statements enable you to populate and manipulate null-terminated byte arrays (aka strings) in your NBC programs.
\par The }{\f2 flatten}{\f1  statement converts its input (second) argument into its string output (first) argument. The syntax of the }{\f2 flatten}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 flatten}{\f2\fs22  strData, args  // copy args structure to strData
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 unflatten}{\f1  statement converts its input string (third) a
rgument to the output (first) argument type.  If the default value (fourth) argument type does not match the flattened data type exactly, including array sizes, then error output (second) argument will be set to TRUE and the output argument will contain a
 copy of the default argument. The syntax of the }{\f2 unflatten}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 unflatten}{\f2\fs22  args, bErr, strSource, x  // convert string to cluster
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 numtostr}{\f1  statement converts its scalar input (second) argument to a string output (first) argument. The syntax of the }{\f2 numtostr}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 numtostr}{\f2\fs22  strValue, value  // convert value to a string
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 fmtnum}{\f1  statement converts its scalar input (third) argument to a string output (first) argument. The format of the string output is specified via
 the format string (second) argument. The syntax of the }{\f2 fmtnum}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 fmtnum}{\f2\fs22  strValue, fmtStr, value  // convert value to a string
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 strtonum}{\f1  statement parses its input string (third) argument into a numeric output (first) argument, a
dvancing an offset output (second) argument past the numeric string. The initial input offset (fourth) argument determines where the string parsing begins. The default (fifth) argument is the value that is returned by the statement if an error occurs whil
e parsing the string. The syntax of the }{\f2 strtonum}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // parse string into num 
\par }{\b\f2\fs22 strtonum}{\f2\fs22  value, idx, strValue, idx, nZero  
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 strsubset}{\f1  statement copies a subset of the input string (second) argument to the output string (first) argu
ment. The subset begins at the specified index (third) argument. The number of characters in the subset is specified using the length (fourth) argument. The syntax of the }{\f2 strsubset}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // copy the first x characters in strSource to strSub
\par }{\b\f2\fs22 strsubset}{\f2\fs22  strSub, strSource, NA, x
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 strcat}{\f1 
 statement constructs an output string from a variable number of input strings. The input arguments must all be null-terminated byte arrays. You must provide one or more comma-separated input arguments. The syntax of the }{\f2 strcat}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // build data string from 3 sources
\par }{\b\f2\fs22 strcat}{\f2\fs22  strData, strStart, strBody, strEnd
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 arrtostr}{\f1  statement copies the input byte array (second) argument into its output string (first) argument and adds a null-ter
minator byte at the end. The syntax of the }{\f2 arrtostr}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 arrtostr}{\f2\fs22  strData, arrData  // convert byte array to string
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 strtoarr}{\f1  statement copies the input string (second) argument into its output byte array (first) argument excluding
 the last byte, which should be a null. The syntax of the }{\f2 strtoarr}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 strtoarr}{\f2\fs22  arrData, strData  // convert string to byte array
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 strindex}{\f1  statement extracts a single element from the source string and returns the value in the ou
tput (first) argument. The last argument is the index of the desired element. The syntax of the }{\f2 strindex}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // extract strVal[idx] and store it in val
\par }{\b\f2\fs22 strindex}{\f2\fs22  val, strVal, idx
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 strreplace}{\f1  statement replaces one or more character
s in a source string and stores the modified string in an output string. The string source argument (second) can be the same variable as the string destination (first) argument to replace without copying the string. The index of the character(s) to be rep
laced is specified via the third argument. The new value (fourth) argument can be a string, in which case multiple characters are replaced. The syntax of the }{\f2 strreplace}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\f2\fs22 // replace strValues[idx] with newStr in strNew
\par }{\b\f2\fs22 strreplace}{\f2\fs22  strNew, strValues, idx, newStr
\par }{\f1 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 strlen}{\f1  statement returns the length of the input string (second) argument in the scalar output (first) argument. The syntax of the }{\f2 strlen}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 strlen}{\f2\fs22  nSize, strMsg  // nSize == length of strMsg
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_SchedulingStatements}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Scheduling Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  scheduling statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{2.7.11 Scheduling Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Scheduling statements enable you to control the execution of multiple threads and the calling of subroutines in your NBC programs.
\par The }{\f2 exit}{\f1  statement finalizes the current thread and schedules zero or more dependant threads by sp
ecifying start and end dependency list indices. The thread indices are zero-based and inclusive. The two arguments are optional, in which case the compiler automatically adds indices for all the dependencies. The syntax of the }{\f2 exit}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 exit}{\f2\fs22  0, 2  // schedule this thread's 3 dependants
\par }{\b\f2\fs22 exit}{\f2\fs22  // schedule all this thread's dependants
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 exitto}{\f1  statement exits the current thread and schedules the specified thread to begin executing. The syntax of the }{\f2 exitto}{\f1  statement is shown below.

\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 exitto}{\f2\fs22  worker  // exit now and schedule worker thread
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 start}{\f1 
 statement causes the thread specified in the statement to start running immediately. Using the standard NXT firmware this statement is implemented by the compiler using a set of compiler-generated
 subroutines. The enhanced NBC/NXC firmware implements this statement natively. The syntax of the }{\f2 start}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 start}{\f2\fs22  worker  // start the worker thread
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 stopthread}{\f1  statement causes the thread specified in the statement to stop runnin
g immediately. This statement cannot be used with the standard NXT firmware. It is supported by the enhanced NBC/NXC firmware. The syntax of the }{\f2 stopthread}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 stopthread}{\f2\fs22  worker  // stop the worker thread
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 priority}{\f1  statement modif
ies the priority of the thread specified in the statement. This statement cannot be used with the standard NXT firmware. It is supported by the enhanced NBC/NXC firmware. The syntax of the }{\f2 priority}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 priority}{\f2\fs22  worker, 50  // change the priority of the worker thread
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 precedes}{\f1 
 statement causes the compiler to mark the threads listed in the statement as dependants of the current thread. A subset of these threads will begin executing once the current thread exits, depending on the for
m of the exit statement used at the end of the current thread. The syntax of the }{\f2 precedes}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 precedes}{\f2\fs22  worker, music, walking  // configure dependant threads
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 follows}{\f1  statement causes the compiler to mark the current thread as a d
ependant of the threads listed in the statement. The current thread will be scheduled to execute if all of the threads that precede it have exited and scheduled it for execution. The syntax of the }{\f2 follows}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 follows}{\f2\fs22  main  // configure thread dependencies
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 acquire}{\f1  statement acquires the named mutex.  If the mutex is already acquired the current thread waits until it becomes available. The syntax of the }{\f2 acquire}
{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 acquire}{\f2\fs22  muFoo  // acquire mutex for subroutine
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 release}{\f1  statement releases the named mutex allowing other threads to acquire it. The syntax of the }{\f2 release}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 release}{\f2\fs22  muFoo  // release mutex for subroutine
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 subcall}{\f1  statement calls into the named thread/subroutine and wait
s for a return (which might not come from the same thread). The second argument is a variable used to store the return address. The syntax of the }{\f2 subcall}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 subcall}{\f2\fs22  drawText, retDrawText  // call drawText subroutine
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 subret}{\f1  statement returns from a thread to the return address value contained in its input argument. The syntax of the }{\f2 subret}{\f1  statement is shown below.

\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 subret}{\f2\fs22  retDrawText  // return to calling routine
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 call}{\f1  statement executes the named subroutine and waits for a re
turn.  The argument should specify a thread that was declared using the subroutine keyword. The syntax of the }{\f2 call}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 call}{\f2\fs22  MyFavoriteSubroutine  // call routine
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 return}{\f1  statement returns from a subroutine. The compiler automatica
lly handles the return address for call and return when they are used with subroutines rather than threads. The syntax of the }{\f2 return}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 return}{\f2\fs22   // return to calling routine
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_InputStatements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Input Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  input statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.12 Input Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Input statements enable you to
 configure the four input ports and read analog sensor values in your NBC programs. Both statements in this category use input field identifiers to control which attribute of the input port you are manipulating. Valid input field identifiers are listed in
 the following table.
\par }\pard \ql \li1440\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin1440\itap0 {\b\f1 Input Field ID\tab Function
\par }{\f1 Type\tab 0
\par InputMode\tab 1
\par RawValue\tab 2
\par NormalizedValue\tab 3
\par ScaledValue\tab 4
\par InvalidData\tab 5
\par }\pard\plain \s25\ql \li1440\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin1440\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs24 {\*\bkmkstart _Toc180913084}Table }{\field{\*\fldinst {\f1\fs24  SEQ Table \\
* ARABIC }}{\fldrslt {\f1\fs24\lang1024\langfe1024\noproof 8}}}{\f1\fs24 . Input Field IDs{\*\bkmkend _Toc180913084}
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 setin}{\f1  statement sets an input field of a sensor on a port to the value specified i
n its first argument. The port is specified via the second argument. The input field identifier is the third argument. The syntax of the }{\f2 setin}{\f1  statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 setin}{\f2\fs22  IN_TYPE_SWITCH, IN_1, Type ; set sensor to switch type
\par }{\b\f2\fs22 setin}{\f2\fs22  IN_MODE_BOOLEAN, IN_1, InputMode ; set to boolean mode
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 getin}{\f1 
 statement reads a value from an input field of a sensor on a port and writes the value to its first argument. The port is specified via the second argument. The input field identifier is the third argument. The syntax of the }{\f2 getin}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 getin}{\f2\fs22  rVal, thePort, RawValue  // read raw sensor value
\par }{\b\f2\fs22 getin}{\f2\fs22  sVal, thePort, ScaledValue  // read scaled sensor value
\par }{\b\f2\fs22 getin}{\f2\fs22  nVal, thePort, NormalizedValue  // read normalized value
\par 
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_OutputStatements}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Output Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  output statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{2.7.13 Output Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Output statements enable you to configure and control the three NXT outputs in your NBC programs. Both statements in this category use output field identifiers to control which attribute of the output you are manipulating. Valid output field identifier
s are listed in the following table.
\par }\pard \ql \li1440\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin1440\itap0 {\b\f1 Output Field ID\tab Function
\par }{\f1 UpdateFlags\tab 0
\par OutputMode\tab 1
\par Power\tab 2
\par ActualSpeed\tab 3
\par TachoCount\tab 4
\par TachoLimit\tab 5
\par RunState\tab 6
\par TurnRatio\tab 7
\par RegMode\tab 8
\par Overload\tab 9
\par RegPValue\tab 10
\par RegIValue\tab 11
\par RegDValue\tab 12
\par BlockTachoCount\tab 13
\par RotationCount\tab 14
\par }\pard\plain \s25\ql \li1440\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin1440\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs24 {\*\bkmkstart _Toc180913085}Table }{\field{\*\fldinst {\f1\fs24  SEQ Table \\
* ARABIC }}{\fldrslt {\f1\fs24\lang1024\langfe1024\noproof 9}}}{\f1\fs24 . Output Field IDs{\*\bkmkend _Toc180913085}
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The }{\f2 setout}{\f1 
 statement sets one or more output fields of a motor on one or more ports to the value specified by the coupled input arguments. The first argument is either a scalar value specifying a single por
t or a byte array specifying multiple ports. After the port argument you then provide one or more pairs of output field identifiers and values. You can set multiple fields via a single statement. The syntax of the }{\f2 setout}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 set}{\f2\fs22  theMode, OUT_MODE_MOTORON  // set mode to motor on
\par }{\b\f2\fs22 set}{\f2\fs22  rsVal, OUT_RUNSTATE_RUNNING // motor running
\par }{\b\f2\fs22 set}{\f2\fs22  thePort, OUT_A  // set port to #1
\par }{\b\f2\fs22 set}{\f2\fs22  pwr, -75 // negative power means reverse motor direction
\par // set output values
\par }{\b\f2\fs22 setout}{\f2\fs22  thePort, OutputMode, theMode, RunState, rsVal, Power, pwr
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 getout}{\f1 
 statement reads a value from an output field of a sensor on a port and writes the value to its first output argument. The port is specified via the second argument. The output field identifier is the third argument. The syntax of the }{\f2 getout}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 getout}{\f2\fs22  rmVal, thePort, RegMode  // read motor regulation mode
\par }{\b\f2\fs22 getout}{\f2\fs22  tlVal, thePort, TachoLimit  // read tachometer limit value
\par }{\b\f2\fs22 getout}{\f2\fs22  rcVal, thePort, RotationCount // read the rotation count
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_CompileTimeStatements}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Compile-time Statements}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  compile-time statements}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{2.7.14 Compile-time Statements
\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Compile-time statements and functions enable you to perform simple compiler operations at the time you compile your NBC programs.
\par The }{\f2 sizeof(arg)}{\f1  compiler function returns the size of the variable you pass into it. The syntax of the }{\f2 sizeof}{\f1  function is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 dseg}{\f2\fs22  segment
\par   }{\f2\fs22\lang1030\langfe1033\langnp1030 arg byte
\par   argsize byte 
\par }{\b\f2\fs22\lang1030\langfe1033\langnp1030 dseg}{\f2\fs22\lang1030\langfe1033\langnp1030  ends
\par }{\f2\fs22 // ...
\par }{\b\f2\fs22 set}{\f2\fs22  argsize, sizeof(arg) ; argsize == 1
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 valueof(arg)}{\f1  compiler function returns the value of the constant expression you pass into it. The syntax of the }{\f2 valueof}{\f1  function is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 set}{\f2\fs22  argval, valueof(4+3*2) ; argval == 10
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 isconst(arg)}{\f1  compiler function returns TRUE if the argument you pass into it is a constant and FALSE if it is not a constant. The syntax of the }{\f2 isconst}{\f1 
 function is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 set}{\f2\fs22  argval, isconst(4+3*2) ; argval == TRUE
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 compchk}{\f1 
 compiler statement takes a comparison constant as its first argument. The second and third arguments must be constants or constant expressions that can be evaluated by the compiler during program compilation. It
 reports a compiler error if the comparison expression does not evaluate to TRUE. Valid comparison constants are listed in }{\field\fldedit{\*\fldinst {\f1  REF _Ref180390481 \\h }{\f1 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0052006500660031003800300033003900300034003800310000000000000100}}}{\fldrslt {\f1 Table }{\f1\lang1024\langfe1024\noproof 6}}}{\f1 . The syntax of the }{\f2 compchk}{\f1 
 statement is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 compchk}{\f2\fs22  EQ, }{\b\f2\fs22 sizeof}{\f2\fs22 (arg3), 2
\par 
\par }\pard \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 The }{\f2 compif}{\f1 , }{\f2 compelse}{\f1 , and }{\f2 compend}{\f1 
 compiler statements work together to create a compile-time if-else statement that enables you to control whether or not sections of code should be included in the compiler output. The }{\f2 compif}{\f1  statement takes a comparison constant as its fir
st argument. The second and third arguments must be constants or constant expressions that can be evaluated by the compiler during program compilation. If the comparison expression is true then code immediate following the statement will be included in th
e executable. The compiler if statement ends when the compiler finds the next }{\f2 compend}{\f1  statement. To optionally provide an else clause use the }{\f2 compelse}{\f1  statement between the }{\f2 compif}{\f1  and }{\f2 compend}{\f1 
 statements. Valid comparison constants are listed in }{\field\fldedit{\*\fldinst {\f1  REF _Ref180390481 \\h }{\f1 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0052006500660031003800300033003900300034003800310000000000002900}
}}{\fldrslt {\f1 Table }{\f1\lang1024\langfe1024\noproof 6}}}{\f1 . The syntax of the }{\f2 compif}{\f1  , }{\f2 compelse}{\f1 , and }{\f2 compend}{\f1  statements is shown below.
\par }\pard \ql \li720\ri0\widctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f2\fs22 compif}{\f2\fs22  EQ, }{\b\f2\fs22 sizeof}{\f2\fs22 (arg3), 2
\par   // compile this if sizeof(arg3) == 2
\par }{\b\f2\fs22 compelse
\par }{\f2\fs22   // compile this if sizeof(arg3) != 2
\par }{\b\f2\fs22 compend
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_API}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  The NBC API}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  api}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3 The NBC API
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NBC AP
I defines a set of constants and macros that provide access to various capabilities of the NXT such as sensors, outputs, and communication. The API consists of macro functions and constants. A function is something that can be called as a statement. Typic
ally it takes some action or configures some parameter. Constants are symbolic names for values that have special meanings for the target. Often, a set of constants will be used in conjunction with a function.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {{\*\bkmkstart _Toc179361847}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_TimingFunctions}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Timing Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  timing functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.1.1 Timing Functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Wait(time)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Make a task sleep for specified amount of time (in 1000ths of a second). The time argument may be an expression or a constant:
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Wait(1000) // wait 1 second
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetFirstTick(out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return an unsigned 32-bit value, which is the system timing value 
(called a "tick") in milliseconds at the time that the program began running.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetFirstTick(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetSleepTime(out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the number of minutes that the NXT will remain on before it automatically shuts down.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetSleepTime(sleepy)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetSleepTimer(out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the number of minutes left in the countdown to zero from the original SleepTime value. When the SleepTimer value reaches zero the NXT will shutdown.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetSleepTimer(stime)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ResetSleepTimer\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Reset the system sleep timer back
 to the SleepTime value. Executing this function periodically can keep the NXT from shutting down while a program is running.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ResetSleepTimer
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSleepTimeout(minutes)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the NXT sleep timeout value to the specified number of minutes.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSleepTimeout(8)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSleepTimer(minutes)\tab Function
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSleepTimer(3)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {{\*\bkmkstart _Toc179361851}{\*\bkmkend _Toc179361847}\page }{\cs16\super #{\footnote 
\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_NumericFunctions}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Numeric Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  numeric functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{\cs43 3.1.2 Numeric Functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Random(out result, Max)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return an unsigned 16-bit random number between 0 and n (exclusive). Max can be a constant or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Random(x, 10) // return a value of 0..9
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SignedRandom(out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return a signed 16-bit random number.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SignedRandom(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Sqrt(x, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the square root of the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Sqrt(x, x) // x = sqrt(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Sin(degrees, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the sine of the s
pecified degrees value. The result is 100 times the sine value (-100..100).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {\lang1024\langfe1024\langnp3082 
Sin(theta, x) // x = sin(theta)*100
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Cos(degrees, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the cosine of the specified degrees value. The result is 100 times the cosine value (-100..100).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {\lang1024\langfe1024\langnp3082 Cos(y, x) // x = cos(y)*100

\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Asin(value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the inverse sine of the specified value (-100..100). The result is degrees (-90..90).

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Asin(80, deg) // deg = asin(0.80)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Acos(value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the inverse cosine of the specified value (-100..100). The result is degrees (0..180).

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Acos(0, deg) // deg = acos(0.00)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 bcd2dec(bcdValue, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the decimal equivalent of the binary coded decimal value provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {bcd2dec(0x3a, dec)
\par }\pard\plain \ql \li720\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {{\*\bkmkend _Toc179361851}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_SystemFunctions}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  System Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  system functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.1.3 Low-level System Functions

\par }\pard\plain \ql \li0\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
There are several standard structures that are defined by the NBC API for use with calls to low-level system functions defined within the NXT firmware. These structures are the means for passing values into the system functions and for returning values fr
om the system functions. In order to call a system function you will need to declare a variable of the required system function structure type, set the structure members as needed by the system function, call the function, and then read the results, if de
sired.
\par Many of these system functions are wrapped into higher level NBC API functions so that the details are hidden from view. Using these low-level API calls you can improve the speed of your programs a little.
\par If you install the NBC/NBC enhanced standard
 NXT firmware on your NXT all the screen drawing system function also supports clearing pixels in addition to setting them. To switch from setting pixels to clearing pixels just specify the DRAW_OPT_CLEAR_PIXELS value (0x0004) in the Options member of the
 
structures. This value can be ORed together with the DRAW_OPT_CLEAR_WHOLE_SCREEN value (0x0001) if desired. Also, some of the system functions and their associated structures are only supported by the NBC/NBC enhanced standard NXT firmware.  These functio
ns are marked with (+) to indicate this additional requirement.
\par The first two structures define types are used within several other structures required by the screen drawing system functions.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TLocation struct\line   X sword\line   Y sword\line 
TLocation ends
\par TSize struct\line   Width sword\line   Height sword\line TSize struct
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall DrawText, args\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you draw text on the NXT LCD given the parameters you pass in via the TDrawText structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TDrawText struct\line   Result sbyte\line 
  Location TLocation\line   Text byte[]\line   Options dword\line TDrawText ends
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   dtArgs TDrawText\line dseg ends\line 
set dtArgs.Location.X, 0\line set dtArgs.Location.Y, LCD_LINE1\line mov dtArgs.Text, 'Please Work'\line set dtArgs.Options, 0x01 // clear before drawing\line syscall DrawText, dtArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall DrawPoint, args\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you draw a pixel on the NXT LCD given the parameters yo
u pass in via the TDrawPoint structure.  The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TDrawPoint struct\line   Result sbyte\line 
  Location TLocation\line   Options dword\line TDrawPoint ends
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call the function, pass
ing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   dpArgs TDrawPoint\line dseg ends\line 
set dpArgs.Location.X, 0\line set dpArgs.Location.Y, 20\line set dpArgs.Options, 0x04 // clear this pixel\line syscall DrawPoint, dpArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall DrawLine, args\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function 
lets you draw a line on the NXT LCD given the parameters you pass in via the TDrawLine structure.  The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TDrawLine struct\line   Result sbyte\line 
  StartLoc TLocation\line   EndLoc TLocation\line   Options dword\line TDrawLine ends
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare
 a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   dlArgs TDrawLine\line dseg ends\line 
set dlArgs.StartLoc.X, 20\line set dlArgs.StartLoc.Y, 20\line set dlArgs.EndLoc.X, 60\line set dlArgs.EndLoc.Y, 60\line set dlArgs.Options, 0x01 // clear before drawing\line syscall DrawLine, dlArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall DrawCircle, args\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you draw a circle on the NXT LCD given the parameters you pass in via the TDrawCircle structure.  The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TDrawCircle struct\line   Result sbyte\line 
  Center TLocation\line   Size byte\line   Options dword\line TDrawCircle ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   dcArgs TDrawCircle\line dseg ends\line 
set dcArgs.Center.X, 20\line set dcArgs.Center.Y, 20\line set dcArgs.Size, 10 // radius\line set dcArgs.Options, 0x01 // clear before drawing\line syscall DrawCircle, dcArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall DrawRect, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you draw a recta
ngle on the NXT LCD given the parameters you pass in via the TDrawRect structure.  The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TDrawRect struct\line   Result sbyte\line 
  Location TLocation\line   Size TSize\line   Options dword\line TDrawRect ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this ty
pe, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   drArgs TDrawRect\line dseg ends\line 
set drArgs.Location.X, 20\line set drArgs.Location.Y, 20\line set drArgs.Size.Width, 20\line set drArgs.Size.Height, 10\line set drArgs.Options, 0x00 // do not clear before drawing\line syscall DrawRect, drArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall DrawGraphic, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you draw a graphic image (RIC file) on the NXT LCD given the parameters you pass in via the TDrawGraphic structure.  The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TDrawGraphic struct\line   Result sbyte\line 
  Location TLocation\line   Filename byte[]\line   Variables sword[]\line   Options dword\line TDrawGraphic ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call the function, passing in your va
riable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   dgArgs TDrawGraphic\line dseg ends\line 
set dgArgs.Location.X, 20\line set dgArgs.Location.Y, 20\line mov dgArgs.Filename, 'image.ric'\line arrinit dgArgs.Variables, 0, 10 // 10 zeros\line replace dgArgs.Variables, dgArgs.Variables, 0, 12\line replace dgArgs.Variables, dgArgs.Variables, 1, 14
\line set dgArgs.Options, 0x00 // do not clear before drawing\line syscall DrawGraphic, dgArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall SetScreenMode, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you set the screen mode of the NXT LCD given the parameters you pas
s in via the TSetScreenMode structure. The standard NXT firmware only supports setting the ScreenMode to }{\cs19\f6\fs22 SCREEN_MODE_RESTORE}{\f1 
, which has a value of 0x00. If you install the NBC/NBC enhanced standard NXT firmware this system function also supports setting the ScreenMode to }{\cs19\f6\fs22 SCREEN_MODE_CLEAR}{\f1 
, which has a value of 0x01. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TSetScreenMode struct\line   Result sbyte;\line 
  ScreenMode dword;\line TSetScreenMode ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call the f
unction, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   ssmArgs TSetScreenMode\line dseg ends
\line set ssmArgs.ScreenMode, 0x00 // restore default NXT screen\line syscall SetScreenMode, ssmArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall SoundPlayFile, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you 
play a sound file given the parameters you pass in via the TSoundPlayFile structure. The sound file can either be an RSO file containing PCM or compressed ADPCM samples or it can be an NXT melody (RMD) file containing frequency and duration values. The st
ructure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TSoundPlayFile struct\line   Result sbyte\line 
  Filename byte[]\line   Loop byte\line   SoundLevel byte\line TSoundPlayFile ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call the function, passing in your variable of this 
structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   spfArgs TSoundPlayFile\line dseg ends
\line mov spfArgs.Filename, 'hello.rso'\line set spfArgs.Loop, FALSE\line set spfArgs.SoundLevel, 3\line syscall SoundPlayFile, spfArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall SoundPlayTone, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you play a tone given
 the parameters you pass in via the TSoundPlayTone structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TSoundPlayTone struct\line   Result sbyte\line 
  Frequency word\line   Duration word\line   Loop byte\line   SoundLevel byte\line TSoundPlayTone ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this 
type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   sptArgs TSoundPlayTone\line dseg ends
\line set sptArgs.Frequency, 440\line set sptArgs.Duration, 1000 // 1 second\line set sptArgs.Loop, false\line set sptArgs.SoundLevel, 3\line syscall SoundPlayTone, sptArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall SoundGetState, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you retrieve information about the sound module state via the TSoundGetState structure. Constants for sound state are }{\cs19\f6\fs22 SOUND_STATE_IDLE}{\f1 , }{\cs19\f6\fs22 SOUND_STATE_FILE}{\f1 , }{\cs19\f6\fs22 SOUND_STATE_TONE}{\f1 
, and }{\cs19\f6\fs22 SOUND_STATE_STOP}{\f1 . Constants for sound flags are }{\cs19\f6\fs22 SOUND_FLAGS_IDLE}{\f1 , }{\cs19\f6\fs22 SOUND_FLAGS_UPDATE}{\f1 , and }{\cs19\f6\fs22 SOUND_FLAGS_RUNNING}{\f1 . The structure type declaration is shown below.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TSoundGetStateType struct\line   State byte\line 
  Flags byte\line TSoundGetStateType ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare
 a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   sgsArgs TSoundGetState\line dseg ends
\line syscall SoundGetState, sgsArgs\line brcmp NEQ, lblEndIf, sgsArgs.State, SOUND_STATE_IDLE\line   // do stuff\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall SoundSetState, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you set sound module state settings via the TSoundSetState structure. Constants for sound state are }{\cs19\f6\fs22 SOUND_STATE_IDLE}{\f1 , }{\cs19\f6\fs22 SOUND_STATE_FILE}{\f1 , }{\cs19\f6\fs22 SOUND_STATE_TONE}{\f1 , and }{
\cs19\f6\fs22 SOUND_STATE_STOP}{\f1 . Constants for sound flags are }{\cs19\f6\fs22 SOUND_FLAGS_IDLE}{\f1 , }{\cs19\f6\fs22 SOUND_FLAGS_UPDATE}{\f1 , and }{\cs19\f6\fs22 SOUND_FLAGS_RUNNING}{\f1 . The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TSoundSetState struct\line   Result byte\line   State byte
\line   Flags byte\line TSoundSetState ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set i
ts members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   sssArgs TSoundSetState\line dseg ends
\line set sssArgs.State, SOUND_STATE_STOP\line syscall SoundSetState, sssArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall ReadButton, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets
 you read button state information via the TReadButton structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TReadButton struct\line   Result sbyte\line   Index byte
\line   Pressed byte\line   Count byte\line   Reset byte // reset count after reading?\line TReadButton ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare 
a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   rbArgs TReadButton\line dseg ends\line 
set rbArgs.Index, BTNRIGHT\line syscall ReadButton, rbArgs\line brtst EQ, lblEndIf, rbArgs.Pressed\line   // do stuff\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall RandomNumber, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you obtain a random number via the TRandomNumber structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TRandomNumber struct\line   Result sword\line 
TRandomNumber ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type and then call the function, passing in your variable of this structure type.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   rnArgs TRandomNumber\line 
  myRandomNumber sword\line dseg ends\line syscall RandomNumber, rnArgs\line mov myRandomValue, rnArgs.Result
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall GetStartTick, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you obtain the tick value at the time your program began executing via the TGetStartTick structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TGetStartTick struct\line   Result dword\line 
TGetStartTick ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type and then call the function, passing in your variable of this structure type.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   gstArgs TGetStartTick\line 
  myStart dword\line dseg ends\line syscall GetStartTick, gstArgs\line mov myStart, gstArgs.Result
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall KeepAlive, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you rese
t the sleep timer via the TKeepAlive structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TKeepAlive struct\line   Result dword\line TKeepAlive ends

\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type and then call the function, passing in your variable of this structure type.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   kaArgs TKeepAlive\line dseg ends\line 
syscall KeepAlive, kaArgs // reset sleep timer
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileOpenWrite, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you create a file that you can write to using the values specified via the TFileOpen structure. The structure typ
e declaration is shown below. Use the FileHandle return value for subsequent file write operations. The desired maximum file capacity in bytes is specified via the Length member.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileOpen struct\line   Result dword\line   FileHandle byte
\line   Filename byte[]\line   Length dword\line TFileOpen ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   foArgs TFileOpen\line dseg ends\line 
mov foArgs.Filename, 'myfile.txt'\line set foArgs.Length, 256 // create with capacity for 256 bytes\line syscall FileOpenWrite, foArgs // create the file\line brcmp NEQ, lblEndIf, foArgs.Result, NO_ERR\line  // write to the file using FileHandle\line 
lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileOpenAppend, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you open an existing file tha
t you can write to using the values specified via the TFileOpen structure. The structure type declaration is shown below. Use the FileHandle return value for subsequent file write operations.  The available length remaining in the file is returned via the
 Length member.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileOpen struct\line   Result dword\line   FileHandle byte
\line   Filename byte[]\line   Length dword\line TFileOpen ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   foArgs TFileOpen\line dseg ends\line 
mov foArgs.Filename, 'myfile.txt'\line syscall FileOpenAppend, foArgs // open the file\line brcmp NEQ, lblEndIf, foArgs.Result, NO_ERR\line   // write to the file using FileHandle\line   // up to the remaining available length in Length\line lblEndIf:

\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileOpenRead, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you open an existing file for reading using the values specified via the TFileOpen structure. The structure type declaration is shown below. Use the FileHandle return value for subsequent file read operat
ions.  The number of bytes that can be read from the file is returned via the Length member.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileOpen struct\line   Result dword\line   FileHandle byte
\line   Filename byte[]\line   Length dword\line TFileOpen ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call t
he function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   foArgs TFileOpen\line dseg ends\line 
mov foArgs.Filename, 'myfile.txt'\line syscall FileOpenRead, foArgs // open the file for reading\line brcmp NEQ, lblEndIf, foArgs.Result, NO_ERR\line   // read data from the file using FileHandle\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileRead, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you read from a file using the values specified via the TFileReadWrite structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileReadWrite struct\line   Result dword\line 
  FileHandle byte\line   Buffer byte[]\line   Length dword\line TFileReadWrite
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   frArgs TFileReadWrite\line dseg ends
\line mov frArgs.FileHandle, foArgs.FileHandle\line set frArgs.Length, 12 // number of bytes to read\line syscall FileRead, frArgs\line brcmp NEQ, lblEndIf, frArgs.Result, NO_ERR\line   TextOut(0, LCD_LINE1, frArgs.Buffer)\line 
  // show how many bytes were actually read\line   NumOut(0, LCD_LINE2, frArgs.Length)\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileWrite,  args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you write to a file using the values specified via the TFileReadWrite structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileReadWrite struct\line   Result dword\line 
  FileHandle byte\line   Buffer byte[]\line   Length dword\line TFileReadWrite
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   fwArgs TFileReadWrite\line dseg ends
\line mov fwArgs.FileHandle,  foArgs.FileHandle\line mov fwArgs.Buffer, 'data to write'\line syscall FileWrite, fwArgs\line brcmp NEQ, lblEndIf, fwArgs.Result, NO_ERR\line   // display number of bytes written\line   NumOut(0, LCD_LINE1, fwArgs.Length)
\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileClose, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you close a fi
le using the values specified via the TFileClose structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileClose struct\line   Result dword\line   FileHandle byte
\line TFileClose ends 
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call the function, pas
sing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   fcArgs TFileClose\line dseg ends\line 
mov fcArgs.FileHandle, foArgs.FileHandle\line syscall FileClose, fcArgs
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileResolveHandle, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you resolve the handle of a file using t
he values specified via the TFileResolveHandle structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileResolveHandle struct\line   Result dword\line 
  FileHandle byte\line   WriteHandle byte\line   Filename byte[]\line TFileResolveHandle ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type
, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   frhArgs TFileResolveHandle\line 
dseg ends\line mov frhArgs.Filename, 'myfile.txt'\line syscall FileResolveHandle, frhArgs\line brcmp NEQ, lblEndIfLdrSuccess, frhArgs.Result, LDR_SUCCESS\line   // use the FileHandle as needed\line   brtst EQ, lblElseIfWriteHandle, frhArgs.WriteHandle
\line     // file is open for writing\line     jmp lblEndIfWriteHandle\line   lblElseIfWriteHandle:\line     // file is open for reading\line   lblEndIfWriteHandle:\line lblEndIfLdrSuccess:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileRename, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you rename a file using the values specified via the TFileRename structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileRename struct\line   Result dword\line 
  OldFilename byte[]\line   NewFilename byte[]\line TFileRename ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {{\*\bkmkstart OLE_LINK1}{\*\bkmkstart OLE_LINK2}dseg segment
\line   frArgs TFileRename\line dseg ends\line {\*\bkmkend OLE_LINK1}{\*\bkmkend OLE_LINK2}mov frArgs.OldFilename, 'myfile.txt'\line mov frArgs.NewFilename, 'myfile2.txt'\line syscall FileRename, frArgs\line 
brcmp NEQ, lblEndIfLdrSuccess, frhArgs.Result, LDR_SUCCESS\line   // do something\line lblEndIfLdrSuccess:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall FileDelete, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you delete a file using the values specified via the TFileDelete
 structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TFileDelete struct\line   Result dword\line 
  Filename byte[]\line TFileDelete ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   fdArgs TFileDelete\line dseg ends\line 
mov fdArgs.Filename, 'myfile.txt'\line syscall FileDelete, fdArgs // delete the file
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall CommLSWrite, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you write to an I2C (Lowspeed) sensor using the values specified via the TCommL
SWrite structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TCommLSWrite struct\line   Result sbyte\line   Port byte
\line   Buffer byte[]\line   ReturnLen byte\line TCommLSWrite ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call the function, passing in your
 variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TCommLSWrite\line dseg ends\line 
set args.Port, IN_1\line mov args.Buffer, myBuf\line set args.ReturnLen, 8\line syscall CommLSWrite, args\line // check Result for error status
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall CommLSCheckStatus, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function 
lets you check the status of an I2C (Lowspeed) sensor transaction using the values specified via the TCommLSCheckStatus structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TCommLSCheckStatus struct\line   Result sbyte\line 
  Port byte\line   BytesReady byte\line TCommLSCheckStatus ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TCommLSCheckStatus\line dseg ends
\line set args.Port, IN_1\line syscall CommLSCheckStatus, args\line // is the status (Result) IDLE?\line brcmp NEQ, lblEndIf, args.Result, LOWSPEED_IDLE\line   // proceed\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall CommLSRead, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you read from an I2C (Lowspeed) sensor using the values specified via the TCommLSRead structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TCommLSRead struct\line   Result sbyte\line   Port byte
\line   Buffer byte[]\line   BufferLen byte\line TCommLSRead ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TCommLSRead\line dseg ends\line 
set args.Port, IN_1\line mov args.Buffer, myBuf\line set args.BufferLen, 8\line syscall CommLSRead, args\line // check Result for error status & use Buffer contents
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall MessageWrite, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you write a me
ssage to a queue (aka mailbox) using the values specified via the TMessageWrite structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TMessageWrite struct\line   Result sbyte\line   QueueID byte
\line   Message byte[]\line TMessageWrite ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type
, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TMessageWrite\line dseg ends\line 
set args.QueueID, MAILBOX1 // 0\line mov args.Message, 'testing'\line syscall MessageWrite, args\line // check Result for error status
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall MessageRead, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you read a message from a queue (aka mailbox) using the values specified via the TMessageRead structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TMessageRead struct\line   Result sbyte\line   QueueID byte
\line   Remove byte\line   Message byte[]\line TMessageRead ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TMessageRead\line dseg ends\line 
set args.QueueID, MAILBOX1 // 0\line set args.Remove, TRUE\line syscall MessageRead, args\line brcmp NEQ, lblEndIf, args.Result, NO_ERR\line   TextOut(0, LCD_LINE1, args.Message)\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall CommBTWrite, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you write to a Bluetooth connection using the values specified via
 the TCommBTWrite structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TCommBTWrite struct\line   Result sbyte\line 
  Connection byte\line   Buffer byte[]\line TCommBTWrite ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call the function, passing in your
 variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TCommBTWrite\line dseg ends\line 
set args.Connection, 1\line mov args.Buffer, myData\line syscall CommBTWrite, args
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall CommBTCheckStatus, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you check the status of a Bluetooth connection
 using the values specified via the TCommBTCheckStatus structure. The structure type declaration is shown below.  Possible values for Result include }{\cs19\f6\fs22 ERR_INVALID_PORT}{\f1 , }{\cs19\f6\fs22 STAT_COMM_PENDING}{\f1 , }{\cs19\f6\fs22 
ERR_COMM_CHAN_NOT_READY}{\f1 , and }{\cs19\f6\fs22 LDR_SUCCESS}{\f1  (0).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TCommBTCheckStatus struct\line   Result sbyte\line 
  Connection byte\line   Buffer byte[]\line TCommBTCheckStatus ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TCommBTCommBTCheckStatus\line 
dseg ends\line set args.Connection, 1\line syscall CommBTCheckStatus, args\line brcmp NEQ, lblEndIf, args.Result, LDR_SUCCESS\line   // do something\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall IOMapRead, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you read data from a firmware module's IOMap using the values specified vi
a the TIOMapRead structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TIOMapRead struct\line   Result sbyte\line 
  ModuleName byte[]\line   Offset word\line   Count word\line   Buffer byte[]\line TIOMapRead ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a variable of this type, set its members, and then call the f
unction, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TIOMapRead\line dseg ends\line 
mov args.ModuleName, CommandModuleName\line set args.Offset, CommandOffsetTick\line set args.Count, 4 // this value happens to be 4 bytes long\line syscall IOMapRead, args\line brcmp NEQ, lblEndIf, args.Result, NO_ERR\line   // do something with the data
\line lblEndIf:
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall IOMapWrite, args\tab Function
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you write data to a firmware module's IOMap using the values specified via the TIOMapWrite structure. The structure type declaration is shown below.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TIOMapWrite struct\line   Result sbyte\line 
  ModuleName byte[]\line   Offset word\line   Buffer byte[]\line TIOMapWrite ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TIOMapWrite\line dseg ends\line 
mov args.ModuleName, SoundModuleName\line set args.Offset, SoundOffsetSampleRate\line mov args.Buffer, theData\line syscall IOMapWrite, args
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall IOMapReadByID, args\tab Function (+)
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This function lets you read data from a firmwa
re module's IOMap using the values specified via the TIOMapReadByID structure. The structure type declaration is shown below. This function can be as much as three times faster than using syscall IOMapRead since it does not have to do a string lookup usin
g the ModuleName.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TIOMapReadByID struct\line   Result sbyte\line 
  ModuleID dword\line   Offset word\line   Count word\line   Buffer byte[]\line TIOMapReadByID ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TIOMapReadByID\line dseg ends\line 
mov args.ModuleID, CommandModuleID\line set args.Offset, CommandOffsetTick\line set args.Count, 4 // this value happens to be 4 bytes long\line syscall IOMapReadByID, args\line brcmp NEQ, lblEndIf, args.Result, NO_ERR\line   // do something with the data
\line lblEndIf: 
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall IOMapWriteByID, args\tab Function (+)
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you write data to a firmware module's IOMap using the values specified via the TIOMapWriteByID structure. The structure type declaration is shown below. This fu
nction can be as much as three times faster than using SysIOMapWrite since it does not have to do a string lookup using the ModuleName.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TIOMapWriteByID struct\line   Result sbyte\line 
  ModuleID dword\line   Offset word\line   Buffer byte[]\line TIOMapWriteByID ends
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Declare a vari
able of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TIOMapWriteByID\line dseg ends
\line mov args.ModuleID, SoundModuleID\line set args.Offset, SoundOffsetSampleRate\line mov args.Buffer, theData\line syscall IOMapWriteByID, args
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall DisplayExecuteFunction, args\tab Function (+)
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you directly execute the Display module's primary drawing function using the values specified via the TDisplayExecuteFunction structure. The structure type de
claration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TDisplayExecuteFunction struct\line   Status byte\line 
  Cmd byte\line   On byte\line   X1 byte\line   Y1 byte\line   X2 byte\line   Y2 byte\line TDisplayExecuteFunction ends
\par }\pard\plain \ql \li360\ri0\widctlpar\tx3348\tx5856\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Cmd\tab Meaning\tab Expected parameters
\par DISPLAY_ERASE_ALL\tab erase entire screen\tab ()
\par DISPLAY_PIXEL\tab set pixel (on/off)\tab (true/false,X1,Y1,x,x)
\par DISPLAY_HORIZONTAL_LINE\tab draw horizontal line\tab (true/false,X1,Y1,X2,x)
\par DISPLAY_VERTICAL_LINE\tab draw vertical line\tab (true/false,X1,Y1,x,Y2)
\par DISPLAY_CHAR\tab draw char (actual font)\tab (true/false,X1,Y1,Char,x)
\par DISPLAY_ERASE_LINE\tab erase a single line\tab (x,LINE,x,x,x)
\par DISPLAY_FILL_REGION\tab fill screen region\tab (true/false,X1,Y1,X2,Y2)
\par DISPLAY_FILLED_FRAME\tab draw a frame (on / off)\tab (true/false,X1,Y1,X2,Y2)
\par }\pard \ql \li360\ri0\sb120\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 {\f1 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TDisplayExecuteFunction\line 
dseg ends\line set args.Cmd, DISPLAY_ERASE_ALL\line syscall DisplayExecuteFunction, args
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall CommExecuteFunction, args\tab Function (+)
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you directly execute the Comm module's primary function using the values specified via the TCommExecuteFunction structure. The structure type 
declaration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TCommExecuteFunction struct\line   Result word\line 
  Cmd byte\line   Param1 byte\line   Param2 byte\line   Param3 byte\line   Name byte[]\line   RetVal word\line TCommExecuteFunction ends
\par }\pard\plain \ql \li180\ri0\widctlpar\tx2520\tx5940\faauto\adjustright\rin0\lin180\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Cmd\tab Meaning\tab (Param1,Param2,Param3,Name)
\par INTF_SENDFILE\tab Send a file over a Bluetooth connection\tab (Connection,x,x,Filename)
\par INTF_SEARCH\tab Search for Bluetooth devices\tab (x,x,x,x)
\par INTF_STOPSEARCH\tab Stop searching for Bluetooth devices\tab (x,x,x,x)
\par INTF_CONNECT\tab Connect to a Bluetooth device\tab (DeviceIndex,Connection,x,x)
\par INTF_DISCONNECT\tab Disconnect a Bluetooth device\tab (Connection,x,x,x)
\par INTF_DISCONNECTALL\tab Disconnect all Bluetooth devices\tab (x,x,x,x)
\par INTF_REMOVEDEVICE\tab Remove device from My Contacts\tab (DeviceIndex,x,x,x)
\par INTF_VISIBILITY\tab Set Bluetooth visibility\tab (true/false,x,x,x)
\par INTF_SETCMDMODE\tab Set command mode\tab (x,x,x,x)
\par INTF_OPENSTREAM\tab Open a stream\tab (x,Connection,x,x)
\par INTF_SENDDATA\tab Send data\tab (Length, Connection, WaitForIt, Buffer)
\par INTF_FACTORYRESET\tab Bluetooth factory reset\tab (x,x,x,x)
\par INTF_BTON\tab Turn Bluetooth on\tab (x,x,x,x)
\par INTF_BTOFF\tab Turn Bluetooth off\tab (x,x,x,x)
\par INTF_SETBTNAME\tab Set Bluetooth name\tab (x,x,x,x)
\par INTF_EXTREAD\tab Handle external? read\tab (x,x,x,x)
\par INTF_PINREQ\tab Handle Blueooth PIN request\tab (x,x,x,x)
\par INTF_CONNECTREQ\tab Handle Bluetooth connect request\tab (x,x,x,x)
\par }\pard \ql \li360\ri0\sb120\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 {\f1 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TCommExecuteFunction\line dseg ends
\line set args.Cmd, INTF_BTOFF\line syscall CommExecuteFunction, args
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 syscall LoaderExecuteFunction, args\tab Function (+)
\par }\pard\plain \ql \li360\ri0\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This function lets you directly execute the Loader module's primary function using the values specified via the TLoaderExecuteFunction s
tructure. The structure type declaration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TLoaderExecuteFunction struct\line   unsigned int Result;
\line   byte Cmd;\line   string Filename;\line   byte Buffer[];\line   unsigned long Length;\line TLoaderExecuteFunction ends
\par }\pard\plain \ql \li-432\ri0\widctlpar\tx3358\tx6228\faauto\adjustright\rin0\lin-432\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Cmd\tab Meaning\tab Expected Parameters
\par LDR_CMD_OPENREAD\tab Open a file for reading\tab (Filename, Length)
\par LDR_CMD_OPENWRITE\tab Creat a file\tab (Filename, Length)
\par LDR_CMD_READ\tab Read from a file\tab (Filename, Buffer, Length)
\par LDR_CMD_WRITE\tab Write to a file\tab (Filename, Buffer, Length)
\par LDR_CMD_CLOSE\tab Close a file\tab (Filename)
\par }{\f1\lang1040\langfe1033\langnp1040 LDR_CMD_DELETE\tab Delete a file\tab (Filename)
\par }{\f1 LDR_CMD_FINDFIRST\tab Start iterating files\tab (Filename, Buffer, Length)
\par LDR_CMD_FINDNEXT\tab Continue iterating files\tab (Filename, Buffer, Length)
\par LDR_CMD_OPENWRITELINEAR\tab Create a linear file\tab (Filename, Length)
\par LDR_CMD_OPENREADLINEAR\tab Read a linear file\tab (Filename, Buffer, Length)
\par LDR_CMD_OPENAPPENDDATA\tab Open a file for writing\tab (Filename, Length)
\par LDR_CMD_FINDFIRSTMODULE\tab Start iterating modules\tab (Filename, Buffer)
\par LDR_CMD_FINDNEXTMODULE\tab Continue iterating modules\tab (Buffer)
\par LDR_CMD_CLOSEMODHANDLE\tab Close module handle\tab ()
\par LDR_CMD_IOMAPREAD\tab Read IOMap data\tab (Filename, Buffer, Length)
\par LDR_CMD_IOMAPWRITE\tab Write IOMap data\tab (Filename, Buffer, Length)
\par LDR_CMD_DELETEUSERFLASH\tab Delete all files\tab ()
\par LDR_CMD_RENAMEFILE\tab Rename file\tab (Filename, Buffer, Length)
\par }\pard \ql \li360\ri0\sb120\sa120\widctlpar\faauto\adjustright\rin0\lin360\itap0 {\f1 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {dseg segment\line   args TLoaderExecuteFunction\line 
dseg ends\line set args.Cmd, LDR_CMD_DELETEUSERFLASH // delete user flash\line syscall LoaderExecuteFunction, args
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_InputModule}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Input Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  input module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.2 Input Module
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT input module encompasses all sensor inputs except for digital I2C (LowSpeed) sensors. 
\par }\pard \ql \li360\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin360\itap0 {\b\f1 Module Constants\tab Function
\par }\pard \ql \li360\ri0\widctlpar\faauto\adjustright\rin0\lin360\itap0 {\f1 InputModuleName\tab "Input.mod"
\par InputModuleID\tab 0x00030001
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 There are four sensors, which are internally numbered 0, 1, 2, and 3. This is potentially confusing since they are externally labeled on the NXT as senso
rs 1, 2, 3, and 4. To help mitigate this confusion, the sensor port names IN_1, IN_2, IN_3, and IN_4 have been defined. These sensor names may be used in any function that requires a sensor port as an argument.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_SensorTypes}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sensor Types}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  sensor types}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.2.1 Types and Modes
\par }\pard\plain \s18\ql \li0\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The sensor ports o
n the NXT are capable of interfacing to a variety of different sensors. It is up to the program to tell the NXT what kind of sensor is attached to each port. Calling SetSensorType configures a sensor's type. There are 12 sensor types, each corresponding t
o a specific LEGO RCX or NXT sensor. A thirteenth type (IN_TYPE_NO_SENSOR) is used to indicate that no sensor has been configured. 
\par In general, a program should configure the type to match the actual sensor. If a sensor port is configured as the wrong type, the NXT may not be able to read it accurately.
\par }\pard\plain \s23\ql \li0\ri0\widctlpar\tx2880\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 NBC Sensor Type\tab Meaning
\par }{\f1 IN_TYPE_NO_SENSOR\tab no sensor configured
\par IN_TYPE_SWITCH\tab NXT or RCX touch sensor
\par }{\f1\lang1040\langfe1033\langnp1040 IN_TYPE_TEMPERATURE\tab RCX temperature sensor
\par }{\f1 IN_TYPE_REFLECTION\tab RCX light sensor
\par IN_TYPE_ANGLE\tab RCX rotation sensor
\par IN_TYPE_LIGHT_ACTIVE\tab NXT light sensor with light
\par IN_TYPE_LIGHT_INACTIVE\tab NXT light sensor without light
\par IN_TYPE_SOUND_DB\tab NXT sound sensor with dB scaling
\par IN_TYPE_SOUND_DBA\tab NXT sound sensor with dBA scaling
\par IN_TYPE_CUSTOM\tab Custom sensor (unused)
\par IN_TYPE_LOWSPEED\tab I2C digital sensor
\par IN_TYPE_LOWSPEED_9V\tab I2C digital sensor (9V power)
\par IN_TYPE_HISPEED\tab Highspeed sensor (unused)
\par }\pard\plain \s25\ql \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Ref157568738}{\*\bkmkstart _Toc179792854}{\*\bkmkstart _Toc180913087}
Table }{\field{\*\fldinst {\f1  SEQ Table \\* ARABIC }}{\fldrslt {\f1\lang1024\langfe1024\noproof 10}}}{\f1 {\*\bkmkend _Ref157568738}. Sensor Type Constants{\*\bkmkend _Toc179792854}{\*\bkmkend _Toc180913087}
\par }\pard\plain \s18\ql \li0\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT allows a sensor to be configured in different modes. The sensor mode d
etermines how a sensor's raw value is processed. Some modes only make sense for certain types of sensors, for example IN_MODE_ANGLESTEP is useful only with rotation sensors. Call SetSensorMode to set the sensor mode. The possible modes are shown below.

\par }\pard\plain \s23\ql \li0\ri0\widctlpar\tx2880\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 NBC Sensor Mode\tab Meaning
\par }{\f1 IN_MODE_RAW\tab raw value from 0 to 1023
\par IN_MODE_BOOLEAN\tab boolean value (0 or 1)
\par IN_MODE_TRANSITIONCNT\tab counts number of boolean transitions
\par IN_MODE_PERIODCOUNTER\tab counts number of boolean periods
\par IN_MODE_PCTFULLSCALE\tab value from 0 to 100
\par }{\f1\lang1031\langfe1033\langnp1031 IN_MODE_FAHRENHEIT\tab degrees F
\par IN_MODE_CELSIUS\tab degrees C
\par }{\f1 IN_MODE_ANGLESTEP\tab rotation (16 ticks per revolution) 
\par }\pard\plain \s25\ql \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Ref157568796}{\*\bkmkstart _Toc179792855}{\*\bkmkstart _Toc180913088}
Table }{\field{\*\fldinst {\f1  SEQ Table \\* ARABIC }}{\fldrslt {\f1\lang1024\langfe1024\noproof 11}}}{\f1 {\*\bkmkend _Ref157568796}. Sensor Mode Constants{\*\bkmkend _Toc179792855}{\*\bkmkend _Toc180913088}
\par }\pard\plain \s18\ql \li0\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT provides a boolean conversion for all sensors - not just touch sensors. This boolean co
nversion is normally based on preset thresholds for the raw value. A "low" value (less than 460) is a boolean value of 1. A high value (greater than 562) is a boolean value of 0. This conversion can be modified: a slope value between 0 and 31 may be added
 
to a sensor's mode when calling SetSensorMode. If the sensor's value changes more than the slope value during a certain time (3ms), then the sensor's boolean state will change. This allows the boolean state to reflect rapid changes in the raw value. A rap
id increase will result in a boolean value of 0, a rapid decrease is a boolean value of 1.
\par Even when a sensor is configured for some other mode (i.e. IN_MODE_PCTFULLSCALE), the boolean conversion will still be carried out.
\par Each sensor has six fields that are used to define its state. The field constants are described in the following table.
\par }\pard\plain \s23\ql \li0\ri0\widctlpar\tx3240\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Sensor Field Constant\tab Meaning
\par }{\f1 Type\tab The sensor type (see }{\field{\*\fldinst {\f1  REF _Ref157568738 \\h }{\f1 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0052006500660031003500370035003600380037003300380000000000002800}}}{\fldrslt {\f1 Table }{
\f1\lang1024\langfe1024\noproof 10}}}{\f1 ).
\par InputMode\tab The sensor mode (see }{\field{\*\fldinst {\f1  REF _Ref157568796 \\h }{\f1 {\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0052006500660031003500370035003600380037003900360000000000000900}}}{\fldrslt {\f1 Table }{
\f1\lang1024\langfe1024\noproof 11}}}{\f1 ).
\par RawValue\tab The raw sensor value
\par NormalizedValue\tab The normalized sensor value
\par ScaledValue\tab The scaled sensor value
\par InvalidData\tab Invalidates the current sensor value
\par }\pard\plain \s25\ql \li0\ri0\sb120\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Ref157568847}{\*\bkmkstart _Toc179792857}{\*\bkmkstart _Toc180913089}
Table }{\field{\*\fldinst {\f1  SEQ Table \\* ARABIC }}{\fldrslt {\f1\lang1024\langfe1024\noproof 12}}}{\f1 {\*\bkmkend _Ref157568847}. Sensor Field Constants{\*\bkmkend _Toc179792857}{\*\bkmkend _Toc180913089}
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSensorType(port, const type)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set a se
nsor's type, which must be one of the predefined sensor type constants. The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ) or a variable.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSensorType(IN_1, IN_TYPE_SWITCH)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSensorMode(port, const mode)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set a sensor's 
mode, which should be one of the predefined sensor mode constants. A slope parameter for boolean conversion, if desired, may be added to the mode. The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{
\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ) or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSensorMode(IN_1, IN_MODE_RAW) // raw mode
\par SetSensorMode(IN_1, IN_MODE_RAW + 10) // slope 10
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSensorLight(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Configure the sensor on the specified port as a light sensor (active). The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ) or a variable.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSensorLight(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSensorSound(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Configure the sensor on the specified port as a sound sensor (dB scaling). The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ) or a variable.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSensorSound(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSensorTouch(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Configure the sensor on the specified port as a touch sensor. The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ) or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSensorTouch(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSensorLowspeed(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Configure the sensor
 on the specified port as an I2C digital sensor (9V powered). The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ) or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSensorLowspeed(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSensorUltrasonic(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Configure the sensor on the specified port 
as an I2C digital sensor (9V powered). The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ) or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSensorUltrasonic(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ClearSensor(const port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Clear the value of a sensor - only affects sensors that are config
ured to measure a cumulative quantity such as rotation or a pulse count. The port must be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ClearSensor(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ResetSensor(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Reset the value of a sensor. If the sensor type or mode has
 been modified then the sensor should be reset in order to ensure that values read from the sensor are valid. The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{
\cs19\f6\fs22 IN_4}{\f1 ) or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ResetSensor(x) // x = IN_1
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetInCustomZeroOffset(const p, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Sets the custom sensor zero offset value of a sensor. The port must be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetInCustomZeroOffset(IN_1, 12)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetInCustomPercentFullScale(const p, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Sets the custom se
nsor percent full scale value of a sensor. The port must be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetInCustomPercentFullScale(IN_1, 100)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetInCustomActiveStatus(const p, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Sets the custom sensor active status value of 
a sensor. The port must be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetInCustomActiveStatus(IN_1, true)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetInDigiPinsDirection(const p, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Sets the digital pins direction value of a sensor. The port must be specified using
 a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ). A value of 1 sets the direction to output. A value of 0 sets the direction to input.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetInDigiPinsDirection(IN_1, 1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetInDigiPinsStatus(const p, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Sets the digital pins status value of a sensor.
 The port must be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetInDigiPinsStatus(IN_1, false)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetInDigiPinsOutputLevel(const p, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Sets the digital pins output level value of a sensor. The port must be specified using a cons
tant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetInDigiPinsOutputLevel(IN_1, 100)
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_SensorInfo}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sensor Information}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  sensor information}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.2.2 Sensor Information
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
There are a number of values that can be inspected for each sensor. For all of these values the sensor must be specified by a constant port value (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{
\cs19\f6\fs22 IN_4}{\f1 ) unless otherwise specified.
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensor(n, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the processed sensor reading for a sensor on port n, where n is 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensor(IN_1, x) // read sensor 1
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorUS(n, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the processed sensor reading for an ultrasonic sensor on port n, where n is 0, 1, 2, or 3 (or a sensor port name constant). Since an ultrasonic sensor
 is an I2C digital sensor its value cannot be read using the standard ReadSensor(n, result) value. A variable whose value is the desired sensor port may also be used.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorUS(IN_4, dist) // read sensor 4
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetInSensorBoolean(const n, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the boolean value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). Boolean conversion is either done based on preset cutoffs, or a slope parameter specified by calling }{\cs19\f6\fs22 SetSensorMode}{\f1 .
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetInSensorBoolean(IN_1, bvalue)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetInCustomZeroOffset(const p, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the custom sensor zero offset value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetInCustomZeroOffset(IN_1, zoValue)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetInCustomPercentFullScale(const p, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the custom sensor percent full scale value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetInCustomPercentFullScale(IN_1, value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetInCustomActiveStatus(const p, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return
 the custom sensor active status value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetInCustomActiveStatus(IN_1, value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetInDigiPinsDirection(const p, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the digital pins direction value of 
a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetInDigiPinsDirection(IN_1, value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetInDigiPinsStatus(const p, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the digital pins status value of a sensor on port p, which must be 0, 1, 2, or 3 (
or a sensor port name constant).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetInDigiPinsStatus(IN_1, value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetInDigiPinsOutputLevel(const p, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the digital pins output level value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetInDigiPinsOutputLevel(IN_1, value)
\par }\pard\plain \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 \page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_InputIOMapOffsets}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Input Module IOMap Offsets}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  input module iomap offsets}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.2.3 IOMAP Offsets
\par }\pard\plain \ql \li720\ri0\widctlpar\tx4320\tx6480\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Input Module Offsets\tab Value\tab Size
\par }{\f1 InputOffsetCustomZeroOffset(p)\tab (((p)*20)+0)\tab 2
\par InputOffsetADRaw(p)\tab (((p)*20)+2)\tab 2
\par InputOffsetSensorRaw(p)\tab (((p)*20)+4)\tab 2
\par InputOffsetSensorValue(p)\tab (((p)*20)+6)\tab 2
\par InputOffsetSensorType(p)\tab (((p)*20)+8)\tab 1
\par InputOffsetSensorMode(p)\tab (((p)*20)+9)\tab 1
\par InputOffsetSensorBoolean(p)\tab (((p)*20)+10)\tab 1
\par InputOffsetDigiPinsDir(p)\tab (((p)*20)+11)\tab 1
\par InputOffsetDigiPinsIn(p)\tab (((p)*20)+12)\tab 1
\par InputOffsetDigiPinsOut(p)\tab (((p)*20)+13)\tab 1
\par InputOffsetCustomPctFullScale(p)\tab (((p)*20)+14)\tab 1
\par InputOffsetCustomActiveStatus(p)\tab (((p)*20)+15)\tab 1
\par InputOffsetInvalidData(p)\tab (((p)*20)+16)\tab 1
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Outputs}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Output Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}
{\f1  output module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.3 Output Module
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT output module encompasses all the motor outputs.
\par }\pard \ql \li360\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin360\itap0 {\b\f1 Module Constants\tab Function
\par }\pard \ql \li360\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin360\itap0 {\f1 OutputModuleName\tab "Output.mod"
\par OutputModuleID\tab 0x00020001
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
Nearly all of the NBC API functions dealing with outputs take either a single output or a set of outputs as their first argument. Depending on the function call, the output or set of outputs may be a constant or a variable c
ontaining an appropriate output port value. The constants OUT_A, OUT_B, and OUT_C are used to identify the three outputs. Unlike NQC, adding individual outputs together does not combine multiple outputs. Instead, the NBC API provides predefined combinatio
ns of outputs: OUT_AB, OUT_AC, OUT_BC, and OUT_ABC. Manually combining outputs involves creating an array and adding two or more of the three individual output constants to the array.
\par Power levels can range 0 (lowest) to 100 (highest). Negative power levels reverse the direction of rotation (i.e., forward at a power level of -100 actually means reverse at a power level of 100).
\par The outputs each have several fields that define the current state of the output port. These fields are defined in the table below.
\par }\pard \ql \fi-5040\li5040\ri0\sb120\widctlpar\tx1440\tx2160\tx3600\tx5040\faauto\adjustright\rin0\lin5040\itap0 {\b\f1 Field Constant\tab Type\tab Access\tab Range\tab Meaning
\par }\pard \ql \fi-5040\li5040\ri0\widctlpar\tx1440\tx2160\tx3600\tx5040\faauto\adjustright\rin0\lin5040\itap0 {\f1 UpdateFlags\tab ubyte\tab Read/Write\tab 0, 255\tab 
Use UF_UPDATE_MODE, UF_UPDATE_SPEED, UF_UPDATE_TACHO_LIMIT, and UF_UPDATE_PID_VALUES along with other fields to commit changes to the state of outputs. Set the appropriate flags a
fter setting one or more of the output fields in order for the changes to actually go into affect.
\par OutputMode\tab ubyte\tab Read/Write\tab 0, 255\tab The OUT_MODE_MOTORON bit must be set in order for power to be applied to the motors. Add OUT_MODE_BRAKE to enable electron
ic braking. Braking means that the output voltage is not allowed to float between active PWM pulses. It improves the accuracy of motor output but uses more battery power.
\par \tab \tab \tab \tab To use motor regulation include OUT_MODE_REGULATED in the OutputMode value. Use UF_UPDATE_MODE with UpdateFlags to commit changes to this field.
\par Power\tab sbyte\tab Read/ Write\tab -100, 100\tab Specify the power level of the output. The absolute value of Power is a percentage of the full power of the motor. The sign of Power controls the rotation dir
ection. Positive values tell the firmware to turn the motor forward, while negative values turn the motor backward. Use UF_UPDATE_POWER with UpdateFlags to commit changes to this field.
\par ActualSpeed\tab sbyte\tab Read\tab -100, 100\tab Return the percent of full power the firmware is applying to the output. This may vary from the Power value when auto-regulation code in the firmware responds to a load on the output.
\par TachoCount\tab slong\tab Read\tab signed long\tab Return the internal position counter value for the specified output. The internal count is reset automatically when a new goal is set using the TachoLimit and the UF_UPDATE_TACHO_LIMIT flag.
\par \tab \tab \tab \tab Set the UF_UPDATE_RESET_COUNT flag in UpdateFlags to reset TachoCount and cancel any TachoLimit.
\par \tab \tab \tab \tab The sign of TachoCount indicates the motor rotation direction.
\par TachoLimit\tab ulong\tab Read/ Write\tab unsigned long\tab Specify the number of degrees the motor should rotate.
\par \tab \tab \tab \tab Use UF_UPDATE_TACHO_LIMIT with the UpdateFlags field to commit changes to the TachoLimit. 
\par \tab \tab \tab \tab The value of this field is a relative distance from the current motor position at the moment when the UF_UPDATE_TACHO_LIMIT flag is processed.
\par RunState\tab ubyte\tab Read/ Write\tab 0..255\tab Use this field to specify the running state of an output. Set the RunState to OUT_RUNSTATE_RUNNING to enable p
ower to any output. Use OUT_RUNSTATE_RAMPUP to enable automatic ramping to a new Power level greater than the current Power level. Use OUT_RUNSTATE_RAMPDOWN to enable automatic ramping to a new Power level less than the current Power level.
\par \tab \tab \tab \tab Both the ra
mpup and rampdown bits must be used in conjunction with appropriate TachoLimit and Power values. In this case the firmware smoothly increases or decreases the actual power to the new Power level over the total number of degrees of rotation specified in Ta
choLimit.
\par TurnRatio\tab sbyte\tab Read/ Write\tab -100, 100\tab 
Use this field to specify a proportional turning ratio. This field must be used in conjunction with other field values: OutputMode must include OUT_MODE_MOTORON and OUT_MODE_REGULATED, RegMode must be set to O
UT_REGMODE_SYNC, RunState must not be OUT_RUNSTATE_IDLE, and Speed must be non-zero. 
\par \tab \tab \tab \tab There are only three valid combinations of left and right motors for use with TurnRatio: OUT_AB, OUT_BC, and OUT_AC. In each of these three options the first motor li
sted is considered to be the left motor and the second motor is the right motor, regardless of the physical configuration of the robot.
\par \tab \tab \tab \tab Negative TurnRatio values shift power toward the left motor while positive values shift power toward the right motor
. An absolute value of 50 usually results in one motor stopping. An absolute value of 100 usually results in two motors turning in opposite directions at equal power.
\par RegMode\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the regulation mode to use with the
 specified port(s). It is ignored if the OUT_MODE_REGULATED bit is not set in the OutputMode field. Unlike the OutputMode field, RegMode is not a bitfield. Only one RegMode value can be set at a time. 
\par \tab \tab \tab \tab Speed regulation means that the firmware tries to 
maintain a certain speed based on the Power setting. The firmware adjusts the PWM duty cycle if the motor is affected by a physical load. This adjustment is reflected by the value of the ActualSpeed property. When using speed regulation, do not set Power 
to its maximum value since the firmware cannot adjust to higher power levels in that situation.
\par \tab \tab \tab \tab Synchronization means the firmware tries to keep two motors in synch regardless of physical loads. Use this mode to maintain a straight path for a mobile rob
ot automatically. Also use this mode with the TurnRatio property to provide proportional turning. 
\par \tab \tab \tab \tab Set OUT_REGMODE_SYNC on at least two motor ports in order for synchronization to function. Setting OUT_REGMODE_SYNC on all three motor ports will result in only the first two (OUT_A and OUT_B) being synchronized.
\par Overload\tab ubyte\tab Read\tab 0..1\tab This field will have a value of 1 (true) if the firmware speed regulation cannot overcome a physical load on the motor. In other words, the motor is turning more slowly than expected. 
\par \tab \tab \tab \tab If the motor speed can be maintained in spite of loading then this field value is zero (false). 
\par \tab \tab \tab \tab In order to use this field the motor must have a non-idle RunState, an OutputMode which includes OUT_MODE_MOTORON and OUT_MODE_REGULATED, and its RegMode must be set to OUT_REGMODE_SPEED.
\par RegPValue\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the proportional term used in the internal proportional-integral-derivative (PID) control algorithm.
\par \tab \tab \tab \tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.
\par RegIValue\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the integral term used in the internal proportional-integral-derivative (PID) control algorithm.
\par \tab \tab \tab \tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.
\par RegDValue\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the derivative term used in the internal proportional-integral-derivative (PID) control algorithm.
\par \tab \tab \tab \tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.
\par BlockTachoCount\tab slong\tab Read\tab full range of signed long\tab Return the block-relative position counter value for the specified port.
\par \tab \tab \tab \tab Refer to the UpdateFlags description for information about how to use block-relative position counts.
\par \tab \tab \tab \tab Set the UF_UPDATE_RESET_BLOCK_COUNT flag in UpdateFlags to request that the firmware reset the BlockTachoCount. 
\par \tab \tab \tab \tab The sign of BlockTachoCount indicates the direction of rotation. Positive values indicate forward rotation and negative values indicate reverse rotation. Forward and reverse depend on the orientation of the motor.
\par RotationCount\tab slong\tab Read\tab signed long\tab Return the program-relative position counter value for the specified port.
\par \tab \tab \tab \tab Refer to the UpdateFlags description for information about how to use program-relative position counts.
\par \tab \tab \tab \tab Set the UF_UPDATE_RESET_ROTATION_COUNT flag in UpdateFlags to request that the firmware reset the RotationCount. 
\par \tab \tab \tab \tab The sign of RotationCount indicates the direction of rotation. Positive values indicate forward rotation and negative values indicate reverse rotation. Forward and reverse depend on the orientation of the motor.
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid UpdateFlags values are described in the following table.
\par }\pard \ql \fi-4320\li4320\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin4320\itap0 {\b\f1 UpdateFlags Constants\tab Meaning
\par }\pard \ql \fi-4320\li4320\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin4320\itap0 {\f1 UF_UPDATE_MODE\tab Commits changes to the OutputMode output property
\par UF_UPDATE_SPEED\tab Commits changes to the Power output property
\par UF_UPDATE_TACHO_LIMIT\tab Commits changes to the TachoLimit output property
\par UF_UPDATE_RESET_COUNT\tab Resets all rotation counters, cancels the current goal, and resets the rotation error-correction system
\par UF_UPDATE_PID_VALUES\tab Commits changes to the PID motor regulation properties
\par UF_UPDATE_RESET_BLOCK_COUNT\tab Resets the block-relative rotation counter
\par UF_UPDATE_RESET_ROTATION_COUNT\tab Resets the program-relative rotation counter
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid OutputMode values are described in the following table.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx2880\tx3960\faauto\adjustright\rin0\lin0\itap0 {\b\f1 OutputMode Constants\tab Value\tab Meaning
\par }\pard \ql \li0\ri0\widctlpar\tx2880\tx3960\faauto\adjustright\rin0\lin0\itap0 {\f1 OUT_MODE_COAST\tab 0x00\tab No power and no braking so motors rotate freely
\par OUT_MODE_MOTORON\tab 0x01\tab Enables PWM power to the outputs given the Power setting
\par OUT_MODE_BRAKE\tab 0x02\tab Uses electronic braking to outputs
\par OUT_MODE_REGULATED\tab 0x04\tab Enables active power regulation using the RegMode value
\par OUT_MODE_REGMETHOD\tab 0xf0\tab 
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid RunState values are described in the following table.
\par }\pard \ql \fi-4320\li4320\ri0\sb120\widctlpar\tx3240\tx4320\faauto\adjustright\rin0\lin4320\itap0 {\b\f1 RunState Constants\tab Value\tab Meaning
\par }\pard \ql \fi-4320\li4320\ri0\widctlpar\tx3240\tx4320\faauto\adjustright\rin0\lin4320\itap0 {\f1 OUT_RUNSTATE_IDLE\tab 0x00\tab Disable all power to motors.
\par OUT_RUNSTATE_RAMPUP\tab 0x10\tab Enable ramping up from a current Power to a new (higher) Power over a specified TachoLimit goal.
\par OUT_RUNSTATE_RUNNING\tab 0x20\tab Enable power to motors at the specified Power level.
\par OUT_RUNSTATE_RAMPDOWN\tab 0x40\tab Enable ramping down from a current Power to a new (lower) Power over a specified TachoLimit goal.
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid RegMode values are described in the following table.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx3240\tx4320\faauto\adjustright\rin0\lin0\itap0 {\b\f1 RegMode Constants\tab Value\tab Meaning
\par }\pard \ql \li0\ri0\widctlpar\tx3240\tx4320\faauto\adjustright\rin0\lin0\itap0 {\f1 OUT_REGMODE_IDLE\tab 0x00\tab No regulation
\par OUT_REGMODE_SPEED\tab 0x01\tab Regulate a motor's speed (Power)
\par OUT_REGMODE_SYNC\tab 0x02\tab Synchronize the rotation of two motors
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_OutputsConvenience}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Convenience Calls}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  convenience calls}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{\cs43 3.3.1 Convenience Calls
\par }\pard\plain \ql \li0\ri0\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Since control of outputs is such a common feature of programs, a number of convenience functions are provided
 that make it easy to work with the outputs. It should be noted that most of these commands do not provide any new functionality above lower level calls described in the following section. They are merely convenient ways to make programs more concise.

\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 The 
Ex versions of the motor functions use special reset constants. They are defined in the following table. The Var versions of the motor functions require that the outputs argument be a variable while the non-Var versions require that the outputs argument b
e a constant.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Reset Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 RESET_NONE\tab 0x00
\par RESET_COUNT\tab 0x08
\par RESET_BLOCK_COUNT\tab 0x20
\par RESET_ROTATION_COUNT\tab 0x40
\par RESET_BLOCKANDTACHO\tab 0x28
\par RESET_ALL\tab 0x68
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Output Port Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 OUT_A\tab 0x00
\par OUT_B\tab 0x01
\par OUT_C\tab 0x02
\par OUT_AB\tab 0x03
\par OUT_AC\tab 0x04
\par OUT_BC\tab 0x05
\par OUT_ABC\tab 0x06
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Off(outputs)\tab Function
\par }{\f1 Turn the specified outputs off (with braking). Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Off(OUT_A) // turn off output A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OffEx(outputs, const reset)\tab Function
\par }{\f1 Turn the specified outputs off (with braking). Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three posi
tion counters are reset. It must be a constant. Valid reset values are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OffEx(OUT_A, RESET_NONE) // turn off output A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Coast(outputs)\tab Function
\par }{\f1 Turn off the specified outputs, making them coast to a stop. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Coast(OUT_A) // coast output A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 CoastEx(outputs, const reset)\tab Function
\par }{\f1 Turn off the specified outputs, making them coast to a stop. Outputs can be a constant or a varia
ble containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 CoastEx(OUT_A, RESET_NONE) // coast output A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 Float(outputs)\tab Function
\par }{\f1 Make outputs float. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Float is an alias for Coast.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 Float(OUT_A) // float output A
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnFwd(outputs, pwr)\tab Function
\par }{\f1 Set outputs to forward direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnFwd(OUT_A, 75)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnFwdEx(outputs, pwr, const reset)\tab Function
\par }{\f1 Set outputs to forward direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three posit
ion counters are reset. It must be a constant. Valid reset values are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnFwdEx(OUT_A, 75, RESET_NONE)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnRev(outputs, pwr)\tab Function
\par }{\f1 Set outputs to reverse direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnRev(OUT_A, 75)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnRevEx(outputs, pwr, const reset)\tab Function
\par }{\f1 Set outputs to reverse direction and turn them on. Outputs can be a constant or a variable containing the desired output ports.
 Predefined output port constants are defined above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnRevEx(OUT_A, 75, RESET_NONE)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnFwdReg(outputs, pwr, regmode)\tab Function
\par }{\f1 Run the specified outputs forward using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Valid regulation modes are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnFwdReg(OUT_A, 75, OUT_REGMODE_SPEED) // regulate speed
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnFwdRegEx(outputs, pwr, regmode, const reset)\tab Function
\par }{\f1 Run the specified outputs forward using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports
. Predefined output port constants are defined above. Valid regulation modes are listed above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnFwdRegEx(OUT_A, 75, OUT_REGMODE_SPEED, RESET_NONE)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnRevReg(outputs, pwr, regmode)\tab Function
\par }{\f1 Run the specified outputs in reverse using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Valid regulation modes are listed above.

\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnRevReg(OUT_A, 75, OUT_REGMODE_SPEED) // regulate speed
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnRevRegEx(outputs, pwr, regmode, const reset)\tab Function
\par }{\f1 Run the specified outputs in reverse using the specified regulation mode. Outpu
ts can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Valid regulation modes are listed above. The reset parameter controls whether any of the three position counters are reset. It must
 be a constant. Valid reset values are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnRevRegEx(OUT_A, 75, OUT_REGMODE_SPEED, RESET_NONE)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnFwdSync(outputs, pwr, turnpct)\tab Function
\par }{\f1 Run the specified outputs forward with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnFwdSync(OUT_AB, 75, -100) // spin right
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnFwdSyncEx(outputs, pwr, turnpct, const reset)\tab Function
\par }{\f1 Run the specified outputs forward with r
egulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three position counte
rs are reset. It must be a constant. Valid reset values are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnFwdSyncEx(OUT_AB, 75, 0, RESET_NONE)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnRevSync(outputs, pwr, turnpct)\tab Function
\par }{\f1 Run the specified outputs in reverse with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnRevSync(OUT_AB, 75, -100) // spin left
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 OnRevSyncEx(outputs, pwr, turnpct, const reset)\tab Function
\par }{\f1 Run the specified outputs in re
verse with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three pos
ition counters are reset. It must be a constant. Valid reset values are listed above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 OnRevSyncEx(OUT_AB, 75, -100, RESET_NONE) // spin left
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RotateMotor(outputs, pwr, angle)\tab Function
\par }{\f1 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 RotateMotor(OUT_A, 75, 45) // forward 45 degrees
\par RotateMotor(OUT_A, -75, 45) // reverse 45 degrees
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RotateMotorPID(outputs, pwr, angle, p, i, d)\tab Function
\par }{\f1 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Also specify the proportional, in
tegral, and derivative factors used by the firmware's PID motor control algorithm.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 RotateMotorPID(OUT_A, 75, 45, 20, 40, 100)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RotateMotorEx(outputs, pwr, angle, turnpct, sync, stop)\tab Function
\par }{\f1 Run the specified outputs forward for the specified number of deg
rees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. If a non-zero turn percent is specified then sync must be set to true or no turning will occur. Specify whether the moto
r(s) should brake at the end of the rotation using the stop parameter.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 RotateMotorEx(OUT_AB, 75, 360, 50, true, true) 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RotateMotorExPID(outputs, pwr, angle, turnpct, sync, stop, p, i, d)\tab Function
\par }{\f1 Run the specified outputs forward for the specified number of
 degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. If a non-zero turn percent is specified then sync must be set to true or no turning will occur. Specify whether the 
motor(s) should brake at the end of the rotation using the stop parameter. Also specify the proportional, integral, and derivative factors used by the firmware's PID motor control algorithm.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 RotateMotorExPID(OUT_AB, 75, 360, 50, true, true, 30, 50, 90) 
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ResetTachoCount(outputs)\tab Function
\par }{\f1 Reset the tachometer count and tachometer limit goal for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ResetTachoCount(OUT_AB)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ResetBlockTachoCount(outputs)\tab Function
\par }{\f1 Reset the block-relative position counter for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ResetBlockTachoCount(OUT_AB)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ResetRotationCount(outputs)\tab Function
\par }{\f1 Reset the program-relative position counter for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ResetRotationCount(OUT_AB)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 ResetAllTachoCounts(outputs)\tab Function
\par }{\f1 Reset all three position counters and reset the current tachometer limit goal for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 ResetAllTachoCounts(OUT_AB)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 \page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_OutputIOMapOffsets}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Output Module IOMap Offsets}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  output module iomap offsets}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.3.2 IOMap Offsets
\par }\pard\plain \ql \li720\ri0\widctlpar\tx4320\tx6480\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Output Module Offsets\tab Function\tab Size
\par }{\f1 OutputOffsetTachoCount(p)\tab (((p)*32)+0)\tab 4
\par OutputOffsetBlockTachoCount(p)\tab (((p)*32)+4)\tab 4
\par OutputOffsetRotationCount(p)\tab (((p)*32)+8)\tab 4
\par OutputOffsetTachoLimit(p)\tab (((p)*32)+12)\tab 4
\par OutputOffsetMotorRPM(p)\tab (((p)*32)+16)\tab 2
\par OutputOffsetFlags(p)\tab (((p)*32)+18)\tab 1
\par OutputOffsetMode(p)\tab (((p)*32)+19)\tab 1
\par OutputOffsetSpeed(p)\tab (((p)*32)+20)\tab 1
\par OutputOffsetActualSpeed(p)\tab (((p)*32)+21)\tab 1
\par OutputOffsetRegPParameter(p)\tab (((p)*32)+22)\tab 1
\par OutputOffsetRegIParameter(p)\tab (((p)*32)+23)\tab 1
\par OutputOffsetRegDParameter(p)\tab (((p)*32)+24)\tab 1
\par OutputOffsetRunState(p)\tab (((p)*32)+25)\tab 1
\par OutputOffsetRegMode(p)\tab (((p)*32)+26)\tab 1
\par OutputOffsetOverloaded(p)\tab (((p)*32)+27)\tab 1
\par OutputOffsetSyncTurnParameter(p)\tab (((p)*32)+28)\tab 1
\par OutputOffsetPwnFreq\tab 96\tab 1
\par }{\b\f1 Table 23. Output Module IOMap Offsets
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Sound}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sound Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  sound module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.4 Sound Module
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The NXT sound module encompasses all sound output features. The NXT provides support for playing basic tones as well as two different types of files. 
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Module Constants\tab Function
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 SoundModuleName\tab "Sound.mod"
\par SoundModuleID\tab 0x00080001
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Sound files (.rso) are like .wav files. They contain thousands of sound samples that digitally represent an analog waveform. With sounds files the NXT can speak o
r play music or make just about any sound imaginable.
\par Melody files are like MIDI files. They contain multiple tones with each tone being defined by a frequency and duration pair. When played on the NXT a melody file sounds like a pure sine-wave tone genera
tor playing back a series of notes. While not as fancy as sound files, melody files are usually much smaller than sound files.
\par When a sound or a file is played on the NXT, execution of the program does not wait for the previous playback to complete. To pla
y multiple tones or files sequentially it is necessary to wait for the previous tone or file playback to complete first. This can be done via the Wait API function or by using the sound state value within a while loop.
\par The NBC API defines frequency and dur
ation constants which may be used in calls to PlayTone or PlayToneEx. Frequency constants start with TONE_A3 (the 'A' pitch in octave 3) and go to TONE_B7 (the 'B' pitch in octave 7). Duration constants start with MS_1 (1 millisecond) and go up to MIN_1 (
60000 milliseconds) with several constants in between. See NBCCommon.h for the complete list.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 \page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_SoundHighLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sound Module High Level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  sound module high level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.4.1 High-level functions
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs24 PlayTone(frequency, duration)\tab Function
\par }{\f1 Play a single tone of the specified frequency and duration. The frequency is in Hz. The duration is in 1000ths of a second. All parameters may be any valid expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 PlayTone(440, 500)\tab // Play 'A' for one half second
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PlayToneEx(frequency, duration, volume, bLoop)\tab Function
\par }{\f1 Play a single tone of the specified frequency, duration, and volume. The frequency is in Hz. The duration is in 1000ths of a second. Volume should be a number from 0 (silent) to 4 (loudest). All parameters may be any valid expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 PlayToneEx(440, 500, 2, FALSE)
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PlayFile(filename)\tab Function
\par }{\f1 Play the specified sound file (.rso) or a melody file (.rmd). The filename may be any valid string expression.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 PlayFile('startup.rso')
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 PlayFileEx(filename, volume, bLoop)\tab Function
\par }{\f1 Play the specified sound file (.rso) or a melody file (.rmd). The filename may be any valid string expression. Volume should be a number from 0 (silent) to 4 (loudest). bLoop is a boolean value indicating whether to repeatedly play the file.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 PlayFileEx('startup.rso', 3, TRUE)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_SoundLowLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sound Module Low Level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  sound module low level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.4.2 Low-level functions
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Valid sound flags constants are listed in the following table.
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx2709\tx4059\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs22 Sound Flags Constants\tab Read/Write\tab Meaning
\par }\pard \s18\ql \li0\ri0\widctlpar\tx2709\tx4059\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 SOUND_FLAGS_IDLE\tab Read\tab Sound is idle
\par SOUND_FLAGS_UPDATE\tab Write\tab Make changes take effect
\par SOUND_FLAGS_RUNNING\tab Read\tab Processing a tone or file
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Valid sound state constants are listed in the following table.
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx3060\tx4680\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs22 Sound State Constants\tab Read/Write\tab Meaning
\par }\pard \s18\ql \li0\ri0\widctlpar\tx3060\tx4680\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 SOUND_STATE_IDLE\tab Read\tab Idle, ready for start sound
\par SOUND_STATE_FILE\tab Read\tab Processing file of sound/melody data
\par SOUND_STATE_TONE\tab Read\tab Processing play tone request
\par SOUND_STATE_STOP\tab Write\tab Stop sound immediately and close hardware
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Valid sound mode constants are listed in the following table.
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx2700\tx3960\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs22 Sound Mode Constants\tab Read/Write\tab Meaning
\par }\pard \s18\ql \li0\ri0\widctlpar\tx2700\tx3960\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 SOUND_MODE_ONCE\tab Read\tab Only play file once
\par SOUND_MODE_LOOP\tab Read\tab Play file until writing SOUND_STATE_STOP into State.
\par SOUND_MODE_TONE\tab Read\tab Play tone specified in Frequency for Duration milliseconds.
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Miscellaneous sound constants are listed in the following table.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx2880\tx4320\faauto\adjustright\rin0\lin0\itap0 {\b\f1 Misc. Sound Constants\tab Value\tab Meaning
\par }\pard \ql \li0\ri0\widctlpar\tx2880\tx4320\faauto\adjustright\rin0\lin0\itap0 {\f1 FREQUENCY_MIN\tab 220\tab Minimum frequency in Hz.
\par FREQUENCY_MAX\tab 14080\tab Maximum frequency in Hz.
\par SAMPLERATE_MIN\tab 2000\tab Minimum sample rate supported by NXT
\par SAMPLERATE_DEFAULT\tab 8000\tab Default sample rate
\par SAMPLERATE_MAX\tab 16000\tab Maximum sample rate supported by NXT
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Toc179361864}GetSoundState(out state, out flags)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current sound state. Valid sound state values are listed above. Val
id sound flags values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetSoundState(state, flags)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSoundState(state, flags, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Set the current sound module state. Valid sound state values are listed above. Valid sound flags values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSoundState(SOUND_STATE_STOP, SOUND_FLAGS_UPDATE, result)

\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSoundFlags(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current sound flags. Valid sound flags values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSoundFlags(SOUND_FLAGS_UPDATE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSoundModuleState(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current sound module state. Valid sound state values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSoundState(SOUND_STATE_STOP)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetSoundMode(out mode)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current sound mode. Valid sound mode values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetSoundMode(mode)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSoundMode(n)\tab Function
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSoundMode(SOUND_MODE_ONCE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetSoundFrequency(out freq)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current sound frequency.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetSoundFrequency(freq)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSoundFrequency(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current sound frequency.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSoundFrequency(440)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetSoundDuration(out duration)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current sound duration.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetSoundDuration(duration)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSoundDuration(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current sound duration.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSoundDuration(500)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetSoundSampleRate(out rate)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current sound sample rate.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetSoundSampleRate(rate)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSoundSampleRate(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current sound sample rate.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSoundSampleRate(4000)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetSoundVolume(out volume)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current sound volume.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetSoundVolume(volume)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSoundVolume(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current sound volume.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSoundVolume(3)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 {\*\bkmkend _Toc179361864}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_SoundIOMapOffsets}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Sound Module IOMap Offsets}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  sound module iomap offsets}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.4.3 IOMap Offsets
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx2654\tx3554\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Sound Module Offsets\tab Function\tab Size
\par }\pard \s18\ql \li0\ri0\widctlpar\tx3240\tx5040\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 SoundOffsetFreq\tab 0\tab 2
\par SoundOffsetDuration\tab 2\tab 2
\par SoundOffsetSampleRate\tab 4\tab 2
\par SoundOffsetSoundFilename\tab 6\tab 20
\par SoundOffsetFlags\tab 26\tab 1
\par SoundOffsetState\tab 27\tab 1
\par SoundOffsetMode\tab 28\tab 1
\par SoundOffsetVolume\tab 29\tab 1
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_IOCtrl}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  IOCtrl Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}
{\f1  ioctrl module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.5 IOCtrl Module
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT ioctrl module encompasses low-le
vel communication between the two processors that control the NXT. The NBC API exposes two functions that are part of this module.
\par }{\b\f1\fs24 PowerDown\tab Function
\par }{\f1 Turn off the NXT immediately.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 PowerDown
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24 RebootInFirmwareMode\tab Function
\par }{\f1 Reboot the NXT in SAMBA or firmware download mode. This function is not likely to be used in a normal NBC program.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 {\f2 RebootInFirmwareMode
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 \page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_IOCtrlIOMapOffsets}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  IOCtrl Module IOMap Offsets}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  ioctrl module iomap offsets}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.5.1 IOMap Offsets
\par }\pard\plain \s18\ql \li590\ri0\sb120\widctlpar\tx3348\tx4680\aspalpha\aspnum\faauto\adjustright\rin0\lin590\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 IOCtrl Module Offsets\tab Value\tab Size
\par }\pard \s18\ql \li590\ri0\widctlpar\tx3348\tx4680\aspalpha\aspnum\faauto\adjustright\rin0\lin590\itap0 {\f1\fs20 IOCtrlOffsetPowerOn\tab 0\tab 2
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Display}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Display Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K
}{\f1  display module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.6 Display Module
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT display module encompasses support for dra
wing to the NXT LCD. The NXT supports drawing points, lines, rectangles, and circles on the LCD. It supports drawing graphic icon files on the screen as well as text and numbers.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Module Constants\tab Function
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 DisplayModuleName\tab "Display.mod"
\par DisplayModuleID\tab 0x000A0001
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
The LCD screen has its origin (0, 0) at the bottom left-hand corner of the screen with the positive Y-axis extending upward and the positive X-axis extending toward the right. The NBC API provides constants for use in the NumOut and TextOut functio
ns which make it possible to specify LCD line numbers between 1 and 8 with line 1 being at the top of the screen and line 8 being at the bottom of the screen. These constants (LCD_LINE1, LCD_LINE2, LCD_LINE3, LCD_LINE4, LCD_LINE5, LCD_LINE6, LCD_LINE7, LC
D_LINE8) should be used as the Y coordinate in NumOut and TextOut calls. Values of Y other than these constants will be adjusted so that text and numbers are on one of 8 fixed line positions.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {{\*\bkmkstart _Toc179361869}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_DisplayHighLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Display Module High-level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  display module high-level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.6.1 High-level Functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 NumOut(x, y, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a numeric value on the screen at the specified x and y location.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {NumOut(0, LCD_LINE1, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 NumOutEx(x, y, value, clear)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Draw a numeric value on the screen at the specified x and y location. Clear the screen first if clear equals TRUE.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {NumOutEx(0, LCD_LINE1, x, TRUE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 TextOut(x, y, msg)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a text value on the screen at the specified x and y location.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TextOut(0, LCD_LINE3, 'Hello World!')
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 TextOutEx(x, y, msg, clear)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a text value on the screen at the specified x and y location. 
Clear the screen first if clear equals TRUE.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {TextOutEx(0, LCD_LINE3, 'Hello World!', FALSE) 
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GraphicOut(x, y, filename)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Draw the specified graphic icon file on the screen at the specified x and y location. If the file cannot be found then nothing will be drawn and no errors will be reported.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GraphicOut(40, 40, 'image.ric')
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GraphicOutEx(x, y, filename, vars, clear)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Draw the specified graphic icon file on the screen at the specified x and y location. Use the values contained in the vars arra
y to transform the drawing commands contained within the specified icon file. Clear the screen first if clear equals TRUE. If the file cannot be found then nothing will be drawn and no errors will be reported.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {\lang1024\langfe1024\langnp1036 
GraphicOutEx(40, 40, 'image.ric', variables, TRUE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 CircleOut(x, y, radius)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Draw a circle on the screen with its center at the specified x and y location, using the specified radius.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {CircleOut(40, 40, 10) 
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 CircleOutEx(x, y, radius, clear)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a circle on the screen with its center at
 the specified x and y location, using the specified radius. Clear the screen first if clear equals TRUE.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {CircleOutEx(40, 40, 10, TRUE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 LineOut(x1, y1, x2, y2)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a line on the screen from x1, y1 to x2, y2.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {LineOut(40, 40, 10, 10) 
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 LineOutEx(x1, y1, x2, y2, clear)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a line on the screen from x1, y1 to x2, y2. Clear the screen first if clear equals TRUE.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {LineOutEx(40, 40, 10, 10, FALSE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 PointOut(x, y)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a point on the screen at x, y.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {PointOut(40, 40) 
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 PointOutEx(x, y, clear)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a point on the screen at x, y. Clear the screen first if clear equals TRUE.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {PointOutEx(40, 40, TRUE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RectOut(x, y, width, height)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Draw a rectangle on the screen at x, y with the specified width and height.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RectOut(40, 40, 30, 10)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RectOutEx(x, y, width, height, clear)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Draw a rectangle on the screen at x, y with the specified width and height. Clear the screen first if clear equals TRUE.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RectOutEx(40, 40, 30, 10, TRUE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ClearScreen()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Clear the NXT LCD to a blank screen.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ClearScreen()
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {{\*\bkmkend _Toc179361869}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_DisplayLowLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Display Module low-level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  display module low-level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.6.2 Low-level Functions
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Valid display flag values are listed in the following table.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tx3152\tx4368\faauto\adjustright\rin0\lin0\itap0 {\b\f1 Display Flags Constant\tab Read/Write\tab Meaning
\par }\pard \ql \li0\ri0\widctlpar\tx3152\tx4368\faauto\adjustright\rin0\lin0\itap0 {\f1 DISPLAY_ON\tab Write\tab Display is on
\par DISPLAY_REFRESH\tab Write\tab Enable refresh
\par DISPLAY_POPUP\tab Write\tab Use popup display memory
\par DISPLAY_REFRESH_DISABLED\tab Read\tab Refresh is disabled
\par DISPLAY_BUSY\tab Read\tab Refresh is in progress
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Toc179361870}GetDisplayFlags(out flags)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current display flags. Valid flag values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetDisplayFlags(flags)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetDisplayFlags(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current display flags. Valid flag values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\sl360\slmult1\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetDisplayFlags(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetDisplayEraseMask(out emask)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current display erase mask.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetDisplayEraseMask(emask)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetDisplayEraseMask(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current display erase mask.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetDisplayEraseMask(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetDisplayUpdateMask(out umask)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current display update mask.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetDisplayUpdateMask(umask)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetDisplayUpdateMask(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current display update mask.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetDisplayUpdateMask(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetDisplayDisplay(out addr)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current display memory address.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetDisplayDisplay(addr)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetDisplayDisplay(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current display memory address.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetDisplayDisplay(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetDisplayTextLinesCenterFlags(out flags)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current display text lines center flags.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetDisplayTextLinesCenterFlags(flags)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetDisplayTextLinesCenterFlags(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current display text lines center flags.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetDisplayTextLinesCenterFlags(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetDisplayNormal(x, line, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Read "count" bytes from
 the normal display memory into the data array. Start reading from the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use
 }{\cs19\f6\fs22 TEXTLINE_1}{\f1  through }{\cs19\f6\fs22 TEXTLINE_8}{\f1  for the "line" parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetDisplayNormal(0, TEXTLINE_1, 8, ScreenMem)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetDisplayNormal(x, line, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Write "count" bytes to the normal display memory from the data array. Start writing at the specified x, li
ne coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use }{\cs19\f6\fs22 TEXTLINE_1}{\f1  through }{\cs19\f6\fs22 TEXTLINE_8}{\f1 
 for the "line" parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetDisplayNormal(0, TEXTLINE_1, 8, ScreenMem)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetDisplayPopup(x, line, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read "count" bytes from the popup display memory into the data array. Start reading from the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8
 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use }{\cs19\f6\fs22 TEXTLINE_1}{\f1  through }{\cs19\f6\fs22 TEXTLINE_8}{\f1  for the "line" parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetDisplayPopup(0, TEXTLINE_1, 8, PopupMem)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetDisplayPopup(x, line, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Write "count" bytes 
to the popup display memory from the data array. Start writing at the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use 
}{\cs19\f6\fs22 TEXTLINE_1}{\f1  through }{\cs19\f6\fs22 TEXTLINE_8}{\f1  for the "line" parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetDisplayPopup(0, TEXTLINE_1, 8, PopupMem)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 {\*\bkmkend _Toc179361870}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_DisplayIOMapOffsets}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Display Module IOMap Offsets}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  display module iomap offsets}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.6.3 IOMap Offsets
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx3348\tx5223\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Display Module Offsets\tab Value\tab Size
\par }\pard \s18\ql \li0\ri0\widctlpar\tx3348\tx5223\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 DisplayOffsetPFunc\tab 0\tab 4
\par DisplayOffsetEraseMask\tab 4\tab 4
\par DisplayOffsetUpdateMask\tab 8\tab 4
\par DisplayOffsetPFont\tab 12\tab 4
\par DisplayOffsetPTextLines(p)\tab (((p)*4)+16)\tab 4*8
\par DisplayOffsetPStatusText\tab 48\tab 4
\par DisplayOffsetPStatusIcons\tab 52\tab 4
\par DisplayOffsetPScreens(p)\tab (((p)*4)+56)\tab 4*3
\par DisplayOffsetPBitmaps(p)\tab (((p)*4)+68)\tab 4*4
\par DisplayOffsetPMenuText\tab 84\tab 4
\par DisplayOffsetPMenuIcons(p)\tab (((p)*4)+88)\tab 4*3
\par DisplayOffsetPStepIcons\tab 100\tab 4
\par DisplayOffsetDisplay\tab 104\tab 4
\par DisplayOffsetStatusIcons(p)\tab ((p)+108)\tab 1*4
\par DisplayOffsetStepIcons(p)\tab ((p)+112)\tab 1*5
\par DisplayOffsetFlags\tab 117\tab 1
\par DisplayOffsetTextLinesCenterFlags\tab 118\tab 1
\par DisplayOffsetNormal(l,w)\tab (((l)*100)+(w)+119)\tab 800
\par DisplayOffsetPopup(l,w)\tab (((l)*100)+(w)+919)\tab 800
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Loader}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Loader Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}
{\f1  loader module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.7 Loader Module
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The NXT loader module encompasses support for the NXT file system. The NXT supports creating files, opening existing files, reading, writing, renaming, and deleting files.
\par }\pard \ql \li1440\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin1440\itap0 {\b\f1 Module Constants\tab Value
\par }\pard \ql \li1440\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin1440\itap0 {\f1 LoaderModuleName\tab "Loader.mod"
\par LoaderModuleID\tab 0x00090001
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
Files in the NXT file system must adhere to the 15.3 naming convention for a maximum filename length of 19 characters. While multiple files can be opened simultaneously, a maximum of 4 files can be open for writing at any given time.
\par When accessing files on the NXT, errors can occur. The NBC API defines several constants that define possible result codes. They are listed in the following table.
\par }\pard\plain \s18\ql \li720\ri0\sb120\widctlpar\tx4320\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Loader Result Codes\tab Function
\par }\pard \s18\ql \li720\ri0\widctlpar\tx4320\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0 {\f1\fs20 LDR_SUCCESS\tab 0x0000
\par LDR_INPROGRESS\tab 0x0001
\par LDR_REQPIN\tab 0x0002
\par LDR_NOMOREHANDLES\tab 0x8100
\par LDR_NOSPACE\tab 0x8200
\par LDR_NOMOREFILES\tab 0x8300
\par LDR_EOFEXPECTED\tab 0x8400
\par LDR_ENDOFFILE\tab 0x8500
\par LDR_NOTLINEARFILE\tab 0x8600
\par LDR_FILENOTFOUND\tab 0x8700
\par LDR_HANDLEALREADYCLOSED\tab 0x8800
\par LDR_NOLINEARSPACE\tab 0x8900
\par LDR_UNDEFINEDERROR\tab 0x8A00
\par LDR_FILEISBUSY\tab 0x8B00
\par LDR_NOWRITEBUFFERS\tab 0x8C00
\par LDR_APPENDNOTPOSSIBLE\tab 0x8D00
\par LDR_FILEISFULL\tab 0x8E00
\par LDR_FILEEXISTS\tab 0x8F00
\par LDR_MODULENOTFOUND\tab 0x9000
\par LDR_OUTOFBOUNDARY\tab 0x9100
\par LDR_ILLEGALFILENAME\tab 0x9200
\par LDR_ILLEGALHANDLE\tab 0x9300
\par LDR_BTBUSY\tab 0x9400
\par LDR_BTCONNECTFAIL\tab 0x9500
\par LDR_BTTIMEOUT\tab 0x9600
\par LDR_FILETX_TIMEOUT\tab 0x9700
\par LDR_FILETX_DSTEXISTS\tab 0x9800
\par LDR_FILETX_SRCMISSING\tab 0x9900
\par LDR_FILETX_STREAMERROR\tab 0x9A00
\par LDR_FILETX_CLOSEERROR\tab 0x9B00
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetFreeMemory(out mem)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Get the number of bytes of flash memory that are available for use.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetFreeMemory(memory)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 CreateFile(filename, size, out handle, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Create a new file with the specified filename and size and open it for writing. The file handle is returned in the last para
meter, which must be a variable. The loader result code is returned as the value of the function call. The filename and size parameters must be constants, constant expressions, or variables. A file created with a size of zero bytes cannot be written to si
nce the NBC file writing functions do not grow the file if its capacity is exceeded during a write attempt.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {CreateFile('data.txt', 1024, handle, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 OpenFileAppend(filename, out size, out handle, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Open an existing file with the speci
fied filename for writing. The file size is returned in the second parameter, which must be a variable. The file handle is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The 
filename parameter must be a constant or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {OpenFileAppend('data.txt', fsize, handle, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 OpenFileRead(filename, out size, out handle, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Open an existing file with the specified filename for reading. The file size is returned
 in the second parameter, which must be a variable. The file handle is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {OpenFileRead('data.txt', fsize, handle, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 CloseFile(handle, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Close the file associated with the specified file handle. The loader result code is returned as the value of the function call. The handle parameter must be a constant or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {CloseFile(handle, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ResolveHandle(filename, out handle, out bWriteable, out result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Resolve a file handle from the specified filename. The file handle is returned in the second parameter, which must be a variable. A boolean val
ue indicating whether the handle can be used to write to the file or not is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a vari
able.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ResolveHandle('data.txt', handle, bCanWrite, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RenameFile(oldfilename, newfilename, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Rename a file from the old filename to the new filename. The loader result code is returned as the value of the function call. The filename parameters must be constants or variables.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RenameFile('data.txt', 'mydata.txt', result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 DeleteFile(filename, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Delete the specified file. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {DeleteFile('data.txt', result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Read(handle, out value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read a numeric value from the file associated with the specified handle. The loader result code is returned as the value of the function call. The handl
e parameter must be a variable. The value parameter must be a variable. The type of the value parameter determines the number of bytes of data read.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Read(handle, value, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadLn(handle, out value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Read a numeric value from the fi
le associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a variable. The type of the value parameter determines the number of bytes 
of data read. The ReadLn function reads two additional bytes from the file which it assumes are a carriage return and line feed pair.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadLn(handle, value, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadBytes(handle, in/out length, out buf, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Read the specified number of b
ytes from the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The length parameter must be a variable. The buf parameter must be an array or a string
 variable. The actual number of bytes read is returned in the length parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadBytes(handle, len, buffer, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Write(handle, value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Write a numeric value to the file associated with the specified handle. The loader result code i
s returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a constant, a constant expression, or a variable. The type of the value parameter determines the number of bytes of data written.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Write(handle, value, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 WriteLn(handle, value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Write a numeric value to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value p
arameter must be a constant, a constant expression, or a variable. The type of the value parameter determines the number of bytes of data written. The WriteLn function also writes a carriage return and a line feed to the file following the numeric data.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {WriteLn(handle, value, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 WriteString(handle, str, out count, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Write the string to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a va
riable. The count parameter must be a variable. The str parameter must be a string variable or string constant. The actual number of bytes written is returned in the count parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {WriteString(handle, 'testing', count, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 WriteLnString(handle, str, out count, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Write the string to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The count parameter must be a variable. The st
r parameter must be a string variable or string constant. This function also writes a carriage return and a line feed to the file following the string data. The total number of bytes written is returned in the count parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {WriteLnString(handle, 'testing', count, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 WriteBytes(handle, data, out count, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Write the contents of the data array to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter mu
st be a variable. The count parameter must be a variable. The data parameter must be an array. The actual number of bytes written is returned in the count parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {WriteBytes(handle, buffer, count, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 WriteBytesEx(handle, in/out length, buf, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Write the specified number of bytes to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The length parameter must be a variable. The 
buf parameter must be an array or a string variable or string constant. The actual number of bytes written is returned in the length parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {WriteBytesEx(handle, len, buffer, result)
\par }\pard\plain \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 \page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_LoaderIOMapOffsets}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Loader Module IOMap Offsets}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  loader module iomap offsets}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.7.1 IOMap Offsets
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx3348\tx4677\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Loader Module Offsets\tab Function\tab Size
\par }\pard \s18\ql \li0\ri0\widctlpar\tx3348\tx4677\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 LoaderOffsetPFunc\tab 0\tab 4
\par LoaderOffsetFreeUserFlash\tab 4\tab 4
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Command}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Command Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K
}{\f1  command module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.8 Command Module
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
The NXT command module encompasses support for the execution of user programs via the NXT virtual machine. It also implements the direct command protocol support that enables the NXT to re
spond to USB or Bluetooth requests from other devices such as a PC or another NXT brick.
\par }\pard \ql \li1440\ri0\sb120\widctlpar\tx3960\faauto\adjustright\rin0\lin1440\itap0 {\b\f1 Module Constants\tab Value
\par }\pard \ql \li1440\ri0\widctlpar\tx3960\faauto\adjustright\rin0\lin1440\itap0 {\f1 CommandModuleName\tab "Command.mod"
\par CommandModuleID\tab 0x00010001
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 \page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_CommandIOMapOffsets}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Command Module IOMap Offsets}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  command module iomap offsets}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.8.1 IOMap Offsets
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx3348\tx4338\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Command Module Offsets\tab Function\tab Size
\par }\pard \s18\ql \li0\ri0\widctlpar\tx3348\tx4338\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 CommandOffsetFormatString\tab 0\tab 16
\par CommandOffsetPRCHandler\tab 16\tab 4
\par CommandOffsetTick\tab 20\tab 4
\par CommandOffsetOffsetDS\tab 24\tab 2
\par CommandOffsetOffsetDVA\tab 26\tab 2
\par CommandOffsetProgStatus\tab 28\tab 1
\par CommandOffsetAwake\tab 29\tab 1
\par CommandOffsetActivateFlag\tab 30\tab 1
\par CommandOffsetDeactivateFlag\tab 31\tab 1
\par CommandOffsetFileName\tab 32\tab 20
\par CommandOffsetMemoryPool\tab 52\tab 32k
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Button}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Button Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}
{\f1  button module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.9 Button Module
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT button module encompasses support for the 4 buttons on the NXT brick. 
\par }\pard \ql \li1440\ri0\sb120\widctlpar\tx3960\faauto\adjustright\rin0\lin1440\itap0 {\b\f1 Module Constants\tab Value
\par }\pard \ql \li1440\ri0\widctlpar\tx3960\faauto\adjustright\rin0\lin1440\itap0 {\f1 ButtonModuleName\tab "Button.mod"
\par ButtonModuleID\tab 0x00040001
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_ButtonHighLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Button Module High-level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  button module high-level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.9.1 High-level Functions
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Valid button constant values are listed in the following table.
\par }\pard \ql \li1440\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin1440\itap0 {\b\f1 Button Constants\tab Value
\par }\pard \ql \li1440\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin1440\itap0 {\f1 BTN1, BTNEXIT\tab 0
\par BTN2, BTNRIGHT\tab 1
\par BTN3, BTNLEFT\tab 2
\par BTN4, BTNCENTER\tab 3
\par NO_OF_BTNS\tab 4
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadButtonEx(btn, reset, out pressed, out count, out result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Read the specified button. 
Set the pressed and count parameters with the current state of the button. Optionally reset the press count after reading it. Valid values for the btn argument are listed in }{\field\fldedit{\*\fldinst {\f1  REF _Ref162429493 \\h }{\f1 {\*\datafield 
08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0052006500660031003600320034003200390034003900330000000000001f00}}}{\fldrslt {\f1 Table }{\f1\lang1024\langfe1024\noproof 41}}}{\f1 .
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadButtonEx(BTN1, true, pressed, count, result)
\par }\pard\plain \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_ButtonLowLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Button Module Low-level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  button module low-level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.9.2 Low-level Functions
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Valid button state values are listed in the following table.
\par }\pard \ql \li1440\ri0\sb120\widctlpar\tx5040\faauto\adjustright\rin0\lin1440\itap0 {\b\f1 Button State Constants\tab Value
\par }\pard \ql \li1440\ri0\widctlpar\tx5040\faauto\adjustright\rin0\lin1440\itap0 {\f1 BTNSTATE_PRESSED_EV\tab 0x01
\par BTNSTATE_SHORT_RELEASED_EV\tab 0x02
\par BTNSTATE_LONG_PRESSED_EV\tab 0x04
\par BTNSTATE_LONG_RELEASED_EV\tab 0x08
\par BTNSTATE_PRESSED_STATE\tab 0x80
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Toc179361878}GetButtonPressCount(btn, out cnt)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the press count of the specified button. Valid values for the btn argument are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetButtonPressCount(BTN1, count)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetButtonLongPressCount(btn, out cnt)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the long pr
ess count of the specified button. Valid values for the btn argument are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetButtonLongPressCount(BTN1, count)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetButtonShortReleaseCount(btn, out cnt)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the short release count of the specified button. Valid values for the btn a
rgument are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetButtonShortReleaseCount(BTN1, count)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetButtonLongReleaseCount(btn, out cnt)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the long release count of the specified button. Valid values for the btn argument are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetButtonLongReleaseCount(BTN1, count)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetButtonReleaseCount(btn, out cnt)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the release count of the specified button. Valid values for the btn argument are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetButtonReleaseCount(BTN1, count)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetButtonState(btn, out state)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the state of the specified button. Valid values for the btn argument are listed above.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetButtonState(BTN1, state)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 {\*\bkmkend _Toc179361878}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_ButtonIOMapOffsets}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Button Module IOMap Offsets}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  button module iomap offsets}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.9.3 IOMap Offsets
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx3348\tx4477\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Button Module Offsets\tab Function\tab Size
\par }\pard \s18\ql \li0\ri0\widctlpar\tx3348\tx4477\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 ButtonOffsetPressedCnt(b)\tab (((b)*8)+0)\tab 1
\par ButtonOffsetLongPressCnt(b)\tab (((b)*8)+1)\tab 1
\par ButtonOffsetShortRelCnt(b)\tab (((b)*8)+2)\tab 1
\par ButtonOffsetLongRelCnt(b)\tab (((b)*8)+3)\tab 1
\par ButtonOffsetRelCnt(b)\tab (((b)*8)+4)\tab 1
\par ButtonOffsetState(b)\tab ((b)+32)\tab 1*4
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_UserInterface}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  User Interface Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  user interface module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.10 UI Module
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT UI module encompasses support for various aspects of the user interface for the NXT brick.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Module Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx2880\faauto\adjustright\rin0\lin720\itap0 {\f1 UIModuleName\tab "Ui.mod"
\par UIModuleID\tab 0x000C0001
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid flag values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx5040\faauto\adjustright\rin0\lin720\itap0 {\b\f1 UI Flags Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx5040\faauto\adjustright\rin0\lin720\itap0 {\f1 UI_FLAGS_UPDATE\tab 0x01
\par UI_FLAGS_DISABLE_LEFT_RIGHT_ENTER\tab 0x02
\par UI_FLAGS_DISABLE_EXIT\tab 0x04
\par }{\f1\lang1030\langfe1033\langnp1030 UI_FLAGS_REDRAW_STATUS\tab 0x08
\par UI_FLAGS_RESET_SLEEP_TIMER\tab 0x10
\par }{\f1 UI_FLAGS_EXECUTE_LMS_FILE\tab 0x20
\par UI_FLAGS_BUSY\tab 0x40
\par UI_FLAGS_ENABLE_STATUS_UPDATE\tab 0x80
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid UI state values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 UI State Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 UI_STATE_INIT_DISPLAY\tab 0
\par UI_STATE_INIT_LOW_BATTERY\tab 1
\par UI_STATE_INIT_INTRO\tab 2
\par UI_STATE_INIT_WAIT\tab 3
\par UI_STATE_INIT_MENU\tab 4
\par UI_STATE_NEXT_MENU\tab 5
\par UI_STATE_DRAW_MENU\tab 6
\par UI_STATE_TEST_BUTTONS\tab 7
\par UI_STATE_LEFT_PRESSED\tab 8
\par UI_STATE_RIGHT_PRESSED\tab 9
\par UI_STATE_ENTER_PRESSED\tab 10
\par UI_STATE_EXIT_PRESSED\tab 11
\par UI_STATE_CONNECT_REQUEST\tab 12
\par UI_STATE_EXECUTE_FILE\tab 13
\par UI_STATE_EXECUTING_FILE\tab 14
\par UI_STATE_LOW_BATTERY\tab 15
\par UI_STATE_BT_ERROR\tab 16
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid UI button values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 UI Button Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 UI_BUTTON_NONE\tab 1
\par UI_BUTTON_LEFT\tab 2
\par UI_BUTTON_ENTER\tab 3
\par UI_BUTTON_RIGHT\tab 4
\par UI_BUTTON_EXIT\tab 5
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid UI Bluetooth state values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 UI Bluetooth State Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 UI_BT_STATE_VISIBLE\tab 0x01
\par UI_BT_STATE_CONNECTED\tab 0x02
\par UI_BT_STATE_OFF\tab 0x04
\par UI_BT_ERROR_ATTENTION\tab 0x08
\par UI_BT_CONNECT_REQUEST\tab 0x40
\par UI_BT_PIN_REQUEST\tab 0x80
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Toc179361880}GetVolume(out volume)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the user interface volume level. Valid values are from 0 to 4.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetVolume(vol)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetVolume(value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the user interface volume level. Valid values are from 0 to 4.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetVolume(3)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBatteryLevel(out blevel)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the battery level in millivolts.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBatteryLevel(blevel)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBluetoothState(out bstate)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the Bluetooth state. Valid Bluetooth state values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBluetoothState(bstate)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetBluetoothState(value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the Bluetooth state. Valid Bluetooth state values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetBluetoothState(UI_BT_STATE_OFF)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetCommandFlags(out flags)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the command flags. Valid command flag values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetCommandFlags(flags)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetCommandFlags(value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the command flags. Valid command flag values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {\lang1024\langfe1024\langnp1030 
SetCommandFlags(UI_FLAGS_REDRAW_STATUS)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUIState(out state)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the user interface state. Valid user interface state values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUIState(state)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUIState(value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the user interface state. Valid user interface state values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUIState(UI_STATE_LOW_BATTERY)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUIButton(out btn)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return user interface button information. Valid user interface button values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUIButton(btn)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUIButton(value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set user interface button information. Valid user interface button values are listed above.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUIButton(UI_BUTTON_ENTER)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetVMRunState(out state)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return VM run state information. 
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetVMRunState(state)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetVMRunState(value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set VM run state information.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetVMRunState(0) // stopped
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBatteryState(out state)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return battery state information (0..4). 
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBatteryState(state)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetRechargeableBattery(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return whether the NXT has a rechargeable battery installed or not. 
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetRechargeableBattery(rbat)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ForceOff(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Force the NXT to turn off if the specified value is greater than zero.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ForceOff(TRUE)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUsbState(out ustate)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return USB state information (0=disconnected, 1=connected, 2=working).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUsbState(ustate)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetOnBrickProgramPointer(out ptr)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the current OBP (on-brick program) step; 
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetOnBrickProgramPointer(ptr)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetOnBrickProgramPointer(value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Set the current OBP (on-brick program) step.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetOnBrickProgramPointer(2)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetLongAbort(out value)\tab Function (+)
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Return the enhanced NBC/NXC firmware's long abort setting (TRUE or FALSE). If set to true then a program has access the escape button. Aborting a program requires a long press of the escape button
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetLongAbort(value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetLongAbort(value)\tab Function (+)
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Set the enhanced NBC/NXC firmware's long abort setting (TRUE or FALSE). If set to true then a program has access the escape button. Aborting a program requires a long press of the escape button.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetLongAbort(TRUE)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 {\*\bkmkend _Toc179361880}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_UIIOMapOffsets}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  UI Module IOMap Offsets}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  ui module iomap offsets}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.10.1 IOMap Offsets
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx3348\tx4477\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 UI Module Offsets\tab Function\tab Size
\par }\pard \s18\ql \li0\ri0\widctlpar\tx3348\tx4477\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 UIOffsetPMenu\tab 0\tab 4
\par UIOffsetBatteryVoltage\tab 4\tab 2
\par UIOffsetLMSfilename\tab 6\tab 20
\par UIOffsetFlags\tab 26\tab 1
\par UIOffsetState\tab 27\tab 1
\par UIOffsetButton\tab 28\tab 1
\par UIOffsetRunState\tab 29\tab 1
\par UIOffsetBatteryState\tab 30\tab 1
\par UIOffsetBluetoothState\tab 31\tab 1
\par UIOffsetUsbState\tab 32\tab 1
\par UIOffsetSleepTimeout\tab 33\tab 1
\par UIOffsetSleepTimer\tab 34\tab 1
\par UIOffsetRechargeable\tab 35\tab 1
\par UIOffsetVolume\tab 36\tab 1
\par UIOffsetError\tab 37\tab 1
\par UIOffsetOBPPointer\tab 38\tab 1
\par UIOffsetForceOff\tab 39\tab 1
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {{\*\bkmkstart _Toc179361881}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_LowSpeed}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  LowSpeed Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super 
K}{\f1  lowspeed module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.11 LowSpeed Module
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT low speed module encompasses support for digital I2C sensor communication.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Module Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 LowSpeedModuleName\tab "Low Speed.mod"
\par LowSpeedModuleID\tab 0x000B0001
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 {\*\bkmkend _Toc179361881}Use the lowspeed (aka I2C) communication methods to access devices that use the I2C protocol on the NXT brick's four input ports.
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 
You must set the input port's Type property to IN_TYPE_LOWSPEED or IN_TYPE_LOWSPEED_9V on a given port before using an I2C device on that port. Use IN_TYPE_LOWSPEED_9V if your device requires 9V power from the NXT brick. Remember that you al
so need to set the input port's InvalidData property to true after setting a new Type, and then wait in a loop for the NXT firmware to set InvalidData back to false. This process ensures that the firmware has time to properly initialize the port, includin
g the 9V power lines, if applicable. Some digital devices might need additional time to initialize after power up.
\par The SetSensorLowspeed API function sets the specified port to IN_TYPE_LOWSPEED_9V and calls ResetSensor to perform the InvalidData reset loop described above.
\par When communicating with I2C devices, the NXT firmware uses a master/slave setup in which the NXT brick is always the master device. This means that the firmware is responsible for controlling the write and read operations. The NXT firmware
 maintains write and read buffers for each port, and the three main Lowspeed (I2C) methods described below enable you to access these buffers.
\par A call to LowspeedWrite starts an asynchronous transaction between the NXT brick and a digital I2C device. The pr
ogram continues to run while the firmware manages sending bytes from the write buffer and reading the response bytes from the device. Because the NXT is the master device, you must also specify the number of bytes to expect from the device in response to 
each write operation. You can exchange up to 16 bytes in each direction per transaction.
\par After you start a write transaction with LowspeedWrite, use LowspeedStatus in a loop to check the status of the port. If LowspeedStatus returns a status code of 0 and a
 count of bytes available in the read buffer, the system is ready for you to use LowspeedRead to copy the data from the read buffer into the buffer you provide.
\par Note that any of these calls might return various status codes at any time. A status code of 0 
means the port is idle and the last transaction (if any) did not result in any errors. Negative status codes and the positive status code 32 indicate errors. There are a few possible errors per call.
\par Valid low speed return values are listed in the following table.
\par }\pard \ql \fi-4320\li5040\ri0\sb120\widctlpar\tx4140\tx5040\faauto\adjustright\rin0\lin5040\itap0 {\b\f1 Low Speed Return Constants\tab Value\tab Meaning
\par }\pard \ql \fi-4320\li5040\ri0\widctlpar\tx4140\tx5040\faauto\adjustright\rin0\lin5040\itap0 {\f1 NO_ERR\tab 0\tab The operation succeeded.
\par STAT_COMM_PENDING\tab 32\tab The specified port is busy performing a communication transaction.
\par ERR_INVALID_SIZE\tab -19\tab The specified buffer or byte count exceeded the 16 byte limit.
\par ERR_COMM_CHAN_NOT_READY\tab -32\tab The specified port is busy or improperly configured.
\par ERR_COMM_CHAN_INVALID\tab -33\tab The specified port is invalid. It must be between 0 and 3.
\par ERR_COMM_BUS_ERR\tab -35\tab The last transaction failed, possibly due to a device failure.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_LowSpeedHighLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  LowSpeed Module High-level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  lowspeed module high-level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.11.1 High-level Functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 LowspeedWrite(port, returnlen, buffer, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method starts a transaction to write the bytes contained in the array buffer to the I2C device on the specified port. It also tells the I2C device the number of byt
es that should be included in the response. The maximum number of bytes that can be written or read is 16. The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{
\cs19\f6\fs22 IN_4}{\f1 ) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads. Lowspeed return values are listed above.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {LowspeedWrite(IN_1, 1, inbuffer, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 LowspeedStatus(port, out bytesready, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method checks the status of the I2C com
munication on the specified port. If the last operation on this port was a successful LowspeedWrite call that requested response data from the device then bytesready will be set to the number of bytes in the internal read buffer. The port may be specified
 using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 
) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads. Lowspeed return values are listed above. If the return value 
is 0 then the last operation did not cause any errors. Avoid calls to LowspeedRead or LowspeedWrite while LowspeedStatus returns }{\f2\fs20 STAT_COMM_PENDING}{\f1 .
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {LowspeedStatus(IN_1, nRead, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 LowspeedCheckStatus(port, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method checks the st
atus of the I2C communication on the specified port. The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 
) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running 
on other threads. Lowspeed return values are listed above. If the return value is 0 then the last operation did not cause any errors. Avoid calls to LowspeedRead or LowspeedWrite while LowspeedStatus returns }{\f2\fs20 STAT_COMM_PENDING}{\f1 .
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {LowspeedCheckStatus(IN_1, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 LowspeedBytesReady(port, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method checks the status of the I2C communication on the specified port. If the last operation on this port was a successful LowspeedWrite call that requested response data from the device then the re
turn value will be the number of bytes in the internal read buffer. The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 
) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {LowspeedBytesReady(IN_1, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 LowspeedRead(port, buflen, out buffer, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read the specified number of bytes from the I2C device on the specified port and store the bytes read in the array buffer provided. The maximum number of bytes that can be written or read is 16. The port may be specified using a constant (e.g., }{
\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 ) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by c
ode running on other threads. Lowspeed return values are listed above. If the return value is negative then the output buffer will be empty.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {LowspeedRead(IN_1, 1, outbuffer, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadI2CBytes(port, inbuf, in/out count, out outbuf, out result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 T
his method writes the bytes contained in the input buffer (inbuf) to the I2C device on the specified port, checks for the specified number of bytes to be ready for reading, and then tries to read the specified number (count) of bytes from the I2C device i
nto the output buffer (outbuf). The port may be specified using a constant (e.g., }{\cs19\f6\fs22 IN_1}{\f1 , }{\cs19\f6\fs22 IN_2}{\f1 , }{\cs19\f6\fs22 IN_3}{\f1 , or }{\cs19\f6\fs22 IN_4}{\f1 
) or a variable. Returns true or false indicating whether the I2C read process succeeded or failed.
\par This is a higher-level wrapper around the three main I2C functions. It also maintains a "last good read" buffer and returns values from that buffer if the I2C communication transaction fails.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadI2CBytes(IN_4, writebuf, cnt, readbuf, result)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_LowSpeedLowLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  LowSpeed Module Low-level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  lowspeed module low-level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.11.2 Low-level Functions
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Valid low speed state values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Low Speed State Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 COM_CHANNEL_NONE_ACTIVE\tab 0x00
\par COM_CHANNEL_ONE_ACTIVE\tab 0x01
\par COM_CHANNEL_TWO_ACTIVE\tab 0x02
\par COM_CHANNEL_THREE_ACTIVE\tab 0x04
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid low speed channel state values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Low Speed Channel State Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 LOWSPEED_IDLE\tab 0
\par LOWSPEED_INIT\tab 1
\par LOWSPEED_LOAD_BUFFER\tab 2
\par LOWSPEED_COMMUNICATING\tab 3
\par LOWSPEED_ERROR\tab 4
\par LOWSPEED_DONE\tab 5
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid low speed mode values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Low Speed Mode Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 LOWSPEED_TRANSMITTING\tab 1
\par LOWSPEED_RECEIVING\tab 2
\par LOWSPEED_DATA_RECEIVED\tab 3
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid low speed error type values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Low Speed Error Type Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4320\faauto\adjustright\rin0\lin720\itap0 {\f1 LOWSPEED_NO_ERROR\tab 0
\par LOWSPEED_CH_NOT_READY\tab 1
\par LOWSPEED_TX_ERROR\tab 2
\par LOWSPEED_RX_ERROR\tab 3
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 {\*\bkmkstart _Toc179361884}GetLSMode(port, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the mode of the lowspeed communication over the specified port. The port must be a constant (IN_1..IN_4).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetLSMode(IN_1, mode)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetLSChannelState(port, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the channel sta
te of the lowspeed communication over the specified port. The port must be a constant (IN_1..IN_4).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetLSChannelState(IN_1, cstate)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetLSErrorType(port, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the error type of the lowspeed communication over the specifie
d port. The port must be a constant (IN_1..IN_4).
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetLSErrorType(IN_1, errtype)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetLSState(out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the state of the lowspeed module.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetLSState(state)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetLSSpeed(out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the speed of the lowspeed module.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetLSSpeed(speed)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 {\*\bkmkend _Toc179361884}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_LowSpeedIOMapOffsets}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  LowSpeed Module IOMap Offsets}}K{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  lowspeed module iomap offsets}}+{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.11.3 IOMap Offsets
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx3600\tx5040\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 LowSpeed Module Offsets\tab Value\tab Size
\par }\pard \s18\ql \li0\ri0\widctlpar\tx3600\tx5040\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 LowSpeedOffsetInBufBuf(p)\tab (((p)*19)+0)\tab 16
\par LowSpeedOffsetInBufInPtr(p)\tab (((p)*19)+16)\tab 1
\par LowSpeedOffsetInBufOutPtr(p)\tab (((p)*19)+17)\tab 1
\par LowSpeedOffsetInBufBytesToRx(p)\tab (((p)*19)+18)\tab 58
\par LowSpeedOffsetOutBufBuf(p)\tab (((p)*19)+76)\tab 16
\par LowSpeedOffsetOutBufInPtr(p)\tab (((p)*19)+92)\tab 1
\par LowSpeedOffsetOutBufOutPtr(p)\tab (((p)*19)+93)\tab 1
\par LowSpeedOffsetOutBufBytesToRx(p)\tab (((p)*19)+94)\tab 58
\par LowSpeedOffsetMode(p)\tab ((p)+152)\tab 4
\par LowSpeedOffsetChannelState(p)\tab ((p)+156)\tab 4
\par LowSpeedOffsetErrorType(p)\tab ((p)+160)\tab 4
\par LowSpeedOffsetState\tab 164\tab 1
\par LowSpeedOffsetSpeed\tab 165\tab 1
\par LowSpeedOffsetSpare\tab 166\tab 1
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {{\*\bkmkstart _Toc179361885}\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Comm}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Comm Module}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{
\f1  comm module}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.12 Comm Module
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 The NXT comm module encompasses support for all forms of Bluetooth, USB, and HiSpeed communication.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Module Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 CommModuleName\tab "Comm.mod"
\par CommModuleID\tab 0x00050001
\par }\pard \ql \li0\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 {\f1 {\*\bkmkend _Toc179361885}
You can use the Bluetooth communication methods to send information to other devices connected to the NXT brick. The NXT firmware also implements a message queuing or mailbox system which you can access using these methods.
\par Communication via Bluetooth uses a master/slave connection system. One device must be designated as the master device before you run a program using Bluetooth. If the NXT is the master device then you can confi
gure up to three slave devices using connection 1, 2, and 3 on the NXT brick. If your NXT is a slave device then connection 0 on the brick must be reserved for the master device.
\par Programs running on the master NXT brick can send packets of data to any conn
ected slave devices using the BluetoothWrite method. Slave devices write response packets to the message queuing system where they wait for the master device to poll for the response.
\par Using the direct command protocol, a master device can send messages to 
slave NXT bricks in the form of text strings addressed to a particular mailbox. Each mailbox on the slave NXT brick is a circular message queue holding up to five messages. Each message can be up to 58 bytes long.
\par To send messages from a master NXT brick t
o a slave brick, use BluetoothWrite on the master brick to send a MessageWrite direct command packet to the slave. Then, you can use ReceiveMessage on the slave brick to read the message. The slave NXT brick must be running a program when an incoming mess
age packet is received. Otherwise, the slave NXT brick ignores the message and the message is dropped.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_CommHighLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Comm Module High-level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  comm module high-level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.12.1 High-level Functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SendRemoteBool(connection, queue, bvalue, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sends a boolean value to the device on the spe
cified connection. The message containing the boolean value will be written to the specified queue on the remote brick.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SendRemoteBool(1, queue, false, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SendRemoteNumber(connection, queue, value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sends a numeric valu
e to the device on the specified connection. The message containing the numeric value will be written to the specified queue on the remote brick.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SendRemoteNumber(1, queue, 123, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SendRemoteString(connection, queue, strval, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This 
method sends a string value to the device on the specified connection. The message containing the string value will be written to the specified queue on the remote brick.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SendRemoteString(1, queue, 'hello world', result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SendResponseBool(queue, bvalue, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a boolean value as a response to a received message. The message containing the boolean value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SendResponseBool(queue, false, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SendResponseNumber(queue, value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a numeric value as a response to a received message. The message containing the numeric value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SendResponseNumber(queue, 123, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SendResponseString(queue, strval, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sends a string value as a response to a received message.
 The message containing the string value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SendResponseString(queue, 'hello world', result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReceiveRemoteBool(queue, remove, out bvalue, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method is used on a master brick to receive a boolean value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the v
alue of the boolean remove parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReceiveRemoteBool(queue, true, bvalue, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReceiveRemoteNumber(queue, remove, out value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method is used on a master brick to receive a numeric value from a slave device communicating via a
 specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReceiveRemoteBool(queue, true, value, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReceiveRemoteString(queue, remove, out strval, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method is used on a master brick to receive a string value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean rem
ove parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReceiveRemoteString(queue, true, strval, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
ReceiveRemoteMessageEx(queue, remove, out strval, out val, out bval, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method is used on a master brick to receive a string, boolean, or numeric value from a slave devi
ce communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {
ReceiveRemoteMessageEx(queue, true, strval, val, bval, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SendMessage(queue, msg, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method writes the message buffer contents to the specified mailbox or message queue. The maximum message length is 58 bytes.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SendMessage(mbox, data, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReceiveMessage(queue, remove, out buffer, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Th
is method retrieves a message from the specified queue and writes it to the buffer provided. Optionally removes the last read message from the message queue depending on the value of the boolean remove parameter.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RecieveMessage(mbox, true, buffer, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 BluetoothStatus(connection, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the status of the specified Bluetooth connection. Avoid calling BluetoothWrite or any other API function that writes data over a Bluetooth connection while BluetoothStatus returns }{\f2\fs20 STAT_COMM_PENDING}{\f1 .
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {BluetoothStatus(1, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 BluetoothWrite(connection, buffer, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method tells the NXT firmware to write the data in the buffer to the device on the specified Bluetooth connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {BluetoothWrite(1, data, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteMessageRead(connection, queue, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a MessageRead direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteMessageRead(1, 5, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteMessageWrite(connection, queue, msg, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a MessageWrite direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteMessageWrite(1, 5, 'test', result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteStartProgram(connection, filename, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a StartProgram direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteStartProgram(1, 'myprog.rxe', result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteStopProgram(connection, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a StopProgram direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteStopProgram(1, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemotePlaySoundFile(connection, filename, bLoop, out result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a PlaySoundFile direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemotePlaySoundFile(1, 'click.rso', false, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemotePlayTone(connection, frequency, duration, out result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a PlayTone direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemotePlayTone(1, 440, 1000, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteStopSound(connection, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a StopSound direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteStopSound(1, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteKeepAlive(connection, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a KeepAlive direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteKeepAlive(1, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteResetScaledValue(connection, port, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a ResetScaledValue direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteResetScaledValue(1, IN_1, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteResetMotorPosition(connection, port, bRelative, out result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a ResetMotorPosition direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteResetMotorPosition(1, OUT_A, true, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteSetInputMode(connection, port, type, mode, out result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sends a SetInputMode direct command to the device on the specified 
connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {RemoteSetInputMode(1, IN_1, \line 
  IN_TYPE_LOWSPEED, IN_MODE_RAW, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
RemoteSetOutputState(connection, port, speed, mode, regmode, turnpct, runstate, tacholimit, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method sends a SetOutputState direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.
\par }\pard\plain \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 RemoteSetOutputState(1, OUT_A, 75, OUT_MODE_MOTORON,\line   OUT_REGMODE_IDLE, 0, OUT_RU
NSTATE_RUNNING, 0, result)}{\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_CommLowLevel}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Comm Module Low-level Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
{\cs16\f1\super K}{\f1  comm module low-level functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 
3.12.2 Low-level Functions
\par }\pard\plain \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Valid miscellaneous constant values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4680\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Comm Miscellaneous Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4680\faauto\adjustright\rin0\lin720\itap0 {\f1 SIZE_OF_USBBUF\tab 64
\par USB_PROTOCOL_OVERHEAD\tab 2
\par SIZE_OF_USBDATA\tab 62
\par SIZE_OF_HSBUF\tab 128
\par SIZE_OF_BTBUF\tab 128
\par BT_CMD_BYTE\tab 1
\par SIZE_OF_BT_DEVICE_TABLE\tab 30
\par SIZE_OF_BT_CONNECT_TABLE\tab 4
\par SIZE_OF_BT_NAME\tab 16
\par SIZE_OF_BRICK_NAME\tab 8
\par SIZE_OF_CLASS_OF_DEVICE\tab 4
\par SIZE_OF_BDADDR\tab 7
\par MAX_BT_MSG_SIZE\tab 60000
\par BT_DEFAULT_INQUIRY_MAX\tab 0
\par BT_DEFAULT_INQUIRY_TIMEOUT_LO\tab 15
\par LR_SUCCESS\tab 0x50
\par LR_COULD_NOT_SAVE\tab 0x51
\par LR_STORE_IS_FULL\tab 0x52
\par LR_ENTRY_REMOVED\tab 0x53
\par LR_UNKNOWN_ADDR\tab 0x54
\par USB_CMD_READY\tab 0x01
\par BT_CMD_READY\tab 0x02
\par HS_CMD_READY\tab 0x04
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid BtState values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Comm BtState Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx3600\faauto\adjustright\rin0\lin720\itap0 {\f1 BT_ARM_OFF\tab 0
\par BT_ARM_CMD_MODE\tab 1
\par BT_ARM_DATA_MODE\tab 2
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid BtStateStatus values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Comm BtStateStatus Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\f1 BT_BRICK_VISIBILITY\tab 0x01
\par BT_BRICK_PORT_OPEN\tab 0x02
\par BT_CONNECTION_0_ENABLE\tab 0x10
\par BT_CONNECTION_1_ENABLE\tab 0x20
\par BT_CONNECTION_2_ENABLE\tab 0x40
\par BT_CONNECTION_3_ENABLE\tab 0x80
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid BtHwStatus values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Comm BtHwStatus Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\f1 BT_ENABLE\tab 0x00
\par BT_DISABLE\tab 0x01
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid HsFlags values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Comm HsFlags Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\f1 HS_UPDATE\tab 1
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid HsState values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Comm HsState Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\f1 HS_INITIALISE\tab 1
\par HS_INIT_RECEIVER\tab 2
\par HS_SEND_DATA\tab 3
\par HS_DISABLE\tab 4
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid DeviceStatus values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Comm DeviceStatus Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\f1 BT_DEVICE_EMPTY\tab 0x00
\par BT_DEVICE_UNKNOWN\tab 0x01
\par BT_DEVICE_KNOWN\tab 0x02
\par BT_DEVICE_NAME\tab 0x40
\par BT_DEVICE_AWAY\tab 0x80
\par }\pard \ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1 Valid module interface values are listed in the following table.
\par }\pard \ql \li720\ri0\sb120\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\b\f1 Comm Module Interface Constants\tab Value
\par }\pard \ql \li720\ri0\widctlpar\tx4140\faauto\adjustright\rin0\lin720\itap0 {\f1 INTF_SENDFILE\tab 0
\par INTF_SEARCH\tab 1
\par INTF_STOPSEARCH\tab 2
\par INTF_CONNECT\tab 3
\par INTF_DISCONNECT\tab 4
\par INTF_DISCONNECTALL\tab 5
\par INTF_REMOVEDEVICE\tab 6
\par INTF_VISIBILITY\tab 7
\par INTF_SETCMDMODE\tab 8
\par INTF_OPENSTREAM\tab 9
\par INTF_SENDDATA\tab 10
\par INTF_FACTORYRESET\tab 11
\par INTF_BTON\tab 12
\par INTF_BTOFF\tab 13
\par INTF_SETBTNAME\tab 14
\par INTF_EXTREAD\tab 15
\par INTF_PINREQ\tab 16
\par INTF_CONNECTREQ\tab 17
\par }\pard\plain \s4\ql \fi-864\li864\ri0\sb240\sa60\widctlpar\jclisttab\tx864\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin864\itap0 \b\i\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 \page }{\cs16\f1\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_CommUSB}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Comm Module USB Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  comm module usb functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\f1 3.12.2.1 USB functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBInputBuffer(offset, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method reads count bytes of data from the USB input buffer at the specified offset and writes it to the buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBInputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBInputBuffer(offset, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method writes count bytes of data to the USB input buffer at the specified offset.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBInputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBInputBufferInPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the input pointer of the USB input buffer to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBInputBufferInPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBInputBufferInPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the input pointer of the USB input buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBInputBufferInPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBInputBufferOutPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the output pointer of the USB input buffer to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBInputBufferOutPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBInputBufferOutPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the output pointer of the USB input buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBInputBufferOutPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBOutputBuffer(offset, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Thi
s method reads count bytes of data from the USB output buffer at the specified offset and writes it to the buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBOutputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBOutputBuffer(offset, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method writes count bytes of data to the USB output buffer at the specified offset.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBOutputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBOutputBufferInPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the input pointer of the USB output buffer to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBOutputBufferInPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBOutputBufferInPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the input pointer of the USB output buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBOutputBufferInPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBOutputBufferOutPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the output pointer of the USB output buffer to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBOutputBufferOutPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBOutputBufferOutPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the output pointer of the USB output buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBOutputBufferOutPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBPollBuffer(offset, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method reads count bytes of data from the 
USB poll buffer and writes it to the buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBPollBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBPollBuffer(offset, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method writes count bytes of data to the USB poll buffer at the specified offset.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBPollBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBPollBufferInPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the input pointer of the USB poll buffer to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBPollBufferInPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBPollBufferInPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the input pointer of the USB poll buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBPollBufferInPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBPollBufferOutPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the output pointer of the USB poll buffer to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBPollBufferOutPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBPollBufferOutPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the output pointer of the USB poll buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBPollBufferOutPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetUSBState(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the USB state to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetUSBState(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetUSBState(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the USB state.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetUSBPollBufferOutPtr(x)
\par }\pard\plain \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 
\par }\pard\plain \s4\ql \fi-864\li864\ri0\sb240\sa60\widctlpar\jclisttab\tx864\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin864\itap0 \b\i\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 \page }{\cs16\f1\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_CommHS}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Comm Module Hi-Speed Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  comm module hi-speed functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\f1 3.12.2.
2 Hi Speed port functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSInputBuffer(offset, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method reads count bytes of data from the High Speed input buffer and writes it to the buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetHSInputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSInputBuffer(offset, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method writes count bytes of data to the High Speed input buffer at the specified offset.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSInputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSInputBufferInPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the input pointer of the High Speed input buffer to the specified value.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSInputBufferInPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSInputBufferInPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the input pointer of the High Speed input buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetHSInputBufferInPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSInputBufferOutPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the output pointer of the High Speed input buffer to the specified value.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSInputBufferOutPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSInputBufferOutPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the output pointer of the High Speed input buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetHSInputBufferOutPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSOutputBuffer(offset, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method reads count bytes of data from the High Speed output buffer and writes it to the buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetHSOutputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSOutputBuffer(offset, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method writes count bytes of data to
 the High Speed output buffer at the specified offset.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSOutputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSOutputBufferInPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the input pointer of the High Speed output buffer to the specified value.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSOutputBufferInPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSOutputBufferInPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the input pointer of the High Speed output buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetHSOutputBufferInPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSOutputBufferOutPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the output pointer of the High Speed output buffer to the specified value.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSOutputBufferOutPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSOutputBufferOutPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the output pointer of the High Speed output buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetHSOutputBufferOutPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSFlags(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the High Speed flags to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSFlags(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSFlags(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the High Speed flags.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetHSFlags(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSSpeed(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the High Speed speed to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSSpeed(1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSSpeed(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the High Speed speed.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetHSSpeed(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetHSState(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the High Speed state to the specified value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetHSState(1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSState(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the High Speed state.
\par }\pard\plain \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetHSState(x)}{\f2 
\par }\pard\plain \s4\ql \fi-864\li864\ri0\sb240\sa60\widctlpar\jclisttab\tx864\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin864\itap0 \b\i\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 \page }{\cs16\f1\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_CommBT}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Comm Module Bluetooth Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
{\cs16\f1\super K}{\f1  comm module bluetooth functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\f1 
3.12.2.2 Bluetooth functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTInputBuffer(offset, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method reads count bytes of data from the Bluetooth input buffer and writes it to the buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTInputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetBTInputBuffer(offset, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method writes count bytes of data to the Bluetooth input buffer at the specified offset.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetBTInputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetBTInputBufferInPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the input pointer of the Bluetooth input buffer to the specified value.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetBTInputBufferInPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTInputBufferInPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the input pointer of the Bluetooth input buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTInputBufferInPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetBTInputBufferOutPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the output pointer of the Bluetooth input buffer to the specified value.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetBTInputBufferOutPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTInputBufferOutPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the output pointer of the Bluetooth input buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTInputBufferOutPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTOutputBuffer(offset, count, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method reads count bytes of data from the Bluetooth output buffer and writes it to the buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTOutputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetBTOutputBuffer(offset, count, data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method writes 
count bytes of data to the Bluetooth output buffer at the specified offset.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetBTOutputBuffer(0, 10, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetBTOutputBufferInPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the input pointer of the Bluetooth output buffer to the specified value.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetBTOutputBufferInPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTOutputBufferInPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the input pointer of the Bluetooth output buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTOutputBufferInPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetBTOutputBufferOutPtr(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method sets the output pointer of the Bluetooth output buffer to the specified value.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetBTOutputBufferOutPtr(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTOutputBufferOutPtr(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the value of the output pointer of the Bluetooth output buffer.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTOutputBufferOutPtr(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTDeviceCount(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the number of devices defined within the Bluetooth device table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTDeviceCount(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTDeviceNameCount(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the number of device names defined within the Bluetooth device table. This usually has the same value as GetBTDeviceCount but it can differ in some instances.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTDeviceNameCount(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTDeviceName(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the name of the device at the specified index in the Bluetooth device table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTDeviceName(0, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTConnectionName(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the name of the device at the specified index in the Bluetooth connection table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTConnectionName(0, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTConnectionPinCode(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the pin code of the device at
 the specified index in the Bluetooth connection table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTConnectionPinCode(0, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBrickDataName(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the name of the NXT.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBrickDataName(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTDeviceAddress(idx, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method reads the address 
of the device at the specified index within the Bluetooth device table and stores it in the data buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTDeviceAddress(0, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTConnectionAddress(idx, out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method reads the address of the device at the specified inde
x within the Bluetooth connection table and stores it in the data buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTConnectionAddress(0, buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBrickDataAddress(out data)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method reads the address of the NXT and stores it in the data buffer provided.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBrickDataAddress(buffer)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTDeviceClass(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the class of the device at the specified index within the Bluetooth device table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTDeviceClass(idx, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTDeviceStatus(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the status o
f the device at the specified index within the Bluetooth device table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTDeviceStatus(idx, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTConnectionClass(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the class of the device at the specified index within the Bluetooth connection table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTConnectionClass(idx, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTConnectionHandleNum(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the handle number of the device at the specified index within the Bluetooth connection table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTConnectionHandleNum(idx, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTConnectionStreamStatus(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
This method returns the stream status of the device at the specified index within the Bluetooth connection table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTConnectionStreamStatus(idx, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBTConnectionLinkQuality(idx, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the link quality o
f the device at the specified index within the Bluetooth connection table.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBTConnectionLinkQuality(idx, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBrickDataBluecoreVersion(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the bluecore version of the NXT.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBrickDataBluecoreVersion(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBrickDataBtStateStatus(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the Bluetooth state status of the NXT.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBrickDataBtStateStatus(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBrickDataBtHardwareStatus(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the Bluetooth hardware status of the NXT.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {GetBrickDataBtHardwareStatus(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBrickDataTimeoutValue(out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 This method returns the timeout value of the NXT.
\par }\pard\plain \ql \li720\ri0\sb120\widctlpar\tqr\tx8640\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 GetBrickDataTimeoutValue(x)}{\f2 
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0 \page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_CommIOMapOffsets}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Comm Module IOMap Offsets}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  comm module iomap offsets}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{\cs43 3.12.3 IOMap Offsets
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\tx4247\tx5676\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1 Comm Module Offsets\tab Function\tab Size
\par }\pard \s18\ql \li0\ri0\widctlpar\tx4247\tx5676\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f1\fs20 CommOffsetPFunc\tab 0\tab 4
\par CommOffsetPFuncTwo\tab 4\tab 4
\par CommOffsetBtDeviceTableName(p)\tab (((p)*31)+8)\tab 16
\par CommOffsetBtDeviceTableClassOfDevice(p)\tab (((p)*31)+24)\tab 4
\par CommOffsetBtDeviceTableBdAddr(p)\tab (((p)*31)+28)\tab 7
\par CommOffsetBtDeviceTableDeviceStatus(p)\tab (((p)*31)+35)\tab 1
\par CommOffsetBtConnectTableName(p)\tab (((p)*47)+938)\tab 16
\par CommOffsetBtConnectTableClassOfDevice (p)\tab (((p)*47)+954)\tab 4
\par CommOffsetBtConnectTablePinCode(p)\tab (((p)*47)+958)\tab 16
\par CommOffsetBtConnectTableBdAddr(p)\tab (((p)*47)+974)\tab 7
\par CommOffsetBtConnectTableHandleNr(p)\tab (((p)*47)+981)\tab 1
\par CommOffsetBtConnectTableStreamStatus(p)\tab (((p)*47)+982)\tab 1
\par CommOffsetBtConnectTableLinkQuality(p)\tab (((p)*47)+983)\tab 1
\par CommOffsetBrickDataName\tab 1126\tab 16
\par CommOffsetBrickDataBluecoreVersion\tab 1142\tab 2
\par CommOffsetBrickDataBdAddr\tab 1144\tab 7
\par CommOffsetBrickDataBtStateStatus\tab 1151\tab 1
\par CommOffsetBrickDataBtHwStatus\tab 1152\tab 1
\par CommOffsetBrickDataTimeOutValue\tab 1153\tab 1
\par CommOffsetBtInBufBuf\tab 1157\tab 128
\par CommOffsetBtInBufInPtr\tab 1285\tab 1
\par CommOffsetBtInBufOutPtr\tab 1286\tab 1
\par CommOffsetBtOutBufBuf\tab 1289\tab 128
\par CommOffsetBtOutBufInPtr\tab 1417\tab 1
\par CommOffsetBtOutBufOutPtr\tab 1418\tab 1
\par CommOffsetHsInBufBuf\tab 1421\tab 128
\par CommOffsetHsInBufInPtr\tab 1549\tab 1
\par CommOffsetHsInBufOutPtr\tab 1550\tab 1
\par CommOffsetHsOutBufBuf\tab 1553\tab 128
\par CommOffsetHsOutBufInPtr\tab 1681\tab 1
\par CommOffsetHsOutBufOutPtr\tab 1682\tab 1
\par CommOffsetUsbInBufBuf\tab 1685\tab 64
\par CommOffsetUsbInBufInPtr\tab 1749\tab 1
\par CommOffsetUsbInBufOutPtr\tab 1750\tab 1
\par CommOffsetUsbOutBufBuf\tab 1753\tab 64
\par CommOffsetUsbOutBufInPtr\tab 1817\tab 1
\par CommOffsetUsbOutBufOutPtr\tab 1818\tab 1
\par CommOffsetUsbPollBufBuf\tab 1821\tab 64
\par CommOffsetUsbPollBufInPtr\tab 1885\tab 1
\par CommOffsetUsbPollBufOutPtr\tab 1886\tab 1
\par CommOffsetBtDeviceCnt\tab 1889\tab 1
\par CommOffsetBtDeviceNameCnt\tab 1890\tab 1
\par CommOffsetHsFlags\tab 1891\tab 1
\par CommOffsetHsSpeed\tab 1892\tab 1
\par CommOffsetHsState\tab 1893\tab 1
\par CommOffsetUsbState\tab 1894\tab 1
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\page }{\cs16\super #{\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_HiTechnic}}${\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  HiTechnic API Functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super K}{\f1  hitechnic api functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super +}{\f1  cc}}}{3.13 HiTechnic API Functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 SetSensorHTGyro(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Configure the sensor on the specified port as a HiTechnic Gyro sensor.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {SetSensorHTGyro(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTGyro(port, offset, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read the HiTechnic Gyro sensor on the specified port. The offset value should be calculated by averaging several readings with an offset of zero while the sensor is perfectly still.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorHTGyro(IN_1, gyroOffset, value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTCompass(port, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Read the compass heading value of the HiTechnic Compass sensor on the specified port.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorHTCompass(IN_1, value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTColorNum(port, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Read the color number from the HiTechnic Color sensor on the specified port.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorHTColorNum(IN_1, value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTIRSeekerDir(port, out value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Read the direction value of the HiTechnic IR Seeker on the specified port.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorHTIRSeekerDir(IN_1, value)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTAccel(port, x, y, z, result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read X, Y, and Z axis acceleration values from the HiTechnic Accelerometer sensor. Returns a boolean value indicating whether or not the operation completed successfully.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorHTAccel(IN_1, x, y, z, bVal)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTColor(port, ColorNum, Red, Green, Blue, result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read color number, red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorHTColor(IN_1, c, r, g, b, bVal)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTRawColor(port, Red, Green, Blue, result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read the raw red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorHTRawColor(IN_1, r, g, b, bVal)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTNormalizedColor(port, ColorIdx, Red, Green, Blue, result)\tab 
Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read color index and the normalized red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorHTNormalizedColor(IN_1, c, r, g, b, bVal)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorHTIRSeeker(port, dir, IN_1, IN_3, s5, s7, s9, result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read direction, and five signal strength values from the HiTechnic IRSeeker sensor. Returns a boolean value indicating whether or not the operation completed successfully.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {
ReadSensorHTIRSeeker(port, dir, IN_1, IN_3, s5, s7, s9, bVal)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTPowerFunctionCommand(port, ch, cmd1, cmd2, result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Execute a pair of Power Function motor commands on the specified channel using th
e HiTechnic iRLink device. Commands are HTPF_CMD_STOP, HTPF_CMD_REV, HTPF_CMD_FWD, and HTPF_CMD_BRAKE. Valid channels are HTPF_CHANNEL_1 through HTPF_CHANNEL_4.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {
HTPowerFunctionCommand(IN_1, HTPF_CHANNEL_1, HTPF_CMD_STOP, HTPF_CMD_FWD, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetIRLinkPort(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Set the global port in advance of using the HTRCX* and HTScout* API functions for sending RCX and Scout messages over the HiTechnic iRLink device.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetIRLinkPort(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXPoll(src, value, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the Poll comman
d to an RCX to read a signed 2-byte value at the specified source and value combination.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXPoll(RCX_VariableSrc, 0, x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXBatteryLevel(out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the BatteryLevel command to an RCX to read the current battery level.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXBatteryLevel(x)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXPing()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the Ping command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXPing()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXDeleteTasks()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the DeleteTasks command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXDeleteTasks()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXStopAllTasks()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the StopAllTasks command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXStopAllTasks()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXPBTurnOff()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the PBTurnOff command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXPBTurnOff()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXDeleteSubs()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the DeleteSubs command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXDeleteSubs()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXClearSound()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the ClearSound command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXClearSound()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXClearMsg()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the ClearMsg command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXClearMsg()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXMuteSound()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the MuteSound command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXMuteSound()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXUnmuteSound()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the UnmuteSound command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXUnmuteSound()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXClearAllEvents()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the ClearAllEvents command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXClearAllEvents()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetOutput(outputs, mode)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetOutput command to an RCX to configure the mode of the specified outputs
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetOutput(RCX_OUT_A, RCX_OUT_ON)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetDirection(outputs, dir)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetDirection command to an RCX to configure the direction of the specified outputs.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetDirection(RCX_OUT_A, RCX_OUT_FWD)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetPower(outputs, pwrsrc, pwrval)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetPower command to an RCX to configure the power level of the specified outputs.

\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetPower(RCX_OUT_A, RCX_ConstantSrc, RCX_OUT_FULL)

\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXOn(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send commands to an RCX to turn on the specified outputs.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXOn(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXOff(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send commands to an RCX to turn off the specified outputs.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXOff(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXFloat(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send commands to an RCX to float the specified outputs.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXFloat(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXToggle(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send commands to an RCX to toggle the direction of the specified outputs.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXToggle(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXFwd(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send commands to an RCX to set the specified outputs to the forward direction.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXFwd(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXRev(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send commands to an RCX to set the specified outputs to the reverse direction.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXRev(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXOnFwd(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send commands to an RCX to turn on the specified outputs in the forward direction.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXOnFwd(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXOnRev(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send commands to an RCX to turn on the specified outputs in the reverse direction.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXOnRev(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXOnFor(outputs, duration)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Send commands to an RCX to turn on the specified outputs in the forward direction for the specified duration.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXOnFor(RCX_OUT_A, 100)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetTxPower(pwr)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetTxPower command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetTxPower(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXPlaySound(snd)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the PlaySound command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXPlaySound(RCX_SOUND_UP)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXDeleteTask(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the DeleteTask command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXDeleteTask(3)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXStartTask(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the StartTask command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXStartTask(2)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXStopTask(n)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the StopTask command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXStopTask(1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSelectProgram(prog)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SelectProgram command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSelectProgram(3)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXClearTimer(timer)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the ClearTimer command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXClearTimer(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetSleepTime(t)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetSleepTime command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetSleepTime(4)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXDeleteSub(s)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the DeleteSub command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXDeleteSub(2)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXClearSensor(port)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the ClearSensor command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXClearSensor(IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXPlayToneVar(varnum, duration)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the PlayToneVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXPlayToneVar(0, 50)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetWatch(hours, minutes)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetWatch command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetWatch(3, 30)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetSensorType(port, type)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetSensorType command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetSensorType(IN_1, IN_TYPE_SWITCH)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetSensorMode(port, mode)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetSensorMode command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetSensorMode(IN_1, IN_MODE_BOOLEAN)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXCreateDatalog(size)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the CreateDatalog command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXCreateDatalog(50)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXAddToDatalog(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the AddToDatalog command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXAddToDatalog(RCX_InputValueSrc, IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSendSerial(first, count)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SendSerial command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSendSerial(0, 10)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXRemote(cmd)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the Remote command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXRemote(RCX_RemotePlayASound)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXEvent(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the Event command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXEvent(RCX_ConstantSrc, 2)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXPlayTone(freq, duration)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the PlayTone command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXPlayTone(440, 100)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSelectDisplay(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SelectDisplay command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSelectDisplay(RCX_VariableSrc, 2)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXPollMemory(address, count)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the PollMemory command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXPollMemory(0, 10)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetEvent(evt, src, type)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetEvent command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetEvent(0, RCX_ConstantSrc, 5)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetGlobalOutput(outputs, mode)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetGlobalOutput command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetGlobalOutput(RCX_OUT_A, RCX_OUT_ON)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetGlobalDirection(outputs, dir)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetGlobalDirection command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetGlobalDirection(RCX_OUT_A, RCX_OUT_FWD)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetMaxPower(outputs, pwrsrc, pwrval)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetMaxPower command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetMaxPower(RCX_OUT_A, RCX_ConstantSrc, 5)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXEnableOutput(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the EnableOutput command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXEnableOutput(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXDisableOutput(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the DisableOutput command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXDisableOutput(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXInvertOutput(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the InvertOutput command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXInvertOutput(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXObvertOutput(outputs)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the ObvertOutput command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXObvertOutput(RCX_OUT_A)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXCalibrateEvent(evt, low, hi, hyst)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the CalibrateEvent command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXCalibrateEvent(0, 200, 500, 50)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetVar(0, RCX_VariableSrc, 1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSumVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SumVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSumVar(0, RCX_InputValueSrc, IN_1)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSubVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SubVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSubVar(0, RCX_RandomSrc, 10)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXDivVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the DivVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXDivVar(0, RCX_ConstantSrc, 2)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXMulVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the MulVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXMulVar(0, RCX_VariableSrc, 4)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSgnVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SgnVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSgnVar(0, RCX_VariableSrc, 0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXAbsVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the AbsVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXAbsVar(0, RCX_VariableSrc, 0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXAndVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the AndVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXAndVar(0, RCX_ConstantSrc, 0x7f)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXOrVar(varnum, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the OrVar command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXOrVar(0, RCX_ConstantSrc, 0xCC)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSet(dstsrc, dstval, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the Set command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSet(RCX_VariableSrc, 0, RCX_RandomSrc, 10000)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXUnlock()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the Unlock command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXUnlock()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXReset()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the Reset command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXReset()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXBoot()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the Boot command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXBoot()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetUserDisplay(src, value, precision)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetUserDisplay command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetUserDisplay(RCX_VariableSrc, 0, 2)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXIncCounter(counter)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the IncCounter command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXIncCounter(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXDecCounter(counter)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the DecCounter command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXDecCounter(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXClearCounter(counter)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the ClearCounter command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXClearCounter(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetPriority(p)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetPriority command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetPriority(2)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTRCXSetMessage(msg)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetMessage command to an RCX.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTRCXSetMessage(20)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutCalibrateSensor()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the CalibrateSensor command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutCalibrateSensor()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutMuteSound()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the MuteSound command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutMuteSound()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutUnmuteSound()\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the UnmuteSound command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutUnmuteSound()
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSelectSounds(group)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SelectSounds command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSelectSounds(0)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetLight(mode)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetLight command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetLight(SCOUT_LIGHT_ON)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetCounterLimit(counter, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetCounterLimit command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetCounterLimit(0, RCX_ConstantSrc, 2000)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetTimerLimit(timer, src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetTimerLimit command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetTimerLimit(0, RCX_ConstantSrc, 10000)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetSensorClickTime(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetSensorClickTime command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetSensorClickTime(RCX_ConstantSrc, 200)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetSensorHysteresis(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetSensorHysteresis command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetSensorHysteresis(RCX_ConstantSrc, 50)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetSensorLower Limit(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetSensorLowerLimit command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetSensorLower Limit(RCX_ConstantSrc, 100)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetSensorUpper Limit(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetSensorUpperLimit command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetSensorUpper Limit(RCX_ConstantSrc, 400)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetEventFeedback(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetEventFeedback command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetEventFeedback(RCX_ConstantSrc, 10)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSendVLL(src, value)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SendVLL command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSendVLL(RCX_ConstantSrc, 0x30)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetScoutRules(motion, touch, light, time, effect)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetScoutRules command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {HTScoutSetScoutRules(SCOUT_MR_FORWARD, SCOUT_TR_RE
VERSE, SCOUT_LR_IGNORE, SCOUT_TGS_SHORT, SCOUT_FXR_BUG)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 HTScoutSetScoutMode(mode)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Send the SetScoutMode command to a Scout.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {\lang1024\langfe1024\langnp1036 
HTScoutSetScoutMode(SCOUT_MODE_POWER)
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\lang1036\langfe1033\langnp1036 \page }{\cs16\lang1036\langfe1033\super\langnp1036 #
{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super #}{\f1  IDH_NBC_Mindsensors}}${\footnote \pard\plain 
\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super $}{\f1  Mindsensors API functions}}K{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs16\f1\super K}{\f1  mindsensors api functions}}+{\footnote \pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\cs16\f1\super +}{\f1  cc}}}{\lang1036\langfe1033\langnp1036 3.14 Mindsensors API Functions
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorMSRTClock(port, ss, mm, hh, dow, dd, MM, yy, result)\tab Function

\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 
Read real-time clock values from the Mindsensors RTClock sensor. Returns a boolean value indicating whether or not the operation completed successfully.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {
ReadSensorMSRTClock(IN_1, ss, mm, hh, dow, dd, mon, yy, result)
\par }\pard\plain \s22\ql \li0\ri0\sb120\sa120\widctlpar\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 ReadSensorMSCompass(port, out result)\tab Function
\par }\pard\plain \s21\ql \li360\ri0\sa120\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 Return the Mindsensors Compass sensor value.
\par }\pard\plain \s20\ql \li720\ri720\widctlpar\hyphpar0\aspalpha\aspnum\faauto\adjustright\rin720\lin720\itap0 \f6\fs22\expnd-2\expndtw-10\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {ReadSensorMSCompass(IN_1, result)
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1 \page 
\par }}