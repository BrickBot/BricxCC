{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\fmodern\fprq1\fcharset0 Courier New;}{\f2\fmodern\fprq1\fcharset0 Courier;}}
{\colortbl ;\red0\green0\blue255;\red128\green0\blue128;\red0\green128\blue0;\red255\green0\blue0;}
{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\sa120\super\f0\fs20 #$AK\nosupersub The NXT supports multi-threading, so a task in NXC directly corresponds to an NXT thread. Tasks are defined using the task keyword using the following syntax:\par
\pard\li720\sb120\b\f1 task\b0  name()\par
\{\par
  // the task's code is placed here\par
\}\par
\pard\sa120\f0 The name of the task may be any legal identifier. A program must always have at least one task - named "main" - which is started whenever the program is run. The maximum number of tasks is 256.\par
The body of a task consists of a list of statements. Scheduling dependant tasks using the \cf1 Precedes\cf0  or \cf1 Follows\cf0  API function is the primary mechanism supported by the NXT for starting other tasks concurrently. Tasks may also be started and stopped using the \b start\b0  and \b stop\b0  statements. There is also an NXC API command, \cf1 StopAllTasks\cf0 , which stops all currently running tasks. You can also stop all tasks using the \cf1 Stop\cf0  function. A task can stop itself via the \cf1 ExitTo\cf0  function or by task execution simply reaching the end of the task.\par
\pard\sb120\sa120\page\super #$AK\nosupersub All variables in NXC are of the following types: \par
\pard\li1548\tx3816\b Type Name\tab Information\par
\b0 bool\tab 8 bit unsigned\par
byte, unsigned char\tab 8 bit unsigned\par
char\tab 8 bit signed\par
unsigned int\tab 16 bit unsigned\par
short, int\tab 16 bit signed\par
unsigned long\tab 32 bit unsigned\par
long\tab 32 bit signed\par
mutex\tab Special type used for exclusive code access\par
string\tab Array of byte\par
struct\tab User-defined structure types\par
Arrays\tab Arrays of any type\par
\pard\sa120\page\super #$AK\nosupersub Identifiers are used for variable, task, function, and subroutine names. The first character of an identifier must be an upper or lower case letter or the underscore ('_'). Remaining characters may be letters, numbers, and an underscore. \par
A number of potential identifiers are reserved for use in the NXC language itself. These reserved words are called keywords and may not be used as identifiers. A complete list of keywords appears below:\par
\pard\li720\tx2520\tx4320\tx6480\f1 __RETURN__\tab __RETVAL__\tab __STRRETVAL__\tab __TMPBYTE__\par
__TMPWORD__\tab __TMPLONG__\tab abs\tab asm\par
bool\tab break\tab byte\tab case\par
char\tab const\tab continue\tab default\par
do\tab else\tab false\tab for\par
goto\tab if\tab inline\tab int\par
long\tab mutex\tab priority\tab repeat\par
return\tab safecall\tab short\tab sign\par
start\tab stop\tab string\tab struct\par
sub\tab switch\tab task\tab true\par
typedef\tab unsigned\tab until\tab void\par
while\par
\pard\tx2520\tx4320\tx6480\f0\par
\pard\sb120 NXC functions may optionally be marked as inline functions. This means that each call to a function will result in another copy of the function's code being included in the program. Unless used judiciously, inline functions can lead to excessive code size. \par
If a function is not marked as inline then an actual NXT subroutine is created and the call to the function in NXC code will result in a subroutine call to the NXT subroutine. The total number of non-inline functions (aka subroutines) and tasks must not exceed 256.\par
Another optional keyword that can be specified prior to the return type of a function is the safecall keyword. If a function is marked as safecall then the compiler will synchronize the execution of this function across multiple threads by wrapping each call to the function in Acquire and Release calls. If a second thread tries to call a safecall function while another thread is executing it the second thread will have to wait until the function returns to the first thread.\par
\pard Once declared, variables may be assigned the value of an expression:\par
\pard\li720\sb120\i\f1 variable\i0  \i assign_operator\i0  \i expression\i0 ;\par
\pard\sb120\f0 There are nine different assignment operators. The most basic operator, '=', simply assigns the value of the expression to the variable. The other operators modify the variable's value in some other way as shown in the table below\par
\pard\li720\sb120\tx1980\ul\b\f1 Operator\ulnone\tab\ul Action\ulnone\par
\pard\li720\tx1980\b0 =\tab Set variable to expression\par
+=\tab Add expression to variable\par
-=\tab Subtract expression from variable\par
*=\tab Multiple variable by expression\par
/=\tab Divide variable by expression\par
%=\tab Set variable to remainder after dividing by expression\par
&=\tab Bitwise AND expression into variable\par
|=\tab Bitwise OR expression into variable\par
^=\tab Bitwise exclusive OR expression into variable\par
||=\tab Set variable to absolute value of expression\par
+-=\tab Set variable to sign (-1,+1,0) of expression\par
>>=\tab Right shift variable by an amount\par
<<=\tab Left shift variable by an amount\par
\pard\sb120\f0 Some examples:\par
\pard\li720\sb120\f1 x = 2; // set x to 2\par
\pard\li720 y = 7; // set y to 7\par
x += y; // x is 9, y is still 7\par
\pard\sb120\f0\page\super #$AK\nosupersub The \f1 if\f0  statement evaluates a condition. If the condition is true it executes one statement (the consequence). An optional second statement (the alternative) is executed if the condition is false. The two syntaxes for an \f1 if\f0  statement is shown below.\par
\pard\li720\sb120\b\f1 if\b0  (\i condition\i0 ) \i consequence\i0\par
\pard\li720\b if\b0  (\i condition\i0 ) \i consequence\i0  \b else\b0  \i alternative\i0\par
\pard\sb120\f0 Note that the condition is enclosed in parentheses. Examples are shown below. Note how a compound statement is used in the last example to allow two statements to be executed as the consequence of the condition.\par
\pard\li720\sb120\b\f1 if\b0  (x == 1) y = 2;\par
\pard\li720\b if\b0  (x == 1) y = 3; \b else\b0  y = 4;\par
\b if\b0  (x == 1) \{y = 1; z = 2;\}\par
\pard\sb120\f0\page\super #$AK\nosupersub The \f1 while\f0  statement is used to construct a conditional loop. The condition is evaluated, and if true the body of the loop is executed, then the condition is tested again. This process continues until the condition becomes false (or a break statement is executed). The syntax for a while loop appears below:\par
\pard\li720\sb120\b\f1 while\b0  (\i condition\i0 ) \i body\i0\par
\pard\sb120\f0 It is very common to use a compound statement as the body of a loop:\par
\pard\li720\sb120\lang3082\b\f1 while\b0  (x < 10)\par
\pard\li720\{\par
\pard\fi720\li720 x = x+1;\par
y = y*2;\par
\pard\li720\lang1033\}\par
\pard\sb120\f0\page\super #$AK\nosupersub A variant of the while loop is the do-while loop. Its syntax is:\par
\pard\li720\sb120\b\f1 do\b0  \i body\i0  \b while\b0  (\i condition\i0 )\par
\pard\sb120\f0 The difference between a \f1 while\f0  loop and a \f1 do-while\f0  loop is that the \f1 do-while\f0  loop always executes the body at least once, whereas the \f1 while\f0  loop may not execute it at all. \par
\page\super #$AK\nosupersub Another kind of loop is the \f1 for\f0  loop:\par
\pard\li720\sb120\b\f1 for\b0  (\i stmt1\i0 ; \i condition\i0 ; \i stmt2\i0 ) \i body\i0\par
\pard\sb120\f0 A \f1 for\f0  loop always executes stmt1, then it repeatedly checks the condition and while it remains true executes the body followed by stmt2. The \f1 for\f0  loop is equivalent to:\par
\pard\li720\sb120\i\f1 stmt1\i0 ;\par
\pard\li720\b while\b0  (\i condition\i0 )\par
\{\par
\pard\fi720\li720\i body\par
stmt2\i0 ;\par
\pard\li720\}\par
\pard\sb120\f0\page\super #$AK\nosupersub The \f1 repeat\f0  statement executes a loop a specified number of times:\par
\pard\li720\sb120\b\f1 repeat\b0  (\i expression\i0 ) \i body\i0\par
\pard\sb120\f0 The expression determines how many times the body will be executed. Note that it is only evaluated a single time, then the body is repeated that number of times. This is different from both the \f1 while\f0  and \f1 do-while\f0  loops which evaluate their condition each time through the loop.\par
\page\super #$AK\nosupersub A \f1 switch\f0  statement can be used to execute one of several different blocks of code depending on the value of an expression. Each block of code is preceded by one or more \f1 case\f0  labels. Each \f1 case\f0  must be a constant and unique within the \f1 switch\f0  statement. The \f1 switch\f0  statement evaluates the expression then looks for a matching \f1 case\f0  label. It will then execute any statements following the matching \f1 case\f0  until either a \f1 break\f0  statement or the end of the \f1 switch\f0  is reached. A single default label may also be used - it will match any value not already appearing in a case label. Technically, a switch statement has the following syntax:\par
\pard\li720\sb120\b\f1 switch\b0  (\i expression\i0 ) \i body\i0\par
\pard\sb120\f0 The case and default labels are not statements in themselves - they are labels that precede statements. Multiple labels can precede the same statement. These labels have the following syntax\par
\pard\li720\sb120\b\f1 case\b0  \i constant_expression\i0 :\par
\pard\li720\b default\b0 :\par
\pard\sb120\f0 A typical switch statement might look like this:\par
\pard\li720\sb120\b\f1 switch\b0 (x)\par
\pard\li720\{\par
\pard\fi720\li720\b case\b0  1:\par
\pard\fi720\li1440 // do something when x is 1\par
\b break\b0 ;\par
\pard\fi720\li720\b case\b0  2:\par
\b case\b0  3:\par
\pard\fi720\li1440 // do something else when x is 2 or 3\par
\b break\b0 ;\par
\pard\fi720\li720\b default\b0 :\par
\pard\fi720\li1440 // do this when x is not 1, 2, or 3\par
\pard\fi720\li720\b break\b0 ;\par
\pard\li720\}\par
\pard\sb120\sa120\f0 NXC also supports using string types in the switch expression and constant strings in case labels.\par
\page\super #$AK\nosupersub  The \f1 goto\f0  statement forces a program to jump to the specified location. Statements in a program can be labeled by preceding them with an identifier and a colon. A \f1 goto\f0  statement then specifies the label which the program should jump to. For example, this is how an infinite loop that increments a variable could be implemented using \f1 goto\f0 :\par
\pard\li720\f1 my_loop:\par
\pard\fi720\li720 x++;\par
\b goto\b0  my_loop;\par
\pard\f0\par
\pard\sb120 The \f1 goto\f0  statement should be used sparingly and cautiously. In almost every case, control structures such as \f1 if\f0 , \f1 while\f0 , and \f1 switch\f0  make a program much more readable and maintainable than using \f1 goto\f0 .\par
\page\super #$AK\nosupersub NQC also defines the \f1 until\f0  macro which provides a convenient alternative to the \f1 while\f0  loop. The actual definition of until is:\par
\pard\li720\sb120\f1 #define \b until\b0 (c) \b while\b0  (!(c))\par
\pard\sb120\f0 In other words, \f1 until\f0  will continue looping until the condition becomes true. It is most often used in conjunction with an empty body statement:\par
\pard\li720\sb120\b\f1 until\b0 (SENSOR_1 == 1); // wait for sensor to be pressed\par
\pard\f0 The asm statement is used to define many of the NXC API calls. The syntax of the statement is:\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 asm \{ \line  \i one or more lines of assembly language\i0\line\}\par
\pard\sb120\expndtw0\f0\fs20 The statement simply emits the body of the statement as NeXT Byte Codes (NBC) code and passes it directly to the NBC compiler backend. The asm statement can often be used to optimize code so that it executes as fast as possible on the NXT firmware.  The following example shows an asm block containing variable declarations, labels, and basic NBC statements as well as comments.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 asm \{ \line //      jmp __lbl00D5\line       dseg segment\line         sl0000 slong\line         sl0005 slong\line         bGTTrue byte\line       dseg ends\line       mov\tab sl0000, 0x0\line       mov\tab sl0005, sl0000\line       mov\tab sl0000, 0x1\line       cmp\tab GT, bGTTrue, sl0005, sl0000\line       set bGTTrue, FALSE\line       brtst\tab EQ, __lbl00D5, bGTTrue\line   __lbl00D5:\line\}\par
\pard\sb120\expndtw0\f0\fs20 A few NXC keywords have meaning only within an asm statement. These keywords provide a means for returning string or scalar values from asm statements and for using temporary integer variables of byte, word, and long sizes.\par
\pard\li720\sb120\tx2880\b ASM Keyword\tab Meaning\par
\b0 __RETURN__\tab Used to return a value other than __RETVAL__ or __STRRETVAL__\par
__RETVAL__\tab Writing to this 4-byte value returns it to the calling program\par
__STRRETVAL__\tab Writing to this string value returns it to the calling program\par
__TMPBYTE__\tab Use this temporary variable to write and return single byte values\par
__TMPWORD__\tab Use this temporary variable to write and return 2-byte values\par
__TMPLONG__\tab Use this temporary variable to write and return 4-byte values\par
\pard\sb120 The asm block statement and these special ASM keywords are used throughout the NXC API. See the NXCDefs.h header file for several examples of how they can be put to use. To keep the main NXC code as "C-like" as possible and for the sake of better readability NXC asm block statements can be wrapped in preprocessor macros and placed in custom header files which are included using #include. The following example demonstrates using macro wrappers around asm block statements.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 #define SetMotorSpeed(port, cc, thresh, fast, slow) \\\line   asm \{ \\\line   set theSpeed, fast \\\line   brcmp cc, EndIfOut__I__, SV, thresh \\\line   set theSpeed, slow \\\line EndIfOut__I__: \\\line   OnFwd(port, theSpeed) \\\line   __IncI__ \\\line\}\par
\pard\sb120\expndtw0\f0\fs20\page\super #$AK\nosupersub  You can adjust the priority of a task using the priority statement.\par
\pard\li720\sb120\b\f1 priority\b0  task_name, new_priority;\par
\pard\sb120\f0\page\super #$AK\nosupersub Tasks may be started or stopped with the following statements:\par
\pard\li720\sb120\b\f1 start\b0  task_name;\par
\pard\li720\b stop\b0  task_name;\par
\pard\sb120\f0\page\super #$AK\nosupersub Within loops (such as a \f1 while\f0  loop) the \f1 break\f0  statement can be used to exit the loop and the \f1 continue\f0  statement can be used to skip to the top of the next iteration of the loop. The \f1 break\f0  statement can also be used to exit a \f1 switch\f0  statement.\par
\pard\li720\sb120\b\f1 break\b0 ;\par
\pard\li720\b continue\b0 ;\par
\pard\sb120\f0\page\super #$AK\nosupersub It is possible to cause a function to return before it reaches the end of its code using the \f1 return\f0  statement with an optional return value.\par
\pard\li720\sb120\b\f1 return\b0  [expression];\par
\pard\li360\sb120\tx1440\tx4140\tx5580\tx7380\b\f0\page\super #$AK\ul\nosupersub Operator\ulnone\tab\ul Description\ulnone\tab\ul Associativity\ulnone\tab\ul Restriction\ulnone\tab\ul Example\ulnone\par
\pard\li360\tx1440\tx4140\tx5580\tx7380\cf1\b0 abs\cf0 ()\tab Absolute value\tab n/a\tab\tab abs(x)\par
\cf1 sign\cf0 ()\tab Sign of operand\tab n/a\tab\tab sign(x)\par
++, --\tab Increment, decrement\tab left\tab variables only\tab x++ or ++x\par
-\tab Unary minus\tab right\tab\tab -x\par
~\tab Bitwise negation (unary)\tab right\tab\tab ~123\par
!\tab Logical negation\tab right\tab\tab !x\par
*, /, %\tab Multiplication, division,modulo\tab left\tab\tab x * y\par
+, -\tab Addition, subtraction\tab left\tab\tab x + y\par
<<, >>\tab Left and right shift\tab left\tab\tab 123 << 4\par
<, >,<=, >=\tab relational operators\tab left\tab\tab x < y\par
==, !=\tab equal to, not equal to\tab left\tab\tab x == 1\par
&\tab Bitwise AND\tab left\tab\tab x & y\par
^\tab Bitwise XOR\tab left\tab\tab 123 ^ 4\par
|\tab Bitwise OR\tab left\tab\tab x | y\par
&&\tab Logical AND\tab left\tab\tab x && y\par
||\tab Logical OR\tab left\tab\tab x || y\par
? :\tab conditional value\tab n/a\tab\tab x==1 ? y : z\par
\pard\par
\pard\fi-1800\li2520\sb120\tx2520\b\page\super #$AK\ul\nosupersub Condition\ulnone\tab\ul Meaning\ulnone\par
\pard\fi-1800\li2520\tx2520 true\b0\tab always true\par
\b false\b0\tab always false\par
expr\tab true if expr is not equal to 0\par
expr1 == expr2\tab true if expr1 equals expr2\par
expr1 != expr2\tab true if expr1 is not equal to expr2\par
expr1 < expr2\tab true if one expr1 is less than expr2\par
expr1 <= expr2\tab true if expr1 is less than or equal to expr2\par
expr1 > expr2\tab true if expr1 is greater than expr2\par
expr1 >= expr2\tab true if expr1 is greater than or equal to expr2\par
! condition\tab logical negation of a condition - true if condition is false\par
cond1 && cond2\tab logical AND of two conditions (true if and only if both conditions are true)\par
cond1 || cond2\tab logical OR of two conditions (true if and only if at least one of the conditions are true)\par
\pard\page\super #$AK\nosupersub The #include command works as expected, with the caveat that the filename must be enclosed in double quotes. There is no notion of a system include path, so enclosing a filename in angle brackets is forbidden.\par
\pard\li720\sb120\cf2\f1 #include "foo.h"\cf0  // ok\par
\pard\li720\cf2 #include <foo.h>\cf0  // error!\par
\pard\sb120\f0 NXC programs can begin with #include "NXCDefs.h" but they don't need to. This standard header file includes many important constants and macros which form the core NXC API. Current versions of NXC no longer require that you manually include the NXCDefs.h header file. Unless you specifically tell the compiler to ignore the standard system files this header file will automatically be included for you.\par
\pard\page\super #$AK\nosupersub The #define command is used for simple macro substitution. Redefinition of a macro is an error (unlike in C where it is a warning). Macros are normally terminated by the end of the line, but the newline may be escaped with the backslash ('\\') to allow multiline macros:\par
\pard\li720\sb120\cf2\f1 #define foo(x) do \{ bar(x); \\\par
\pard\fi720\li2160   baz(x); \} while( false)\par
\pard\sb120\cf0\f0 The \cf2 #undef\cf0  directive may be used to remove a macro\rquote s definition.\par
\pard\page\super #$AK\nosupersub Conditional compilation works similar to the C preprocessor. The following preprocessor directives may be used:\par
\pard\li720\sb120\cf2\f1 #if \i condition\i0\par
\pard\li720 #ifdef \i symbol\i0\par
#ifndef \i symbol\i0\par
#else\par
#elif \i condition\i0\par
#endif\cf0\par
\pard\sb120\f0 Conditions in \f1 #if\f0  directives use the same operators and precedence as in C. The \f1 defined()\f0  operator is supported.\par
\pard\super\fs24\page\fs20 #$AK\nosupersub The ## directive works similar to the C preprocessor. It is replaced by nothing, which causes tokens on either side to be concatenated together. Because it acts as a separator initially, it can be used within macro functions to produce identifiers via combination with parameter values.\par
\page\super #$AK\nosupersub  The NXT input module encompasses all sensor inputs except for digital I2C (LowSpeed) sensors. \par
\pard\li360\sb120\b Module Constants\tab\tab Value\par
\pard\li360\cf3\b0\f1 InputModuleName\cf0\f0\tab "Input.mod"\par
\cf3\f1 InputModuleID\cf0\f0\tab\tab 0x00030001\par
\pard\sb120 There are four sensors, which are internally numbered 0, 1, 2, and 3. This is potentially confusing since they are externally labeled on the NXT as sensors 1, 2, 3, and 4. To help mitigate this confusion, the sensor port names \cf3\f1 S1\cf0\f0 , \cf3\f1 S2\cf0\f0 , \cf3\f1 S3\cf0\f0 , and \cf3\f1 S4\cf0\f0  have been defined. These sensor names may be used in any function that requires a sensor port as an argument. Alternatively, the NBC port name constants \cf3\f1 IN_1\cf0\f0 , \cf3\f1 IN_2\cf0\f0 , \cf3\f1 IN_3\cf0\f0 , and \cf3\f1 IN_4\cf0\f0  may also be used when a sensor port is required.\par
Sensor value names \cf3\f1 SENSOR_1\cf0\f0 , \cf3\f1 SENSOR_2\cf0\f0 , \cf3\f1 SENSOR_3\cf0\f0 , and \cf3\f1 SENSOR_4\cf0\f0  have also been defined. These names may also be used whenever a program wishes to read the current value of the sensor:\par
\pard\li720\sb120\f1 x = \cf3 SENSOR_1\cf0 ; // read sensor and store value in x\par
\pard\sb120\tqr\tx8640\f0\page\super #$AK\nosupersub\b\fs24 SetSensor(sensor, const configuration)\tab Function\par
\b0\fs20 Set the type and mode of the given sensor to the specified configuration, which must be a special constant containing both type and mode information.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSensor\cf0 (\cf3 SENSOR_1\cf0 , \cf3 SENSOR_TOUCH\cf0 );\par
\pard\sb120\f0 When using the NXT, it is common to set both the type and mode at the same time. The SetSensor function makes this process a little easier by providing a single function to call and a set of standard type/mode combinations.\par
\pard\li720\sb120\tx3060\tx6300\ul\b Sensor Configuration\ulnone\tab\ul Type\ulnone\tab\ul Mode\par
\pard\li720\tx3060\tx6300\cf3\ulnone\b0 SENSOR_TOUCH\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_BOOL\par
SENSOR_LIGHT\tab SENSOR_TYPE_LIGHT\tab SENSOR_MODE_PERCENT\par
SENSOR_ROTATION\tab SENSOR_TYPE_ROTATION\tab SENSOR_MODE_ROTATION\par
\lang1036 SENSOR_CELSIUS\tab SENSOR_TYPE_TEMPERATURE\tab SENSOR_MODE_CELSIUS\par
\lang1031 SENSOR_FAHRENHEIT\tab SENSOR_TYPE_TEMPERATURE\tab SENSOR_MODE_FAHRENHEIT\par
\lang1033 SENSOR_PULSE\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_PULSE\par
SENSOR_EDGE\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_EDGE\par
\pard\sb120\tqr\tx8640\cf0\b\fs24\page\super #$AK\nosupersub SetSensorType(port, const type)\tab Function\par
\b0\fs20 Set a sensor's type, which must be one of the predefined sensor type constants. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSensorType\cf0 (\cf3 S1\cf0 , \cf3 SENSOR_TYPE_TOUCH\cf0 );\par
\pard\sb120\f0 There are 12 sensor types, each corresponding to a specific LEGO RCX or NXT sensor. A thirteenth type (SENSOR_TYPE_NONE) is used to indicate that no sensor has been configured. In general, a program should configure the type to match the actual sensor. If a sensor port is configured as the wrong type, the NXT may not be able to read it accurately.\par
\pard\li720\sb120\tx4320\ul\b Sensor Type\ulnone\tab\ul Meaning\ulnone\par
\pard\li720\tx4320\cf3\b0 SENSOR_TYPE_NONE\cf0\tab generic passive sensor\par
\cf3 SENSOR_TYPE_TOUCH\cf0\tab a touch sensor\par
\cf3\lang1040 SENSOR_TYPE_TEMPERATURE\cf0\tab a temperature sensor\par
\cf3\lang1033 SENSOR_TYPE_LIGHT\cf0\tab a light sensor\par
\cf3 SENSOR_TYPE_ROTATION\cf0\tab a rotation sensor\par
\cf3 SENSOR_TYPE_LIGHT_ACTIVE\cf0\tab NXT light sensor with light\par
\cf3 SENSOR_TYPE_LIGHT_INACTIVE\cf0\tab NXT light sensor without light\par
\cf3 SENSOR_TYPE_SOUND_DB\cf0\tab NXT sound sensor with dB scaling\par
\cf3 SENSOR_TYPE_SOUND_DBA\cf0\tab NXT sound sensor with dBA scaling\par
\cf3 SENSOR_TYPE_CUSTOM\cf0\tab Custom sensor (unused)\par
\cf3 SENSOR_TYPE_LOWSPEED\cf0\tab I2C digital sensor\par
\cf3 SENSOR_TYPE_LOWSPEED_9V\cf0\tab I2C digital sensor (9V power)\par
\cf3 SENSOR_TYPE_HIGHSPEED\cf0\tab Highspeed sensor (unused)\par
\par
\pard\sb120\tqr\tx8640\b\fs24\page\super #$AK\nosupersub SetSensorMode(port, const mode)\tab Function\par
\b0\fs20 Set a sensor's mode, which should be one of the predefined sensor mode constants. A slope parameter for boolean conversion, if desired, may be added to the mode. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSensorMode\cf0 (\cf3 SENSOR_1\cf0 , \cf3 SENSOR_MODE_RAW\cf0 ); // raw mode\par
\pard\li720\tqr\tx8640\cf1 SetSensorMode\cf0 (\cf3 SENSOR_1\cf0 , \cf3 SENSOR_MODE_RAW\cf0  + 10) ; // slope 10\par
\pard\sb120\f0 The NXT allows a sensor to be configured in different modes. The sensor mode determines how a sensor's raw value is processed. Some modes only make sense for certain types of sensors, for example SENSOR_MODE_ROTATION is useful only with rotation sensors. Call SetSensorMode to set the sensor mode. The possible modes are shown below.\par
\pard\li720\sb120\tx4320\ul\b Sensor Mode\ulnone\tab\ul Meaning\ulnone\par
\pard\li720\tx4320\cf3\b0 SENSOR_MODE_RAW\cf0\tab raw value from 0 to 1023\par
\cf3 SENSOR_MODE_BOOL\cf0\tab boolean value (0 or 1)\par
\cf3 SENSOR_MODE_EDGE\cf0\tab counts number of boolean transitions\par
\cf3 SENSOR_MODE_PULSE\cf0\tab counts number of boolean periods\par
\cf3 SENSOR_MODE_PERCENT\cf0\tab value from 0 to 100\par
\cf3 SENSOR_MODE_FAHRENHEIT\cf0\tab degrees F\par
\cf3 SENSOR_MODE_CELSIUS\cf0\tab degrees C\par
\cf3 SENSOR_MODE_ROTATION\cf0\tab rotation (16 ticks per revolution)\par
\pard\sb120\tqr\tx8640 The NXT provides a boolean conversion for all sensors - not just touch sensors. This boolean conversion is normally based on preset thresholds for the raw value. A "low" value (less than 460) is a boolean value of 1. A high value (greater than 562) is a boolean value of 0. This conversion can be modified: a slope value between 0 and 31 may be added to a sensor's mode when calling SetSensorMode. If the sensor's value changes more than the slope value during a certain time (3ms), then the sensor's boolean state will change. This allows the boolean state to reflect rapid changes in the raw value. A rapid increase will result in a boolean value of 0, a rapid decrease is a boolean value of 1.\par
Even when a sensor is configured for some other mode (i.e. SENSOR_MODE_PERCENT), the boolean conversion will still be carried out.\par
\b\fs24\page\super #$AK\nosupersub SetSensorLight(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as a light sensor (active). The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\cf1\expndtw-10\f1\fs22 SetSensorLight\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SetSensorSound(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as a sound sensor (dB scaling). The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\cf1\expndtw-10\f1\fs22 SetSensorSound\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SetSensorTouch(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as a touch sensor. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\cf1\expndtw-10\f1\fs22 SetSensorTouch\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SetSensorLowspeed(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as an I2C digital sensor (9V powered). The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\cf1\expndtw-10\f1\fs22 SetSensorLowspeed\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SetInput(port, const field, value)\tab Function\par
\b0\fs20 Set the specified field of the sensor on the specified port to the value provided. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. The field must be a sensor field constant. The value may be any valid expression.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\cf1\expndtw-10\f1\fs22 SetInput\cf0 (\cf3 S1\cf0 , \cf3 Type\cf0 , \cf3 SENSOR_TYPE_SOUND_DB\cf0 );\par
\pard\sb120\tqr\tx8640\expndtw0\f0\fs20 Each sensor has six fields that are used to define its state. The field constants are described in the following table. \par
\pard\li360\sb120\tx2880\b Sensor Field Constant\tab Meaning\par
\pard\li360\tx2880\cf3\b0 Type\cf0\tab The sensor type\par
\cf3 InputMode\cf0\tab The sensor mode\par
\cf3 RawValue\cf0\tab The raw sensor value\par
\cf3 NormalizedValue\cf0\tab The normalized sensor value\par
\cf3 ScaledValue\cf0\tab The scaled sensor value\par
\cf3 InvalidData\cf0\tab Invalidates the current sensor value\par
\pard\sb120\tqr\tx8640\b\fs24\page\super #$AK\nosupersub ClearSensor(port)\tab Function\par
\b0\fs20 Clear the value of a sensor - only affects sensors that are configured to measure a cumulative quantity such as rotation or a pulse count. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 ClearSensor\cf0 (\cf3 SENSOR_1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub ResetSensor(port)\tab Function\par
\b0\fs20 Reset the value of a sensor. If the sensor type or mode has been modified then the sensor should be reset in order to ensure that values read from the sensor are valid. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 ResetSensor\cf0 (x); // x = S1\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SetCustomSensorZeroOffset(const port, value)\tab Function\par
\b0\fs20 Sets the custom sensor zero offset value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetCustomSensorZeroOffset\cf0 (\cf3 S1\cf0 , 12);\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SetCustomSensorPercentFullScale(const port, value)\tab Function\par
\b0\fs20 Sets the custom sensor percent full scale value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetCustomSensorPercentFullScale\cf0 (\cf3 S1\cf0 , 100);\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SetCustomSensorActiveStatus(const port, value)\tab Function\par
\b0\fs20 Sets the custom sensor active status value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetCustomSensorActiveStatus\cf0 (\cf3 S1\cf0 , true);\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SetSensorDigiPinsDirection(const port, value)\tab Function\par
\b0\fs20 Sets the digital pins direction value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4). A value of 1 sets the direction to output. A value of 0 sets the direction to input.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSensorDigiPinsDirection\cf0 (\cf3 S1\cf0 , 1);\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SetSensorDigiPinsStatus(const port, value)\tab Function\par
\b0\fs20 Sets the digital pins status value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSensorDigiPinsStatus\cf0 (\cf3 S1\cf0 , \b false\b0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SetSensorDigiPinsOutputLevel(const port, value)\tab Function\par
\b0\fs20 Sets the digital pins output level value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSensorDigiPinsOutputLevel\cf0 (\cf3 S1\cf0 , 100);\par
\pard\tqr\tx8640\super\f0\fs24\page #$AK\nosupersub\b Sensor(n)\tab Value\par
\pard\sb120\tqr\tx8640\b0\fs20 Return the processed sensor reading for a sensor on port n, where n is 0, 1, 2, or 3 (or a sensor port name constant). This is the same value that is returned by the sensor value names (e.g. SENSOR_1). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 Sensor\cf0 (\cf3 S1\cf0 ); // read sensor 1\par
\pard\tqr\tx8640\b\f0\fs24\page\super\b0 #$AK\nosupersub\b SensorValue(n)\tab Value\par
\pard\sb120\tqr\tx8640\b0\fs20 Return the processed sensor reading for a sensor on port n, where n is 0, 1, 2, or 3 (or a sensor port name constant). This is the same value that is returned by the sensor value names (e.g. SENSOR_1). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorValue\cf0 (\cf3 S1\cf0 ); // read sensor 1\par
\pard\tqr\tx8640\b\f0\fs24\page\super\b0 #$AK\nosupersub\b SensorUS(n)\tab Value\par
\pard\sb120\tqr\tx8640\b0\fs20 Return the processed sensor reading for an ultrasonic sensor on port n, where n is 0, 1, 2, or 3 (or a sensor port name constant). Since an ultrasonic sensor is an I2C digital sensor its value cannot be read using the standard Sensor(n) value. A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorUS\cf0 (\cf3 S4\cf0 ); // read sensor 4\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorType(n)\tab Value\par
\b0\fs20 Return the configured type of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorType\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorMode(n)\tab Value\par
\b0\fs20 Return the current sensor mode for a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorMode\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorBoolean(n)\tab Value\par
\b0\fs20 Return the boolean value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). Boolean conversion is either done based on preset cutoffs, or a slope parameter specified by calling SetSensorMode.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorBoolean\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorValueBool(n)\tab Value\par
\b0\fs20 Return the boolean value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). Boolean conversion is either done based on preset cutoffs, or a slope parameter specified by calling SetSensorMode.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorValueBool\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorRaw(n) \tab Value\par
\b0\fs20 Return the raw value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorRaw\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SensorValueRaw(port) \tab Value\par
\b0\fs20 Return the raw value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorValueRaw\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SensorNormalized(port) \tab Value\par
\b0\fs20 Return the normalized value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorNormalized\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SensorScaled(port) \tab Value\par
\b0\fs20 Return the scaled value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used. This is the same as the standard Sensor(n) value.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorScaled\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SensorInvalid(port) \tab Value\par
\b0\fs20 Return the value of the InvalidData flag of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorInvalid\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub GetInput(port, const field) \tab Value\par
\b0\fs20 Return the value of the specified field of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used. The field must be a sensor field constant. Valid field constants are listed \uldb above\ulnone\v IDH_API_SETINPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 GetInput\cf0 (\cf3 S1\cf0 , \cf3 Type\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub CustomSensorZeroOffset(const port) \tab Value\par
\b0\fs20 Return the custom sensor zero offset value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 CustomSensorZeroOffset\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub CustomSensorPercentFullScale(const port) \tab Value\par
\b0\fs20 Return the custom sensor percent full scale value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 CustomSensorPercentFullScale\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub CustomSensorActiveStatus(const port) \tab Value\par
\b0\fs20 Return the custom sensor active status value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 CustomSensorActiveStatus\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SensorDigiPinsDirection(const port) \tab Value\par
\b0\fs20 Return the digital pins direction value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorDigiPinsDirection\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SensorDigiPinsStatus(const port) \tab Value\par
\b0\fs20 Return the digital pins status value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorDigiPinsStatus\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\b #$AK\nosupersub SensorDigiPinsOutputLevel(const port) \tab Value\par
\b0\fs20 Return the digital pins output level value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SensorDigiPinsOutputLevel\cf0 (\cf3 S1\cf0 );\par
\pard\sb120\tqr\tx8640\super\f0\fs24\page\fs20 #$AK\nosupersub\b\fs24 SetOutput(outputs, const field1, val1, \'85, const fieldN, valN)\tab Function\par
\pard\sb120\b0\fs20 Set the specified field of the outputs to the value provided. Outputs can be a constant or a variable containing the desired output ports. The field must be a valid output field constant. This function takes a variable number of field/value pairs. The output field constants and output port constants are described below.\par
\pard\li720\sb120\cf1\f1 SetOutput\cf0 (\cf3 OUT_AB\cf0 , \cf3 TachoLimit\cf0 , 720); // set tacho limit\par
\pard\sb120\f0 The NXT output module encompasses all the motor outputs.\par
\pard\li360\sb120\tx2880\b Module Constants\tab Value\par
\pard\li360\tx2880\cf3\b0 OutputModuleName\cf0\tab "Output.mod"\par
\cf3 OutputModuleID\cf0\tab 0x00020001\par
\pard\sb120 Nearly all of the NXC API functions dealing with outputs take either a single output or a set of outputs as their first argument. Depending on the function call, the output or set of outputs may be a constant or a variable containing an appropriate output port value. The constants \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , and \cf3 OUT_C\cf0  are used to identify the three outputs. Unlike NQC, adding individual outputs together does not combine multiple outputs. Instead, the NXC API provides predefined combinations of outputs: \cf3 OUT_AB\cf0 , \cf3 OUT_AC\cf0 , \cf3 OUT_BC\cf0 , and \cf3 OUT_ABC\cf0 . Manually combining outputs involves creating an array and adding two or more of the three individual output constants to the array.\par
Power levels can range 0 (lowest) to 100 (highest). Negative power levels reverse the direction of rotation (i.e., forward at a power level of -100 actually means reverse at a power level of 100).\par
The outputs each have several fields that define the current state of the output port. These fields are defined in the table below.\par
\pard\fi-5040\li5040\sb120\tx1440\tx2160\tx3600\tx5040\b Field Constant\tab Type\tab Access\tab Range\tab Meaning\par
\pard\fi-5040\li5040\tx1440\tx2160\tx3600\tx5040\cf3\b0 UpdateFlags\cf0\tab ubyte\tab Read/Write\tab 0, 255\tab Use UF_UPDATE_MODE, UF_UPDATE_SPEED, UF_UPDATE_TACHO_LIMIT, and UF_UPDATE_PID_VALUES along with other fields to commit changes to the state of outputs. Set the appropriate flags after setting one or more of the output fields in order for the changes to actually go into affect.\par
\cf3 OutputMode\cf0\tab ubyte\tab Read/Write\tab 0, 255\tab The OUT_MODE_MOTORON bit must be set in order for power to be applied to the motors. Add OUT_MODE_BRAKE to enable electronic braking. Braking means that the output voltage is not allowed to float between active PWM pulses. It improves the accuracy of motor output but uses more battery power.\par
\tab\tab\tab\tab To use motor regulation include OUT_MODE_REGULATED in the OutputMode value. Use UF_UPDATE_MODE with UpdateFlags to commit changes to this field.\par
\cf3 Power\cf0\tab sbyte\tab Read/ Write\tab -100, 100\tab Specify the power level of the output. The absolute value of Power is a percentage of the full power of the motor. The sign of Power controls the rotation direction. Positive values tell the firmware to turn the motor forward, while negative values turn the motor backward. Use UF_UPDATE_POWER with UpdateFlags to commit changes to this field.\par
\cf3 ActualSpeed\cf0\tab sbyte\tab Read\tab -100, 100\tab Return the percent of full power the firmware is applying to the output. This may vary from the Power value when auto-regulation code in the firmware responds to a load on the output.\par
\cf3 TachoCount\cf0\tab slong\tab Read\tab signed long\tab Return the internal position counter value for the specified output. The internal count is reset automatically when a new goal is set using the TachoLimit and the UF_UPDATE_TACHO_LIMIT flag.\par
\tab\tab\tab\tab Set the UF_UPDATE_RESET_COUNT flag in UpdateFlags to reset TachoCount and cancel any TachoLimit.\par
\tab\tab\tab\tab The sign of TachoCount indicates the motor rotation direction.\par
\cf3 TachoLimit\cf0\tab ulong\tab Read/ Write\tab unsigned long\tab Specify the number of degrees the motor should rotate.\par
\tab\tab\tab\tab Use UF_UPDATE_TACHO_LIMIT with the UpdateFlags field to commit changes to the TachoLimit. \par
\tab\tab\tab\tab The value of this field is a relative distance from the current motor position at the moment when the UF_UPDATE_TACHO_LIMIT flag is processed.\par
\cf3 RunState\cf0\tab ubyte\tab Read/ Write\tab 0..255\tab Use this field to specify the running state of an output. Set the RunState to OUT_RUNSTATE_RUNNING to enable power to any output. Use OUT_RUNSTATE_RAMPUP to enable automatic ramping to a new Power level greater than the current Power level. Use OUT_RUNSTATE_RAMPDOWN to enable automatic ramping to a new Power level less than the current Power level.\par
\tab\tab\tab\tab Both the rampup and rampdown bits must be used in conjunction with appropriate TachoLimit and Power values. In this case the firmware smoothly increases or decreases the actual power to the new Power level over the total number of degrees of rotation specified in TachoLimit.\par
\cf3 TurnRatio\cf0\tab sbyte\tab Read/ Write\tab -100, 100\tab Use this field to specify a proportional turning ratio. This field must be used in conjunction with other field values: OutputMode must include OUT_MODE_MOTORON and OUT_MODE_REGULATED, RegMode must be set to OUT_REGMODE_SYNC, RunState must not be OUT_RUNSTATE_IDLE, and Speed must be non-zero. \par
\tab\tab\tab\tab There are only three valid combinations of left and right motors for use with TurnRatio: OUT_AB, OUT_BC, and OUT_AC. In each of these three options the first motor listed is considered to be the left motor and the second motor is the right motor, regardless of the physical configuration of the robot.\par
\tab\tab\tab\tab Negative TurnRatio values shift power toward the left motor while positive values shift power toward the right motor. An absolute value of 50 usually results in one motor stopping. An absolute value of 100 usually results in two motors turning in opposite directions at equal power.\par
\cf3 RegMode\cf0\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the regulation mode to use with the specified port(s). It is ignored if the OUT_MODE_REGULATED bit is not set in the OutputMode field. Unlike the OutputMode field, RegMode is not a bitfield. Only one RegMode value can be set at a time. \par
\tab\tab\tab\tab Speed regulation means that the firmware tries to maintain a certain speed based on the Power setting. The firmware adjusts the PWM duty cycle if the motor is affected by a physical load. This adjustment is reflected by the value of the ActualSpeed property. When using speed regulation, do not set Power to its maximum value since the firmware cannot adjust to higher power levels in that situation.\par
\tab\tab\tab\tab Synchronization means the firmware tries to keep two motors in synch regardless of physical loads. Use this mode to maintain a straight path for a mobile robot automatically. Also use this mode with the TurnRatio property to provide proportional turning. \par
\tab\tab\tab\tab Set OUT_REGMODE_SYNC on at least two motor ports in order for synchronization to function. Setting OUT_REGMODE_SYNC on all three motor ports will result in only the first two (OUT_A and OUT_B) being synchronized.\par
\cf3 Overload\cf0\tab ubyte\tab Read\tab 0..1\tab This field will have a value of 1 (true) if the firmware speed regulation cannot overcome a physical load on the motor. In other words, the motor is turning more slowly than expected. \par
\tab\tab\tab\tab If the motor speed can be maintained in spite of loading then this field value is zero (false). \par
\tab\tab\tab\tab In order to use this field the motor must have a non-idle RunState, an OutputMode which includes OUT_MODE_MOTORON and OUT_MODE_REGULATED, and its RegMode must be set to OUT_REGMODE_SPEED.\par
\cf3 RegPValue\cf0\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the proportional term used in the internal proportional-integral-derivative (PID) control algorithm.\par
\tab\tab\tab\tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.\par
\cf3 RegIValue\cf0\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the integral term used in the internal proportional-integral-derivative (PID) control algorithm.\par
\tab\tab\tab\tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.\par
\cf3 RegDValue\cf0\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the derivative term used in the internal proportional-integral-derivative (PID) control algorithm.\par
\tab\tab\tab\tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.\par
\cf3 BlockTachoCount\cf0\tab slong\tab Read\tab full range of signed long\tab Return the block-relative position counter value for the specified port.\par
\tab\tab\tab\tab Refer to the UpdateFlags description for information about how to use block-relative position counts.\par
\tab\tab\tab\tab Set the UF_UPDATE_RESET_BLOCK_COUNT flag in UpdateFlags to request that the firmware reset the BlockTachoCount. \par
\tab\tab\tab\tab The sign of BlockTachoCount indicates the direction of rotation. Positive values indicate forward rotation and negative values indicate reverse rotation. Forward and reverse depend on the orientation of the motor.\par
\cf3 RotationCount\cf0\tab slong\tab Read\tab signed long\tab Return the program-relative position counter value for the specified port.\par
\tab\tab\tab\tab Refer to the UpdateFlags description for information about how to use program-relative position counts.\par
\tab\tab\tab\tab Set the UF_UPDATE_RESET_ROTATION_COUNT flag in UpdateFlags to request that the firmware reset the RotationCount. \par
\tab\tab\tab\tab The sign of RotationCount indicates the direction of rotation. Positive values indicate forward rotation and negative values indicate reverse rotation. Forward and reverse depend on the orientation of the motor.\par
\pard\sb120 Valid UpdateFlags values are described in the following table.\par
\pard\fi-4320\li4320\sb120\tx4320\b UpdateFlags Constants\tab Meaning\par
\pard\fi-4320\li4320\tx4320\cf3\b0 UF_UPDATE_MODE\cf0\tab Commits changes to the OutputMode output property\par
\cf3 UF_UPDATE_SPEED\cf0\tab Commits changes to the Power output property\par
\cf3 UF_UPDATE_TACHO_LIMIT\cf0\tab Commits changes to the TachoLimit output property\par
\cf3 UF_UPDATE_RESET_COUNT\cf0\tab Resets all rotation counters, cancels the current goal, and resets the rotation error-correction system\par
\cf3 UF_UPDATE_PID_VALUES\cf0\tab Commits changes to the PID motor regulation properties\par
\cf3 UF_UPDATE_RESET_BLOCK_COUNT\cf0\tab Resets the block-relative rotation counter\par
\cf3 UF_UPDATE_RESET_ROTATION_COUNT\cf0\tab Resets the program-relative rotation counter\par
\pard\sb120 Valid OutputMode values are described in the following table.\par
\pard\sb120\tx3240\tx4320\b OutputMode Constants\tab Value\tab Meaning\par
\pard\tx3240\tx4320\cf3\b0 OUT_MODE_COAST\cf0\tab 0x00\tab No power and no braking so motors rotate freely\par
\cf3 OUT_MODE_MOTORON\cf0\tab 0x01\tab Enables PWM power to the outputs given the Power setting\par
\cf3 OUT_MODE_BRAKE\cf0\tab 0x02\tab Uses electronic braking to outputs\par
\cf3 OUT_MODE_REGULATED\cf0\tab 0x04\tab Enables active power regulation using the RegMode value\par
\cf3 OUT_MODE_REGMETHOD\cf0\tab 0xf0\tab\par
\pard\sb120 Valid RunState values are described in the following table.\par
\pard\fi-4320\li4320\sb120\tx3240\tx4320\b RunState Constants\tab Value\tab Meaning\par
\pard\fi-4320\li4320\tx3240\tx4320\cf3\b0 OUT_RUNSTATE_IDLE\cf0\tab 0x00\tab Disable all power to motors.\par
\cf3 OUT_RUNSTATE_RAMPUP\cf0\tab 0x10\tab Enable ramping up from a current Power to a new (higher) Power over a specified TachoLimit goal.\par
\cf3 OUT_RUNSTATE_RUNNING\cf0\tab 0x20\tab Enable power to motors at the specified Power level.\par
\cf3 OUT_RUNSTATE_RAMPDOWN\cf0\tab 0x40\tab Enable ramping down from a current Power to a new (lower) Power over a specified TachoLimit goal.\par
\pard\sb120 Valid RegMode values are described in the following table.\par
\pard\sb120\tx3240\tx4320\b RegMode Constants\tab Value\tab Meaning\par
\pard\tx3240\tx4320\cf3\b0 OUT_REGMODE_IDLE\cf0\tab 0x00\tab No regulation\par
\cf3 OUT_REGMODE_SPEED\cf0\tab 0x01\tab Regulate a motor's speed (Power)\par
\cf3 OUT_REGMODE_SYNC\cf0\tab 0x02\tab Synchronize the rotation of two motors\par
\pard\sb120 Valid tachometer reset constants are described in the following table.\par
\pard\sb120\tx3240\b Reset Constants\tab Value\par
\pard\tx3240\cf3\b0 RESET_NONE\cf0\tab 0x00\par
\cf3 RESET_COUNT\cf0\tab 0x08\par
\cf3 RESET_BLOCK_COUNT\cf0\tab 0x20\par
\cf3 RESET_ROTATION_COUNT\cf0\tab 0x40\par
\cf3 RESET_BLOCKANDTACHO\cf0\tab 0x28\par
\cf3 RESET_ALL\cf0\tab 0x68\par
\pard\sb120 Valid output port constants are described in the following table.\par
\pard\sb120\tx3240\b Output Port Constants\tab Value\par
\pard\tx3240\cf3\b0 OUT_A\cf0\tab 0x00\par
\cf3 OUT_B\cf0\tab 0x01\par
\cf3 OUT_C\cf0\tab 0x02\par
\cf3 OUT_AB\cf0\tab 0x03\par
\cf3 OUT_AC\cf0\tab 0x04\par
\cf3 OUT_BC\cf0\tab 0x05\par
\cf3 OUT_ABC\cf0\tab 0x06\par
\pard\tx3240\tx4320\par
\pard\sb120\tqr\tx8640\b\fs24\page\super #$AK\nosupersub Off(outputs)\tab Function\par
\b0\fs20 Turn the specified outputs off (with braking). Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 Off\cf0 (\cf3 OUT_A\cf0 ); // turn off output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OffEx(outputs, const reset)\tab Function\par
\b0\fs20 Turn the specified outputs off (with braking). Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OffEx\cf0 (\cf3 OUT_A\cf0 , \cf3 RESET_NONE\cf0 ); // turn off output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Coast(outputs)\tab Function\par
\b0\fs20 Turn off the specified outputs, making them coast to a stop. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 Coast\cf0 (\cf3 OUT_A\cf0 ); // coast output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub CoastEx(outputs, const reset)\tab Function\par
\b0\fs20 Turn off the specified outputs, making them coast to a stop. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 CoastEx\cf0 (\cf3 OUT_A\cf0 , \cf3 RESET_NONE\cf0 ); // coast output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Float(outputs)\tab Function\par
\b0\fs20 Make outputs float. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . Float is an alias for \uldb Coast\ulnone\v IDH_API_COAST\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 Float\cf0 (\cf3 OUT_A\cf0 ); // float output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnFwd(outputs, pwr)\tab Function\par
\b0\fs20 Set outputs to forward direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . \par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnFwd\cf0 (\cf3 OUT_A\cf0 , 75);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnFwdEx(outputs, pwr, const reset)\tab Function\par
\b0\fs20 Set outputs to forward direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnFwdEx\cf0 (\cf3 OUT_A\cf0 , 75, \cf3 RESET_NONE\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnRev(outputs, pwr)\tab Function\par
\b0\fs20 Set outputs to reverse direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnRev\cf0 (\cf3 OUT_A\cf0 , 75);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnRevEx(outputs, pwr, const reset)\tab Function\par
\b0\fs20 Set outputs to reverse direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnRevEx\cf0 (\cf3 OUT_A\cf0 , 75, \cf3 RESET_NONE\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnFwdReg(outputs, pwr, regmode)\tab Function\par
\b0\fs20 Run the specified outputs forward using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . Valid regulation modes are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnFwdReg\cf0 (\cf3 OUT_A\cf0 , 75, \cf3 OUT_REGMODE_SPEED\cf0 ); // regulate speed\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnFwdRegEx(outputs, pwr, regmode, const reset)\tab Function\par
\b0\fs20 Run the specified outputs forward using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . Valid regulation modes are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnFwdRegEx\cf0 (\cf3 OUT_A\cf0 , 75, \cf3 OUT_REGMODE_SPEED\cf0 , \cf3 RESET_NONE\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnRevReg(outputs, pwr, regmode)\tab Function\par
\b0\fs20 Run the specified outputs in reverse using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . Valid regulation modes are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnRevReg\cf0 (\cf3 OUT_A\cf0 , 75, \cf3 OUT_REGMODE_SPEED\cf0 ); // regulate speed\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnRevRegEx(outputs, pwr, regmode, const reset)\tab Function\par
\b0\fs20 Run the specified outputs in reverse using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . Valid regulation modes are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnRevRegEx\cf0 (\cf3 OUT_A\cf0 , 75, \cf3 OUT_REGMODE_SPEED\cf0 , \cf3 RESET_NONE\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnFwdSync(outputs, pwr, turnpct)\tab Function\par
\b0\fs20 Run the specified outputs forward with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnFwdSync\cf0 (\cf3 OUT_AB\cf0 , 75, -100); // spin right\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnFwdSyncEx(outputs, pwr, turnpct, const reset)\tab Function\par
\b0\fs20 Run the specified outputs forward with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnFwdSyncEx\cf0 (\cf3 OUT_AB\cf0 , 75, 0, \cf3 RESET_NONE\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnRevSync(outputs, pwr, turnpct)\tab Function\par
\b0\fs20 Run the specified outputs in reverse with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnRevSync\cf0 (\cf3 OUT_AB\cf0 , 75, -100); // spin left\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnRevSyncEx(outputs, pwr, turnpct, const reset)\tab Function\par
\b0\fs20 Run the specified outputs in reverse with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 OnRevSyncEx\cf0 (\cf3 OUT_AB\cf0 , 75, -100, \cf3 RESET_NONE\cf0 ); // spin left\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RotateMotor(outputs, pwr, angle)\tab Function\par
\b0\fs20 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 RotateMotor\cf0 (\cf3 OUT_A\cf0 , 75, 45); // forward 45 degrees\par
\cf1 RotateMotor\cf0 (\cf3 OUT_A\cf0 , -75, 45); // reverse 45 degrees\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RotateMotorPID(outputs, pwr, angle, p, i, d)\tab Function\par
\b0\fs20 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . Also specify the proportional, integral, and derivative factors used by the firmware's PID motor control algorithm.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 RotateMotorPID\cf0 (\cf3 OUT_A\cf0 , 75, 45, 20, 40, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RotateMotorEx(outputs, pwr, angle, turnpct, sync, stop)\tab Function\par
\b0\fs20 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . If a non-zero turn percent is specified then sync must be set to true or no turning will occur. Specify whether the motor(s) should brake at the end of the rotation using the stop parameter.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 RotateMotorEx\cf0 (\cf3 OUT_AB\cf0 , 75, 360, 50, \b true\b0 , \b true\b0 ); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RotateMotorExPID(outputs, pwr, angle, turnpct, sync, stop, p, i, d)\tab Function\par
\b0\fs20 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 . If a non-zero turn percent is specified then sync must be set to true or no turning will occur. Specify whether the motor(s) should brake at the end of the rotation using the stop parameter. Also specify the proportional, integral, and derivative factors used by the firmware's PID motor control algorithm.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 RotateMotorExPID\cf0 (\cf3 OUT_AB\cf0 , 75, 360, 50, \b true\b0 , \b true\b0 , 30, 50, 90); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ResetTachoCount(outputs)\tab Function\par
\b0\fs20 Reset the tachometer count and tachometer limit goal for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 ResetTachoCount\cf0 (\cf3 OUT_AB\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ResetBlockTachoCount(outputs)\tab Function\par
\b0\fs20 Reset the block-relative position counter for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 ResetBlockTachoCount\cf0 (\cf3 OUT_AB\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ResetRotationCount(outputs)\tab Function\par
\b0\fs20 Reset the program-relative position counter for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 ResetRotationCount\cf0 (\cf3 OUT_AB\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ResetAllTachoCounts(outputs)\tab Function\par
\b0\fs20 Reset all three position counters and reset the current tachometer limit goal for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 ResetAllTachoCounts\cf0 (\cf3 OUT_AB\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetOutput(output, const field)\tab Value\par
\pard\sb120\b0\fs20 Get the value of the specified field for the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values. The field must be a valid output field constant. The output field constants are described \uldb above\ulnone\v IDH_API_SETOUTPUT\v0 .\par
\pard\li720\sb120\f1 x = \cf1 GetOutput\cf0 (\cf3 OUT_A\cf0 , \cf3 TachoLimit\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorMode(output)\tab Value\par
\pard\sb120\b0\fs20 Get the mode of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorMode\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorPower(output)\tab Value\par
\pard\sb120\b0\fs20 Get the power level of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorPower\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorActualSpeed(output)\tab Value\par
\pard\sb120\b0\fs20 Get the actual speed value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorActualSpeed\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorTachoCount(output)\tab Value\par
\pard\sb120\b0\fs20 Get the tachometer count value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorTachoCount\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorTachoLimit(output)\tab Value\par
\pard\sb120\b0\fs20 Get the tachometer limit value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorTachoLimit\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorRunState(output)\tab Value\par
\pard\sb120\b0\fs20 Get the RunState value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorRunState\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorTurnRatio(output)\tab Value\par
\pard\sb120\b0\fs20 Get the turn ratio value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorTurnRatio\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorRegulation(output)\tab Value\par
\pard\sb120\b0\fs20 Get the regulation value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorRegulation\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorOverload(output)\tab Value\par
\pard\sb120\b0\fs20 Get the overload value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorOverload\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorRegPValue(output)\tab Value\par
\pard\sb120\b0\fs20 Get the proportional PID value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorRegPValue\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorRegIValue(output)\tab Value\par
\pard\sb120\b0\fs20 Get the integral PID value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorRegIValue\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorRegDValue(output)\tab Value\par
\pard\sb120\b0\fs20 Get the derivative PID value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorRegDValue\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorBlockTachoCount(output)\tab Value\par
\pard\sb120\b0\fs20 Get the block-relative position counter value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorBlockTachoCount\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorRotationCount(output)\tab Value\par
\pard\sb120\b0\fs20 Get the program-relative position counter value of the specified output. Output can be \cf3 OUT_A\cf0 , \cf3 OUT_B\cf0 , \cf3 OUT_C\cf0 , or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = \cf1 MotorRotationCount\cf0 (\cf3 OUT_A\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub MotorPwnFreq()\tab Value\par
\pard\sb120\b0\fs20 Get the current motor pulse width modulation frequency.\par
\pard\li720\sb120\f1 x = \cf1 MotorPwnFreq\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetMotorPwnFreq(val)\tab Function\par
\pard\sb120\b0\fs20 Set the current motor pulse width modulation frequency.\par
\pard\li720\sb120\cf1\f1 SetMotorPwnFreq\cf0 (x);\par
\pard\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub\b0\fs20 The NXT firmware provides a mechanism for reading and writing input (sensor) and output (motor) field values using low-level constants known as IO Map Addresses (IOMA). Valid IOMA constants are listed in the following table.\par
\pard\sb120\tx2880\tx5040\b IOMA Constant\tab Parameter\tab Meaning\par
\pard\tx2880\tx5040\b0 InputIOType(p)            \tab S1..S4\tab Input Type value\par
InputIOInputMode(p)       \tab S1..S4\tab Input InputMode value\par
InputIORawValue(p)        \tab S1..S4\tab Input RawValue value\par
InputIONormalizedValue(p) \tab S1..S4\tab Input NormalizedValue value\par
InputIOScaledValue(p)     \tab S1..S4\tab Input ScaledValue value\par
InputIOInvalidData(p)     \tab S1..S4\tab Input InvalidData value\par
OutputIOUpdateFlags(p)    \tab OUT_A..OUT_C\tab Output UpdateFlags value\par
OutputIOOutputMode(p)     \tab OUT_A..OUT_C\tab Output OutputMode value\par
OutputIOPower(p)          \tab OUT_A..OUT_C\tab Output Power value\par
OutputIOActualSpeed(p)    \tab OUT_A..OUT_C\tab Output ActualSpeed value\par
OutputIOTachoCount(p)     \tab OUT_A..OUT_C\tab Output TachoCount value\par
OutputIOTachoLimit(p)      \tab OUT_A..OUT_C\tab Output TachoLimit value\par
OutputIORunState(p)        \tab OUT_A..OUT_C\tab Output RunState value\par
OutputIOTurnRatio(p)       \tab OUT_A..OUT_C\tab Output TurnRatio value\par
OutputIORegMode(p)         \tab OUT_A..OUT_C\tab Output RegMode value\par
OutputIOOverload(p)        \tab OUT_A..OUT_C\tab Output Overload value\par
OutputIORegPValue(p)       \tab OUT_A..OUT_C\tab Output RegPValue value\par
OutputIORegIValue(p)       \tab OUT_A..OUT_C\tab Output RegIValue value\par
OutputIORegDValue(p)       \tab OUT_A..OUT_C\tab Output RegDValue value\par
OutputIOBlockTachoCount(p) \tab OUT_A..OUT_C\tab Output BlockTachoCount value\par
OutputIORotationCount(p)   \tab OUT_A..OUT_C\tab Output RotationCount value.\par
\pard\tqr\tx8640\b\fs24\page\super #$AK\nosupersub IOMA(const n)\tab Value\par
\pard\sb120\tqr\tx8640\b0\fs20 Read from the specified IO Map Address value. Valid IO Map Address constants are listed \uldb above\ulnone\v IDH_API_IOMACONSTANTS\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 IOMA\cf0 (\cf3 InputIORawValue\cf0 (\cf3 S3\cf0 ));\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetIOMA(const n, val)\tab Function\par
\b0\fs20 Set the specified IO Map Address to the value provided. Valid IO Map Address constants are listed \uldb above\ulnone\v IDH_API_IOMACONSTANTS\v0 . The value must be a specified via a constant, a constant expression, or a variable.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetIOMA\cf0 (\cf3 OutputIOPower\cf0 (\cf3 OUT_A\cf0 ), x);\par
\pard\sb120\b\f0\fs24\page\super #$AK\nosupersub\b0\fs20 The NXT sound module encompasses all sound output features. The NXT provides support for playing basic tones as well as two different types of files. \par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\cf3\b0 SoundModuleName\cf0\tab "Sound.mod"\par
\cf3 SoundModuleID\cf0\tab 0x00080001\par
\pard\sb120 Sound files (.rso) are like .wav files. They contain thousands of sound samples that digitally represent an analog waveform. With sounds files the NXT can speak or play music or make just about any sound imaginable.\par
Melody files are like MIDI files. They contain multiple tones with each tone being defined by a frequency and duration pair. When played on the NXT a melody file sounds like a pure sine-wave tone generator playing back a series of notes. While not as fancy as sound files, melody files are usually much smaller than sound files.\par
When a sound or a file is played on the NXT, execution of the program does not wait for the previous playback to complete. To play multiple tones or files sequentially it is necessary to wait for the previous tone or file playback to complete first. This can be done via the Wait API function or by using the sound state value within a while loop.\par
\pard\sb120\tqr\tx8640 The NXC API defines frequency and duration constants which may be used in calls to PlayTone or PlayToneEx. Frequency constants start with \cf3 TONE_A3\cf0  (the 'A' pitch in octave 3) and go to \cf3 TONE_B7\cf0  (the 'B' pitch in octave 7). Duration constants start with \cf3 MS_1\cf0  (1 millisecond) and go up to \cf3 MIN_1\cf0  (60000 milliseconds) with several constants in between. See NBCCommon.h for the complete list.\par
Valid sound flags constants are listed in the following table.\par
\pard\sb120\tx2709\tx4059\b\fs22 Sound Flags Constants\tab Read/Write\tab Meaning\par
\pard\tx2709\tx4059\b0\fs20 SOUND_FLAGS_IDLE\tab Read\tab Sound is idle\par
SOUND_FLAGS_UPDATE\tab Write\tab Make changes take effect\par
SOUND_FLAGS_RUNNING\tab Read\tab Processing a tone or file\par
\pard\sb120\tqr\tx8640 Valid sound state constants are listed in the following table.\par
Valid sound mode constants are listed in the following table.\par
Miscellaneous sound constants are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub PlayTone(frequency, duration)\tab Function\par
\b0\fs20 Play a single tone of the specified frequency and duration. The frequency is in Hz. The duration is in 1000ths of a second. All parameters may be any valid expression.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 PlayTone\cf0 (\cf4 440\cf0 , \cf4 500\cf0 ); // Play 'A' for one half second\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub PlayToneEx(frequency, duration, volume, bLoop)\tab Function\par
\b0\fs20 Play a single tone of the specified frequency, duration, and volume. The frequency is in Hz. The duration is in 1000ths of a second. Volume should be a number from 0 (silent) to 4 (loudest). All parameters may be any valid expression.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 PlayToneEx\cf0 (\cf4 440\cf0 , \cf4 500\cf0 , \cf4 2\cf0 , \b false\b0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub PlayFile(filename)\tab Function\par
\b0\fs20 Play the specified sound file (.rso) or a melody file (.rmd). The filename may be any valid string expression.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 PlayFile\cf0 ("startup.rso");\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub PlayFileEx(filename, volume, bLoop)\tab Function\par
\b0\fs20 Play the specified sound file (.rso) or a melody file (.rmd). The filename may be any valid string expression. Volume should be a number from 0 (silent) to 4 (loudest). bLoop is a boolean value indicating whether to repeatedly play the file.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 PlayFileEx\cf0 ("startup.rso", \cf4 3\cf0 , \b true\b0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SoundFlags()\tab Value\par
\b0\fs20 Return the current sound flags. Valid sound flags values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SoundFlags\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSoundFlags(n)\tab Function\par
\b0\fs20 Set the current sound flags. Valid sound flags values are listed above.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSoundFlags\cf0 (\cf3 SOUND_FLAGS_UPDATE\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SoundState()\tab Value\par
\b0\fs20 Return the current sound state. Valid sound state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SoundState\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSoundState(n)\tab Function\par
\b0\fs20 Set the current sound state. Valid sound state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSoundState\cf0 (\cf3 SOUND_STATE_STOP\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SoundMode()\tab Value\par
\b0\fs20 Return the current sound mode. Valid sound mode values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SoundMode\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSoundMode(n)\tab Function\par
\b0\fs20 Set the current sound mode. Valid sound mode values are listed above.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSoundMode\cf0 (\cf3 SOUND_MODE_ONCE\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SoundFrequency()\tab Value\par
\b0\fs20 Return the current sound frequency.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SoundFrequency\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSoundFrequency(n)\tab Function\par
\b0\fs20 Set the current sound frequency.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSoundFrequency\cf0 (\cf4 440\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SoundDuration()\tab Value\par
\b0\fs20 Return the current sound duration.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SoundDuration\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSoundDuration(n)\tab Function\par
\b0\fs20 Set the current sound duration.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSoundDuration\cf0 (\cf4 500\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SoundSampleRate()\tab Value\par
\b0\fs20 Return the current sound sample rate.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SoundSampleRate\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSoundSampleRate(n)\tab Function\par
\b0\fs20 Set the current sound sample rate.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSoundSampleRate\cf0 (\cf4 4000\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SoundVolume()\tab Value\par
\b0\fs20 Return the current sound volume.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 SoundVolume\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSoundVolume(n)\tab Function\par
\b0\fs20 Set the current sound volume.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSoundVolume\cf0 (\cf4 3\cf0 );\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub StopSound()\tab Function\par
\b0\fs20 Stop playback of the current tone or file.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 StopSound\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub\b0\fs20 The NXT ioctrl module encompasses low-level communication between the two processors that control the NXT.\par
\b\fs24\page\super #$AK\nosupersub PowerDown()\tab Function\par
\b0\fs20 Turn off the NXT immediately.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 PowerDown\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SleepNow()\tab Function\par
\b0\fs20 Force the device to go to sleep. Only works if the sleep time is non-zero.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SleepNow\cf0 (); // go to sleep\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RebootInFirmwareMode()\tab Function\par
\b0\fs20 Reboot the NXT in SAMBA or firmware download mode. This function is not likely to be used in a normal NXC program.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 RebootInFirmwareMode\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Wait(time)\tab Function\par
\b0\fs20 Make a task sleep for specified amount of time (in 1000ths of a second). The time argument may be an expression or a constant:\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 Wait\cf0 (\cf4 1000\cf0 ); // wait 1 second\par
\pard\li720\tqr\tx8640\cf1 Wait\cf0 (\cf1 Random\cf0 (\cf4 1000\cf0 )); // wait random time up to 1 second\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub CurrentTick()\tab Value\par
\pard\sb120\b0\fs20 Return an unsigned 32-bit value, which is the current system timing value (called a "tick") in milliseconds.\par
\pard\li720\sb120\f1 x = \cf1 CurrentTick\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub FirstTick()\tab Value\par
\pard\sb120\b0\fs20 Return an unsigned 32-bit value, which is the system timing value (called a "tick") in milliseconds at the time that the program began running.\par
\pard\li720\sb120\f1 x = \cf1 FirstTick\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SleepTime()\tab Value\par
\pard\sb120\b0\fs20 Return the number of minutes that the NXT will remain on before it automatically shuts down.\par
\pard\li720\sb120\f1 x = \cf1 SleepTime\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SleepTimer()\tab Value\par
\pard\sb120\b0\fs20 Return the number of minutes left in the countdown to zero from the original SleepTime value. When the SleepTimer value reaches zero the NXT will shutdown.\par
\pard\li720\sb120\f1 x = \cf1 SleepTimer\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ResetSleepTimer()\tab Function\par
\pard\sb120\b0\fs20 Reset the system sleep timer back to the SleepTime value. Executing this function periodically can keep the NXT from shutting down while a program is running.\par
\pard\li720\sb120\cf1\f1 ResetSleepTimer\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSleepTime(minutes)\tab Function\par
\b0\fs20 Set the sleep timeout the requested number of minutes. Specifying 0 minutes disables the sleep feature.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetSleepTime\cf0 (5); // sleep after 5 minutes\par
\pard\li720\tqr\tx8640\cf1 SetSleepTime\cf0 (0) ; // disable sleep time\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSleepTimer(minutes)\tab Function\par
\pard\sb120\b0\fs20 Set the system sleep timer to the specified number of minutes.\par
\pard\li720\sb120\cf1\f1 SetSleepTimer\cf0 (3);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub StopAllTasks()\tab Function\par
\b0\fs20 Stop all currently running tasks. This will halt the program completely, so any code following this command will be ignored.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 StopAllTasks\cf0 (); // stop the program\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Stop(bvalue)\tab Function\par
\pard\sb120\b0\fs20 Stop the running program if bvalue is true. This will halt the program completely, so any code following this command will be ignored.\par
\pard\li720\sb120\cf1\f1 Stop\cf0 (x == 24); // stop the program if x==24\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Acquire(mutex)\tab Function\par
\pard\sb120\b0\fs20 Acquire the specified mutex variable. If another task already has acquired the mutex then the current task will be suspended until the mutex is released by the other task. This function is used to ensure that the current task has exclusive access to a shared resource, such as the display or a motor. After the current task has finished using the shared resource the program should call Release to allow other tasks to acquire the mutex.\par
\pard\li720\sb120\cf1\f1 Acquire\cf0 (motorMutex); // make sure we have exclusive access\line // use the motors\line\cf1 Release\cf0 (motorMutex);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Release(mutex)\tab Function\par
\pard\sb120\b0\fs20 Release the specified mutex variable. Use this to relinquish a mutex so that it can be acquired by another task. Release should always be called after a matching call to Acquire and as soon as possible after a shared resource is no longer needed.\par
\pard\li720\sb120\cf1\f1 Acquire\cf0 (motorMutex); // make sure we have exclusive access\line // use the motors\line\cf1 Release\cf0 (motorMutex); // release mutex for other tasks\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Precedes(task1, task2, ..., taskN)\tab Function\par
\pard\sb120\b0\fs20 Schedule the specified tasks for execution once the current task has completed executing. The tasks will all execute simultaneously unless other dependencies prevent them from doing so. Generally this function should be called once within a task \endash  preferably at the start of the task definition.\par
\pard\li720\sb120\cf1\f1 Precedes\cf0 (moving, drawing, playing); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Follows(task1, task2, ..., taskN)\tab Function\par
\pard\sb120\b0\fs20 Schedule this task to follow the specified tasks so that it will execute once any of the specified tasks has completed executing. Generally this function should be called once within a task \endash  preferably at the start of the task definition. If multiple tasks declare that they follow the same task then they will all execute simultaneously unless other dependencies prevent them from doing so.\par
\pard\li720\sb120\cf1\f1 Follows\cf0 (main); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ExitTo(task)\tab Function\par
\pard\sb120\b0\fs20 Immediately exit the current task and start executing the specified task.\par
\pard\li720\sb120\cf1\f1 ExitTo\cf0 (nextTask); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub StrToNum(str)\tab Value\par
\pard\sb120\b0\fs20 Return the numeric value specified by the string passed to the function. If the content of the string is not a numeric value then this function returns zero.\par
\pard\li720\sb120\f1 x = \cf1 StrToNum\cf0 (strVal);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub StrLen(str)\tab Value\par
\pard\sb120\b0\fs20 Return the length of the specified string. The length of a string does not include the null terminator at the end of the string.\par
\pard\li720\sb120\f1 x = \cf1 StrLen\cf0 (msg); // return the length of msg\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub StrIndex(str, idx)\tab Value\par
\pard\sb120\b0\fs20 Return the numeric value of the character in the specified string at the specified index.\par
\pard\li720\sb120\f1 x = \cf1 StrIndex\cf0 (msg, 2); // return the value of msg[2]\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub NumToStr(value)\tab Value\par
\pard\sb120\b0\fs20 Return the string representation of the specified numeric value.\par
\pard\li720\sb120\f1 msg = \cf1 NumToStr\cf0 (-2); // returns "-2" in a string\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub FormatNum(fmtstr, value)\tab Value\par
\pard\sb120\b0\fs20 Return the formatted string using the format and value. Use standard numeric sprintf format specifiers within the format string.\par
\pard\li720\sb120\f1 msg = \cf1 FormatNum\cf0 ("value = %d", x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub StrCat(str1, str2, ..., strN)\tab Value\par
\pard\sb120\b0\fs20 Return a string which is the result of concatenating all of the string arguments together.\par
\pard\li720\sb120\f1 msg = \cf1 StrCat\cf0 ("test", "please"); // returns "testplease"\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SubStr(string, idx, len)\tab Value\par
\pard\sb120\b0\fs20 Return a sub-string from the specified input string starting at idx and including the specified number of characters.\par
\pard\li720\sb120\f1 msg = \cf1 SubStr\cf0 ("test", 1, 2); // returns "es"\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub StrReplace(string, idx, newStr)\tab Value\par
\pard\sb120\b0\fs20 Return a string with the part of the string replaced (starting at the specified index) with the contents of the new string value provided in the third argument.\par
\pard\li720\sb120\f1 msg = \cf1 StrReplace\cf0 ("testing", 3, "xx"); // returns "tesxxng"\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Flatten(value)\tab Value\par
\pard\sb120\b0\fs20 Return a string containing the byte representation of the specified value.\par
\pard\li720\sb120\f1 msg = \cf1 Flatten\cf0 (48); // returns "0" since 48 == ascii("0")\par
msg = \cf1 Flatten\cf0 (12337); // returns "10" (little-endian)\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub FlattenVar(anytype)\tab Value\par
\pard\sb120\b0\fs20 Return a string containing the byte representation of the specified variable.\par
\pard\li720\sb120\f1 stringValue = \cf1 FlattenVar\cf0 (myStruct);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub UnflattenVar(string, anytype)\tab Function\par
\pard\sb120\b0\fs20 Convert a string containing the byte representation of the specified variable back into the original variable type.\par
\pard\li720\sb120\cf1\f1 UnflattenVar\cf0 (stringValue, myStruct);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ByteArrayToStr(arr)\tab Value\par
\pard\sb120\b0\fs20 Convert the specified array to a string by appending a null terminator to the end of the array elements. The array must be a one-dimensional array of byte.\par
\pard\li720\sb120\f1 myStr = \cf1 ByteArrayToStr\cf0 (myArray);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ByteArrayToStrEx(arr, out str)\tab Function\par
\pard\sb120\b0\fs20 Convert the specified array to a string by appending a null terminator to the end of the array elements. The array must be a one-dimensional array of byte.\par
\pard\li720\sb120\cf1\f1 ByteArrayToStrEx\cf0 (myArray, myStr);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub StrToByteArray(str, out arr)\tab Function\par
\pard\sb120\b0\fs20 Convert the specified string to an array of byte by removing the null terminator at the end of the string. The output array variable must be a one-dimensional array of byte.\par
\pard\li720\sb120\cf1\f1 StrToByteArray\cf0 (myStr, myArray);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ArrayLen(array)\tab Value\par
\pard\sb120\b0\fs20 Return the length of the specified array.\par
\pard\li720\sb120\f1 x = \cf1 ArrayLen\cf0 (myArray); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ArrayInit(array, value, count)\tab Function\par
\pard\sb120\b0\fs20 Initialize the array to contain count elements with each element equal to the value provided. To initialize a multi-dimensional array, the value should be an array of N-1 dimensions, where N is the number of dimensions in the array being initialized.\par
\pard\li720\sb120\cf1\f1 ArrayInit\cf0 (myArray, 0, 10); // 10 elements == zero\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ArraySubset(out aout, asrc, idx, len)\tab Function\par
\pard\sb120\b0\fs20 Copy a subset of the source array starting at the specified index and containing the specified number of elements into the destination array.\par
\pard\li720\sb120\cf1\f1 ArraySubset\cf0 (myArray, srcArray, 2, 5); copy 5 elements\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ArrayBuild(out aout, src1 [, src2, \'85, srcN])\tab Function\par
\pard\sb120\b0\fs20 Build a new array from the specified source(s). The sources can be of any type. If a source is an array then all of its elements are added to the output array.\par
\pard\li720\sb120\cf1\f1 ArrayBuild\cf0 (myArray, src1, src2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Random(n)\tab Value\par
\b0\fs20 Return an unsigned 16-bit random number between 0 and n (exclusive). N can be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 Random\cf0 (10); // return a value of 0..9\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Random()\tab Value\par
\pard\sb120\b0\fs20 Return a signed 16-bit random number.\par
\pard\li720\sb120\f1 x = \cf1 Random\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Sqrt(x)\tab Value\par
\pard\sb120\b0\fs20 Return the square root of the specified value.\par
\pard\li720\sb120\f1 x = \cf1 Sqrt\cf0 (x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Sin(degrees)\tab Value\par
\pard\sb120\b0\fs20 Return the sine of the specified degrees value. The result is 100 times the sine value (-100..100).\par
\pard\li720\sb120\f1 x = \cf1 Sin\cf0 (theta);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Cos(degrees)\tab Value\par
\pard\sb120\b0\fs20 Return the cosine of the specified degrees value. The result is 100 times the cosine value (-100..100).\par
\pard\li720\sb120\f1 x = \cf1 Cos\cf0 (y);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Asin(value)\tab Value\par
\pard\sb120\b0\fs20 Return the inverse sine of the specified value (-100..100). The result is degrees (-90..90).\par
\pard\li720\sb120\f1 deg = \cf1 Asin\cf0 (80);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Acos(value)\tab Value\par
\pard\sb120\b0\fs20 Return the inverse cosine of the specified value (-100..100). The result is degrees (0..180).\par
\pard\li720\sb120\f1 deg = \cf1 Acos\cf0 (0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub bcd2dec(byte bcdValue)\tab Value\par
\pard\sb120\b0\fs20 Return the decimal equivalent of the binary coded decimal value provided.\par
\pard\li720\sb120\f1 dec = \cf1 bcd2dec\cf0 (0x3a);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BatteryLevel()\tab Value\par
\b0\fs20 Return the battery level in millivolts.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 BatteryLevel\cf0 ();\par
\pard\sb120\b\f0\fs24\page\super #$AK\nosupersub\b0\fs20 There are several standard structures that are defined by the NXC API for use with calls to low-level system functions defined within the NXT firmware. These structures are the means for passing values into the system functions and for returning values from the system functions. In order to call a system function you will need to declare a variable of the required system function structure type, set the structure members as needed by the system function, call the function, and then read the results, if desired.\par
Many of these system functions are wrapped into higher level NXC API functions so that the details are hidden from view. Using these low-level API calls you can improve the speed of your programs a little.\par
If you install the NBC/NXC enhanced standard NXT firmware on your NXT all the screen drawing system function also supports clearing pixels in addition to setting them. To switch from setting pixels to clearing pixels just specify the \cf3 DRAW_OPT_CLEAR_PIXELS\cf0  value (0x0004) in the Options member of the structures. This value can be ORed together with the \cf3 DRAW_OPT_CLEAR_WHOLE_SCREEN\cf0  value (0x0001) if desired. Also, some of the system functions and their associated structures are only supported by the NBC/NXC enhanced standard NXT firmware.  These functions are marked with (+) to indicate this additional requirement.\par
The first two structures define types are used within several other structures required by the screen drawing system functions.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct LocationType \{\line   int X;\line   int Y;\line\};\par
struct SizeType \{\line   int Width;\line   int Height;\line\};\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysDrawText(DrawTextType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw text on the NXT LCD given the parameters you pass in via the DrawTextType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22  struct DrawTextType \{\line   char Result;\line   LocationType Location;\line   string Text;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 DrawTextType dtArgs;\line dtArgs.Location.X = 0;\line dtArgs.Location.Y = \cf3 LCD_LINE1\cf0 ;\line dtArgs.Text = "Please Work";\line dtArgs.Options = 0x01; // clear before drawing\line\cf1 SysDrawText\cf0 (dtArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysDrawPoint(DrawPointType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a pixel on the NXT LCD given the parameters you pass in via the DrawPointType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct DrawPointType \{\line   char Result;\line   LocationType Location;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 DrawPointType dpArgs;\line dpArgs.Location.X = 20;\line dpArgs.Location.Y = 20;\line dpArgs.Options = 0x04; // clear this pixel\line\cf1 SysDrawPoint\cf0 (dpArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysDrawLine(DrawLineType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a line on the NXT LCD given the parameters you pass in via the DrawLineType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct DrawLineType \{\line   char Result;\line   LocationType StartLoc;\line   LocationType EndLoc;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 DrawLineType dlArgs;\line dlArgs.StartLoc.X = 20;\line dlArgs.StartLoc.Y = 20;\line dlArgs.EndLoc.X = 60;\line dlArgs.EndLoc.Y = 60;\line dlArgs.Options = 0x01; // clear before drawing\line\cf1 SysDrawLine\cf0 (dlArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysDrawCircle(DrawCircleType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a circle on the NXT LCD given the parameters you pass in via the DrawCircleType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct DrawCircleType \{\line   char Result;\line   LocationType Center;\line   byte Size;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 DrawCircleType dcArgs;\line dcArgs.Center.X = 20;\line dcArgs.Center.Y = 20;\line dcArgs.Size = 10; // radius\line dcArgs.Options = 0x01; // clear before drawing\line\cf1 SysDrawCircle\cf0 (dcArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysDrawRect(DrawRectType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a rectangle on the NXT LCD given the parameters you pass in via the DrawRectType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct DrawRectType \{\line   char Result;\line   LocationType Location;\line   SizeType Size;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 DrawRectType drArgs;\line drArgs.Location.X = 20;\line drArgs.Location.Y = 20;\line drArgs.Size.Width = 20;\line drArgs.Size.Height = 10;\line drArgs.Options = 0x00; // do not clear before drawing\line\cf1 SysDrawRect\cf0 (drArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysDrawGraphic(DrawGraphicType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a graphic image (RIC file) on the NXT LCD given the parameters you pass in via the DrawGraphicType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct DrawGraphicType \{\line   char Result;\line   LocationType Location;\line   string Filename;\line   int Variables[];\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 DrawGraphicType dgArgs;\line dgArgs.Location.X = 20;\line dgArgs.Location.Y = 20;\line dgArgs.Filename = "image.ric";\line\cf1 ArrayInit\cf0 (dgArgs.Variables, 0, 10); // 10 zeros\line dgArgs.Variables[0] = 12;\line dgArgs.Variables[1] = 14; // etc...\line dgArgs.Options = 0x00; // do not clear before drawing\line\cf1 SysDrawGraphic\cf0 (dgArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysSetScreenMode(SetScreenModeType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you set the screen mode of the NXT LCD given the parameters you pass in via the SetScreenModeType structure. The standard NXT firmware only supports setting the ScreenMode to \f2\fs22 SCREEN_MODE_RESTORE\f0\fs20 , which has a value of 0x00. If you install the NBC/NXC enhanced standard NXT firmware this system function also supports setting the ScreenMode to \f2\fs22 SCREEN_MODE_CLEAR\f0\fs20 , which has a value of 0x01. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct SetScreenModeType \{\line   char Result;\line   unsigned long ScreenMode;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 SetScreenModeType ssmArgs;\line ssmArgs.ScreenMode = 0x00; // restore default NXT screen\line\cf1 SysSetScreenMode\cf0 (ssmArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysSoundPlayFile(SoundPlayFileType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you play a sound file given the parameters you pass in via the SoundPlayFileType structure. The sound file can either be an RSO file containing PCM or compressed ADPCM samples or it can be an NXT melody (RMD) file containing frequency and duration values. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct SoundPlayFileType \{\line   char Result;\line   string Filename;\line   bool Loop;\line   byte SoundLevel;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 SoundPlayFileType spfArgs;\line spfArgs.Filename = "hello.rso";\line spfArgs.Loop = false;\line spfArgs.SoundLevel = 3; \line\cf1 SysSoundPlayFile\cf0 (spfArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysSoundPlayTone(SoundPlayToneType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you play a tone given the parameters you pass in via the SoundPlayToneType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct SoundPlayToneType \{\line   char Result;\line   unsigned int Frequency;\line   unsigned int Duration;\line   bool Loop;\line   byte SoundLevel;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 SoundPlayToneType sptArgs;\line sptArgs.Frequency = 440;\line sptArgs.Duration = 1000; // 1 second\line sptArgs.Loop = false;\line sptArgs.SoundLevel = 3; \line\cf1 SysSoundPlayTone\cf0 (sptArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysSoundGetState(SoundGetStateType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you retrieve information about the sound module state via the SoundGetStateType structure. Constants for sound state are \cf3\f2\fs22 SOUND_STATE_IDLE\cf0\f0\fs20 , \cf3\f2\fs22 SOUND_STATE_FILE\cf0\f0\fs20 , \cf3\f2\fs22 SOUND_STATE_TONE\cf0\f0\fs20 , and \cf3\f2\fs22 SOUND_STATE_STOP\cf0\f0\fs20 . Constants for sound flags are \cf3\f2\fs22 SOUND_FLAGS_IDLE\cf0\f0\fs20 , \cf3\f2\fs22 SOUND_FLAGS_UPDATE\cf0\f0\fs20 , and \cf3\f2\fs22 SOUND_FLAGS_RUNNING\cf0\f0\fs20 . The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct SoundGetStateType \{\line   byte State;\line   byte Flags;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 SoundGetStateType sgsArgs;\line\cf1 SysSoundGetState\cf0 (sgsArgs);\line if (sgsArgs.State == \cf3 SOUND_STATE_IDLE\cf0 ) \{/* do stuff */\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysSoundSetState(SoundSetStateType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you set sound module state settings via the SoundSetStateType structure. Constants for sound state are \cf3\f2\fs22 SOUND_STATE_IDLE\cf0\f0\fs20 , \cf3\f2\fs22 SOUND_STATE_FILE\cf0\f0\fs20 , \cf3\f2\fs22 SOUND_STATE_TONE\cf0\f0\fs20 , and \cf3\f2\fs22 SOUND_STATE_STOP\cf0\f0\fs20 . Constants for sound flags are \cf3\f2\fs22 SOUND_FLAGS_IDLE\cf0\f0\fs20 , \cf3\f2\fs22 SOUND_FLAGS_UPDATE\cf0\f0\fs20 , and \cf3\f2\fs22 SOUND_FLAGS_RUNNING\cf0\f0\fs20 . The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct SoundSetStateType \{\line   byte Result;\line   byte State;\line   byte Flags;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 SoundSetStateType sssArgs;\line sssArgs.State = \cf3 SOUND_STATE_STOP\cf0 ;\line\cf1 SysSoundSetState\cf0 (sssArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysReadButton(ReadButtonType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read button state information via the ReadButtonType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct ReadButtonType \{\line   char Result;\line   byte Index;\line   bool Pressed;\line   byte Count;\line   bool Reset; // reset count after reading?\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 ReadButtonType rbArgs;\line rbArgs.Index = \cf3 BTNRIGHT\cf0 ;\line\cf1 SysReadButton\cf0 (rbArgs);\line if (rbArgs.Pressed) \{/* do something */\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysRandomNumber(RandomNumberType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you obtain a random number via the RandomNumberType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct RandomNumberType \{\line   int Result;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 RandomNumberType rnArgs;\line\cf1 SysRandomNumber\cf0 (rnArgs);\line int myRandomValue = rnArgs.Result;\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysGetStartTick(GetStartTickType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you obtain the tick value at the time your program began executing via the GetStartTickType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct GetStartTickType \{\line   unsigned long Result;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 GetStartTickType gstArgs;\line\cf1 SysGetStartTick\cf0 (gstArgs);\line unsigned long myStart = gstArgs.Result;\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysKeepAlive(KeepAliveType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you reset the sleep timer via the KeepAliveType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct KeepAliveType \{\line   unsigned long Result;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 KeepAliveType kaArgs;\line\cf1 SysKeepAlive\cf0 (kaArgs); // reset sleep timer\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileOpenWrite(FileOpenType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you create a file that you can write to using the values specified via the FileOpenType structure. The structure type declaration is shown below. Use the FileHandle return value for subsequent file write operations. The desired maximum file capacity in bytes is specified via the Length member.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileOpenType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Filename;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileOpenType foArgs;\line foArgs.Filename = "myfile.txt";\line foArgs.Length = 256; // create with capacity for 256 bytes\line\cf1 SysFileOpenWrite\cf0 (foArgs); // create the file\line if (foArgs.Result == \cf3 NO_ERR\cf0 ) \{\line   // write to the file using FileHandle\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileOpenAppend(FileOpenType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you open an existing file that you can write to using the values specified via the FileOpenType structure. The structure type declaration is shown below. Use the FileHandle return value for subsequent file write operations.  The available length remaining in the file is returned via the Length member.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileOpenType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Filename;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileOpenType foArgs;\line foArgs.Filename = "myfile.txt";\line\cf1 SysFileOpenAppend\cf0 (foArgs); // open the file\line if (foArgs.Result == \cf3 NO_ERR\cf0 ) \{\line   // write to the file using FileHandle\line   // up to the remaining available length in Length\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileOpenRead(FileOpenType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you open an existing file for reading using the values specified via the FileOpenType structure. The structure type declaration is shown below. Use the FileHandle return value for subsequent file read operations.  The number of bytes that can be read from the file is returned via the Length member.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileOpenType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Filename;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileOpenType foArgs;\line foArgs.Filename = "myfile.txt";\line\cf1 SysFileOpenRead\cf0 (foArgs); // open the file for reading\line if (foArgs.Result == \cf3 NO_ERR\cf0 ) \{\line   // read data from the file using FileHandle\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileRead(FileReadWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read from a file using the values specified via the FileReadWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileReadWriteType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Buffer;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileReadWriteType frArgs;\line frArgs.FileHandle = foArgs.FileHandle;\line frArgs.Length = 12; // number of bytes to read\line\cf1 SysFileRead\cf0 (frArgs); \line if (frArgs.Result == \cf3 NO_ERR\cf0 ) \{\line   \cf1 TextOut\cf0 (0, \cf3 LCD_LINE1\cf0 , frArgs.Buffer);\line   // show how many bytes were actually read\line   \cf1 NumOut\cf0 (0, \cf3 LCD_LINE2\cf0 , frArgs.Length);\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileWrite(FileReadWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write to a file using the values specified via the FileReadWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileReadWriteType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Buffer;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileReadWriteType fwArgs;\line fwArgs.FileHandle = foArgs.FileHandle;\line fwArgs.Buffer = "data to write";\line\cf1 SysFileWrite\cf0 (fwArgs); \line if (fwArgs.Result == \cf3 NO_ERR\cf0 ) \{\line   // display number of bytes written\line   \cf1 NumOut\cf0 (0, \cf3 LCD_LINE1\cf0 , fwArgs.Length);\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileClose(FileCloseType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you close a file using the values specified via the FileCloseType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileCloseType \{\line   unsigned int Result;\line   byte FileHandle;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileCloseType fcArgs;\line fcArgs.FileHandle = foArgs.FileHandle;\line\cf1 SysFileClose\cf0 (fcArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileResolveHandle(FileResolveHandleType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you resolve the handle of a file using the values specified via the FileResolveHandleType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileResolveHandleType \{\line   unsigned int Result;\line   byte FileHandle;\line   bool WriteHandle;\line   string Filename;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileResolveHandleType frhArgs;\line frhArgs.Filename = "myfile.txt";\line\cf1 SysFileResolveHandle\cf0 (frhArgs);\line if (frhArgs.Result == \cf3 LDR_SUCCESS\cf0 ) \{\line   // use the FileHandle as needed\line   if (frhArgs.WriteHandle) \{\line     // file is open for writing\line   \}\line   else \{\line     // file is open for reading\line   \}\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileRename(FileRenameType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you rename a file using the values specified via the FileRenameType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileRenameType \{\line   unsigned int Result;\line   string OldFilename;\line   string NewFilename;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileRenameType frArgs;\line frArgs.OldFilename = "myfile.txt";\line frArgs.NewFilename = "myfile2.txt";\line\cf1 SysFileRename\cf0 (frArgs);\line if (frArgs.Result == \cf3 LDR_SUCCESS\cf0 ) \{ /* do something */ \}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysFileDelete(FileDeleteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you delete a file using the values specified via the FileDeleteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct FileDeleteType \{\line   unsigned int Result;\line   string Filename;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 FileDeleteType fdArgs;\line fdArgs.Filename = "myfile.txt";\line\cf1 SysFileDelete\cf0 (fdArgs); // delete the file\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysCommLSWrite(CommLSWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write to an I2C (Lowspeed) sensor using the values specified via the CommLSWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct CommLSWriteType \{\line   char Result;\line   byte Port;\line   byte Buffer[];\line   byte ReturnLen;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 CommLSWriteType args;\line args.Port = \cf3 S1\cf0 ;\line args.Buffer = myBuf;\line args.ReturnLen = 8;\line\cf1 SysCommLSWrite\cf0 (args);\line // check Result for error status\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysCommLSCheckStatus(CommLSCheckStatusType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you check the status of an I2C (Lowspeed) sensor transaction using the values specified via the CommLSCheckStatusType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct CommLSCheckStatusType \{\line   char Result;\line   byte Port;\line   byte BytesReady;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 CommLSCheckStatusType args;\line args.Port = \cf3 S1\cf0 ;\line\cf1 SysCommLSCheckStatus\cf0 (args);\line // is the status (Result) IDLE?\line if (args.Result == \cf3 LOWSPEED_IDLE\cf0 ) \{ /* proceed */ \}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysCommLSRead(CommLSReadType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read from an I2C (Lowspeed) sensor using the values specified via the CommLSReadType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct CommLSReadType \{\line   char Result;\line   byte Port;\line   byte Buffer[];\line   byte BufferLen;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 CommLSReadType args;\line args.Port = \cf3 S1\cf0 ;\line args.Buffer = myBuf;\line args.BufferLen = 8;\line\cf1 SysCommLSRead\cf0 (args);\line // check Result for error status & use Buffer contents\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysMessageWrite(MessageWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write a message to a queue (aka mailbox) using the values specified via the MessageWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct MessageWriteType \{\line   char Result;\line   byte QueueID;\line   string Message;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 MessageWriteType args;\line args.QueueID = \cf3 MAILBOX1\cf0 ; // 0\line args.Message = "testing";\line\cf1 SysMessageWrite\cf0 (args);\line // check Result for error status\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysMessageRead(MessageReadType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read a message from a queue (aka mailbox) using the values specified via the MessageReadType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct MessageReadType \{\line   char Result;\line   byte QueueID;\line   bool Remove;\line   string Message;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 MessageReadType args;\line args.QueueID = \cf3 MAILBOX1\cf0 ; // 0\line args.Remove = true;\line\cf1 SysMessageRead\cf0 (args);\line if (args.Result == \cf3 NO_ERR\cf0 ) \{\line   \cf1 TextOut\cf0 (0, \cf3 LCD_LINE1\cf0 , args.Message);\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysCommBTWrite(CommBTWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write to a Bluetooth connection using the values specified via the CommBTWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct CommBTWriteType \{\line   char Result;\line   byte Connection;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 CommBTWriteType args;\line args.Connection = 1;\line args.Buffer = myData;\line\cf1 SysCommBTWrite\cf0 (args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysCommBTCheckStatus(CommBTCheckStatusType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you check the status of a Bluetooth connection using the values specified via the CommBTCheckStatusType structure. The structure type declaration is shown below.  Possible values for Result include \cf3\f2\fs22 ERR_INVALID_PORT\cf0\f0\fs20 , \cf3\f2\fs22 STAT_COMM_PENDING\cf0\f0\fs20 , \cf3\f2\fs22 ERR_COMM_CHAN_NOT_READY\cf0\f0\fs20 , and \cf3\f2\fs22 LDR_SUCCESS\cf0\f0\fs20   (0).\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct CommBTCheckStatusType \{\line   char Result;\line   byte Connection;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 CommBTCheckStatusType args;\line args.Connection = 1;\line\cf1 SysCommBTCheckStatus\cf0 (args);\line if (args.Result == \cf3 LDR_SUCCESS\cf0 ) \{ /* do something */ \} \par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysIOMapRead(IOMapReadType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read data from a firmware module's IOMap using the values specified via the IOMapReadType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct IOMapReadType \{\line   char Result;\line   string ModuleName;\line   unsigned int Offset;\line   unsigned int Count;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 IOMapReadType args;\line args.ModuleName = \cf3 CommandModuleName\cf0 ;\line args.Offset = \cf3 CommandOffsetTick\cf0 ;\line args.Count = 4; // this value happens to be 4 bytes long\line\cf1 SysIOMapRead\cf0 (args);\line if (args.Result == \cf3 NO_ERR\cf0 ) \{ /* do something with data */ \} \par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysIOMapWrite(IOMapWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write data to a firmware module's IOMap using the values specified via the IOMapWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct IOMapWriteType \{\line   char Result;\line   string ModuleName;\line   unsigned int Offset;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 IOMapWriteType args;\line args.ModuleName = \cf3 SoundModuleName\cf0 ;\line args.Offset = \cf3 SoundOffsetSampleRate\cf0 ;\line args.Buffer = theData;\line\cf1 SysIOMapWrite\cf0 (args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysIOMapReadByID(IOMapReadByIDType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you read data from a firmware module's IOMap using the values specified via the IOMapReadByIDType structure. The structure type declaration is shown below. This function can be as much as three times faster than using SysIOMapRead since it does not have to do a string lookup using the ModuleName.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct IOMapReadByIDType \{\line   char Result;\line   unsigned long ModuleID;\line   unsigned int Offset;\line   unsigned int Count;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 IOMapReadByIDType args;\line args.ModuleID = \cf3 CommandModuleID\cf0 ;\line args.Offset = \cf3 CommandOffsetTick\cf0 ;\line args.Count = 4; // this value happens to be 4 bytes long\line\cf1 SysIOMapReadByID\cf0 (args);\line if (args.Result == \cf3 NO_ERR\cf0 ) \{ /* do something with data */ \} \par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysIOMapWriteByID(IOMapWriteByIDType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you write data to a firmware module's IOMap using the values specified via the IOMapWriteByIDType structure. The structure type declaration is shown below. This function can be as much as three times faster than using SysIOMapWrite since it does not have to do a string lookup using the ModuleName.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct IOMapWriteByIDType \{\line   char Result;\line   unsigned long ModuleID;\line   unsigned int Offset;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 IOMapWriteByIDType args;\line args.ModuleID = \cf3 SoundModuleID\cf0 ;\line args.Offset = \cf3 SoundOffsetSampleRate\cf0 ;\line args.Buffer = theData;\line\cf1 SysIOMapWriteByID\cf0 (args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysDisplayExecuteFunction(DisplayExecuteFunctionType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you directly execute the Display module's primary drawing function using the values specified via the DisplayExecuteFunctionType structure. The structure type declaration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct DisplayExecuteFunctionType \{\line   byte Status;\line   byte Cmd;\line   bool On;\line   byte X1;\line   byte Y1;\line   byte X2;\line   byte Y2;\line\};\par
\pard\sb120\tx3060\tx5760\expndtw0\b\f0\fs20 Cmd\tab Meaning\tab Expected parameters\par
\pard\tx3060\tx5760\cf3\b0 DISPLAY_ERASE_ALL\cf0\tab erase entire screen\tab ()\par
\cf3 DISPLAY_PIXEL\cf0\tab set pixel (on/off)\tab (true/false,X1,Y1,x,x)\par
\cf3 DISPLAY_HORIZONTAL_LINE\cf0\tab draw horizontal line\tab (true/false,X1,Y1,X2,x)\par
\cf3 DISPLAY_VERTICAL_LINE\cf0\tab draw vertical line\tab (true/false,X1,Y1,x,Y2)\par
\cf3 DISPLAY_CHAR\cf0\tab draw char (actual font)\tab (true/false,X1,Y1,Char,x)\par
\cf3 DISPLAY_ERASE_LINE\cf0\tab erase a single line\tab (x,LINE,x,x,x)\par
\cf3 DISPLAY_FILL_REGION\cf0\tab fill screen region\tab (true/false,X1,Y1,X2,Y2)\par
\cf3 DISPLAY_FILLED_FRAME\cf0\tab draw a frame (on / off)\tab (true/false,X1,Y1,X2,Y2)\par
\pard\sb120 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 DisplayExecuteFunctionType args;\line args.Cmd = \cf3 DISPLAY_ERASE_ALL\cf0 ;\line\cf1 SysDisplayExecuteFunction\cf0 (args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysCommExecuteFunction(CommExecuteFunctionType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you directly execute the Comm module's primary function using the values specified via the CommExecuteFunctionType structure. The structure type declaration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct CommExecuteFunctionType \{\line   unsigned int Result;\line   byte Cmd;\line   byte Param1;\line   byte Param2;\line   byte Param3;\line   string Name;\line   unsigned int RetVal;\line\};\par
\pard\sb120\tx2520\tx5940\expndtw0\b\f0\fs20 Cmd\tab Meaning\tab (Param1,Param2,Param3,Name)\par
\pard\tx2520\tx5940\cf3\b0 INTF_SENDFILE\cf0\tab Send a file over a Bluetooth connection\tab (Connection,x,x,Filename)\par
\cf3 INTF_SEARCH\cf0\tab Search for Bluetooth devices\tab (x,x,x,x)\par
\cf3 INTF_STOPSEARCH\cf0\tab Stop searching for Bluetooth devices\tab (x,x,x,x)\par
\cf3 INTF_CONNECT\cf0\tab Connect to a Bluetooth device\tab (DeviceIndex,Connection,x,x)\par
\cf3 INTF_DISCONNECT\cf0\tab Disconnect a Bluetooth device\tab (Connection,x,x,x)\par
\cf3 INTF_DISCONNECTALL\cf0\tab Disconnect all Bluetooth devices\tab (x,x,x,x)\par
\cf3 INTF_REMOVEDEVICE\cf0\tab Remove device from My Contacts\tab (DeviceIndex,x,x,x)\par
\cf3 INTF_VISIBILITY\cf0\tab Set Bluetooth visibility\tab (true/false,x,x,x)\par
\cf3 INTF_SETCMDMODE\cf0\tab Set command mode\tab (x,x,x,x)\par
\cf3 INTF_OPENSTREAM\cf0\tab Open a stream\tab (x,Connection,x,x)\par
\cf3 INTF_SENDDATA\cf0\tab Send data\tab (Length, Connection, WaitForIt, Buffer)\par
\cf3 INTF_FACTORYRESET\cf0\tab Bluetooth factory reset\tab (x,x,x,x)\par
\cf3 INTF_BTON\cf0\tab Turn Bluetooth on\tab (x,x,x,x)\par
\cf3 INTF_BTOFF\cf0\tab Turn Bluetooth off\tab (x,x,x,x)\par
\cf3 INTF_SETBTNAME\cf0\tab Set Bluetooth name\tab (x,x,x,x)\par
\cf3 INTF_EXTREAD\cf0\tab Handle external? read\tab (x,x,x,x)\par
\cf3 INTF_PINREQ\cf0\tab Handle Blueooth PIN request\tab (x,x,x,x)\par
\cf3 INTF_CONNECTREQ\cf0\tab Handle Bluetooth connect request\tab (x,x,x,x)\par
\pard\sb120 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 CommExecuteFunctionType args;\line args.Cmd = \cf3 INTF_BTOFF\cf0 ;\line\cf1 SysCommExecuteFunction\cf0 (args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysLoaderExecuteFunction(LoaderExecuteFunctionType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you directly execute the Loader module's primary function using the values specified via the LoaderExecuteFunctionType structure. The structure type declaration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 struct LoaderExecuteFunctionType \{\line   unsigned int Result;\line   byte Cmd;\line   string Filename;\line   byte Buffer[];\line   unsigned long Length;\line\};\par
\pard\sb120\tx3358\tx6228\expndtw0\b\f0\fs20 Cmd\tab Meaning\tab Expected Parameters\par
\pard\tx3358\tx6228\cf3\b0 LDR_CMD_OPENREAD\cf0\tab Open a file for reading\tab (Filename, Length)\par
\cf3 LDR_CMD_OPENWRITE\cf0\tab Creat a file\tab (Filename, Length)\par
\cf3 LDR_CMD_READ\cf0\tab Read from a file\tab (Filename, Buffer, Length)\par
\cf3 LDR_CMD_WRITE\cf0\tab Write to a file\tab (Filename, Buffer, Length)\par
\cf3 LDR_CMD_CLOSE\cf0\tab Close a file\tab (Filename)\par
\cf3\lang1040 LDR_CMD_DELETE\cf0\tab Delete a file\tab (Filename)\par
\cf3\lang1033 LDR_CMD_FINDFIRST\cf0\tab Start iterating files\tab (Filename, Buffer, Length)\par
\cf3 LDR_CMD_FINDNEXT\cf0\tab Continue iterating files\tab (Filename, Buffer, Length)\par
\cf3 LDR_CMD_OPENWRITELINEAR\cf0\tab Create a linear file\tab (Filename, Length)\par
\cf3 LDR_CMD_OPENREADLINEAR\cf0\tab Read a linear file\tab (Filename, Buffer, Length)\par
\cf3 LDR_CMD_OPENAPPENDDATA\cf0\tab Open a file for writing\tab (Filename, Length)\par
\cf3 LDR_CMD_FINDFIRSTMODULE\cf0\tab Start iterating modules\tab (Filename, Buffer)\par
\cf3 LDR_CMD_FINDNEXTMODULE\cf0\tab Continue iterating modules\tab (Buffer)\par
\cf3 LDR_CMD_CLOSEMODHANDLE\cf0\tab Close module handle\tab ()\par
\cf3 LDR_CMD_IOMAPREAD\cf0\tab Read IOMap data\tab (Filename, Buffer, Length)\par
\cf3 LDR_CMD_IOMAPWRITE\cf0\tab Write IOMap data\tab (Filename, Buffer, Length)\par
\cf3 LDR_CMD_DELETEUSERFLASH\cf0\tab Delete all files\tab ()\par
\cf3 LDR_CMD_RENAMEFILE\cf0\tab Rename file\tab (Filename, Buffer, Length)\par
\pard\sb120 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 LoaderExecuteFunctionType args;\line args.Cmd = 0xA0; // delete user flash\line\cf1 SysLoaderExecuteFunction\cf0 (args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SysCall(funcID, args)\tab Function\par
\pard\sb120\b0\fs20 This generic macro can be used to call any system function. No type checking is performed so you need to make sure you use the correct structure type given the selected system function ID. This is, however, the fastest possible way to call a system function in NXC. Function ID constants that can be used with this API call are: \cf3 FileOpenRead\cf0 , \cf3 FileOpenWrite\cf0 , \cf3 FileOpenAppend\cf0 , \cf3 FileRead\cf0 , \cf3 FileWrite\cf0 , \cf3 FileClose\cf0 , \cf3 FileResolveHandle\cf0 , \cf3 FileRename\cf0 , \cf3 FileDelete\cf0 , \cf3 SoundPlayFile\cf0 , \cf3 SoundPlayTone\cf0 , \cf3 SoundGetState\cf0 , \cf3 SoundSetState\cf0 , \cf3 DrawText\cf0 , \cf3 DrawPoint\cf0 , \cf3 DrawLine\cf0 , \cf3 DrawCircle\cf0 , \cf3 DrawRect\cf0 , \cf3 DrawGraphic\cf0 , \cf3 SetScreenMode\cf0 , \cf3 ReadButton\cf0 , \cf3 CommLSWrite\cf0 , \cf3 CommLSRead\cf0 , \cf3 CommLSCheckStatus\cf0 , \cf3 RandomNumber\cf0 , \cf3 GetStartTick\cf0 , \cf3 MessageWrite\cf0 , \cf3 MessageRead\cf0 , \cf3 CommBTCheckStatus\cf0 , \cf3 CommBTWrite\cf0 , \cf3 KeepAlive\cf0 , \cf3 IOMapRead\cf0 , \cf3 IOMapWrite\cf0 , \cf3 IOMapReadByID\cf0 , \cf3 IOMapWriteByID\cf0 , \cf3 DisplayExecuteFunction\cf0 , \cf3 CommExecuteFunction\cf0 , and \cf3 LoaderExecuteFunction\cf0 .\par
\pard\hyphpar0\li720\ri720\sb120\sa120\expndtw-10\f1\fs22 DrawTextType dtArgs;\line dtArgs.Location.X = 0;\line dtArgs.Location.Y = \cf3 LCD_LINE1\cf0 ;\line dtArgs.Text = "Please Work";\line\cf1 SysCall\cf0 (\cf3 DrawText\cf0 , dtArgs);\par
\pard\expndtw0\b\f0\fs24\page\super #$AK\nosupersub\b0\fs20 The NXT display module encompasses support for drawing to the NXT LCD. The NXT supports drawing points, lines, rectangles, and circles on the LCD. It supports drawing graphic icon files on the screen as well as text and numbers.\par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\cf3\b0 DisplayModuleName\cf0\tab "Display.mod"\par
\cf3 DisplayModuleID\cf0\tab 0x000A0001\par
\pard\sb120\tqr\tx8640 The LCD screen has its origin (0, 0) at the bottom left-hand corner of the screen with the positive Y-axis extending upward and the positive X-axis extending toward the right. The NXC API provides constants for use in the \cf1 NumOut\cf0  and \cf1 TextOut\cf0  functions which make it possible to specify LCD line numbers between 1 and 8 with line 1 being at the top of the screen and line 8 being at the bottom of the screen. These constants (\cf3 LCD_LINE1\cf0 , \cf3 LCD_LINE2\cf0 , \cf3 LCD_LINE3\cf0 , \cf3 LCD_LINE4\cf0 , \cf3 LCD_LINE5\cf0 , \cf3 LCD_LINE6\cf0 , \cf3 LCD_LINE7\cf0 , \cf3 LCD_LINE8\cf0 ) should be used as the Y coordinate in \cf1 NumOut\cf0  and \cf1 TextOut\cf0  calls. Values of Y other than these constants will be adjusted so that text and numbers are on one of 8 fixed line positions.\par
\b\fs24\page\super #$AK\nosupersub NumOut(x, y, value, clear = false)\tab Function\par
\b0\fs20 Draw a numeric value on the screen at the specified x and y location. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 NumOut\cf0 (0, \cf3 LCD_LINE1\cf0 , x); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub TextOut(x, y, msg, clear = false)\tab Function\par
\b0\fs20 Draw a text value on the screen at the specified x and y location. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 TextOut\cf0 (0, \cf3 LCD_LINE3\cf0 , "Hello World!"); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GraphicOut(x, y, filename, clear = false)\tab Function\par
\b0\fs20 Draw the specified graphic icon file on the screen at the specified x and y location. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false. If the file cannot be found then nothing will be drawn and no errors will be reported.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 GraphicOut\cf0 (40, 40, "image.ric"); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GraphicOutEx(x, y, filename, vars, clear = false)\tab Function\par
\b0\fs20 Draw the specified graphic icon file on the screen at the specified x and y location. Use the values contained in the vars array to transform the drawing commands contained within the specified icon file. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false. If the file cannot be found then nothing will be drawn and no errors will be reported.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 GraphicOutEx\cf0 (40, 40, "image.ric", variables);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub CircleOut(x, y, radius, clear = false)\tab Function\par
\b0\fs20 Draw a circle on the screen with its center at the specified x and y location, using the specified radius. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 CircleOut\cf0 (40, 40, 10); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LineOut(x1, y1, x2, y2, clear = false)\tab Function\par
\b0\fs20 Draw a line on the screen from x1, y1 to x2, y2. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 LineOut\cf0 (40, 40, 10, 10); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub PointOut(x, y, clear = false)\tab Function\par
\b0\fs20 Draw a point on the screen at x, y. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 PointOut\cf0 (40, 40); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RectOut(x, y, width, height, clear = false)\tab Function\par
\b0\fs20 Draw a rectangle on the screen at x, y with the specified width and height. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 RectOut\cf0 (40, 40, 30, 10); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ResetScreen()\tab Function\par
\b0\fs20 Restore the standard NXT running program screen.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 ResetScreen\cf0 (); \par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ClearScreen()\tab Function\par
\b0\fs20 Clear the NXT LCD to a blank screen.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 ClearScreen\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub DisplayFlags()\tab Value\par
\b0\fs20 Return the current display flags.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 DisplayFlags\cf0 ();\par
\pard\sb120\tqr\tx8640\f0 Valid display flag values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub SetDisplayFlags(n)\tab Function\par
\b0\fs20 Set the current display flags. Valid flag values are listed \uldb above\ulnone\v IDH_API_DisplayFlags\v0 .\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetDisplayFlags\cf0 (x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub DisplayEraseMask()\tab Value\par
\b0\fs20 Return the current display erase mask.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 DisplayEraseMask\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetDisplayEraseMask(n)\tab Function\par
\b0\fs20 Set the current display erase mask.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetDisplayEraseMask\cf0 (x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub DisplayUpdateMask()\tab Value\par
\b0\fs20 Return the current display update mask.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 DisplayUpdateMask\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetDisplayUpdateMask(n)\tab Function\par
\b0\fs20 Set the current display update mask.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetDisplayUpdateMask\cf0 (x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub DisplayDisplay()\tab Value\par
\b0\fs20 Return the current display memory address.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 DisplayDisplay\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetDisplayDisplay(n)\tab Function\par
\b0\fs20 Set the current display memory address.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetDisplayDisplay\cf0 (x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub DisplayTextLinesCenterFlags()\tab Value\par
\b0\fs20 Return the current display text lines center flags.\par
\pard\li720\sb120\tqr\tx8640\f1 x = \cf1 DisplayTextLinesCenterFlags\cf0 ();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetDisplayTextLinesCenterFlags(n)\tab Function\par
\b0\fs20 Set the current display text lines center flags.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetDisplayTextLinesCenterFlags\cf0 (x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetDisplayNormal(x, line, count, data)\tab Function\par
\b0\fs20 Read "count" bytes from the normal display memory into the data array. Start reading from the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use \cf3 TEXTLINE_1\cf0  through \cf3 TEXTLINE_8\cf0  for the "line" parameter.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 GetDisplayNormal\cf0 (0, \cf3 TEXTLINE_1\cf0 , 8, ScreenMem);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetDisplayNormal(x, line, count, data)\tab Function\par
\b0\fs20 Write "count" bytes to the normal display memory from the data array. Start writing at the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use \cf3 TEXTLINE_1\cf0  through \cf3 TEXTLINE_8\cf0  for the "line" parameter.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetDisplayNormal\cf0 (0, \cf3 TEXTLINE_1\cf0 , 8, ScreenMem);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetDisplayPopup(x, line, count, data)\tab Function\par
\b0\fs20 Read "count" bytes from the popup display memory into the data array. Start reading from the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use \cf3 TEXTLINE_1\cf0  through \cf3 TEXTLINE_8\cf0  for the "line" parameter.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 GetDisplayPopup\cf0 (0, \cf3 TEXTLINE_1\cf0 , 8, PopupMem);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetDisplayPopup(x, line, count, data)\tab Function\par
\b0\fs20 Write "count" bytes to the popup display memory from the data array. Start writing at the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use \cf3 TEXTLINE_1\cf0  through \cf3 TEXTLINE_8\cf0  for the "line" parameter.\par
\pard\li720\sb120\tqr\tx8640\cf1\f1 SetDisplayPopup\cf0 (0, \cf3 TEXTLINE_1\cf0 , 8, PopupMem);\par
\pard\sb120\tqr\tx8640\f0\page\super #$AK\nosupersub The NXT loader module encompasses support for the NXT file system. The NXT supports creating files, opening existing files, reading, writing, renaming, and deleting files.\par
Files in the NXT file system must adhere to the 15.3 naming convention for a maximum filename length of 19 characters. While multiple files can be opened simultaneously, a maximum of 4 files can be open for writing at any given time.\par
When accessing files on the NXT, errors can occur. The NXC API defines several constants that define possible result codes. They are listed in the following table.\par
\pard\li720\sb120\tx4320\b\fs24 Loader Result Codes\tab Value\par
\pard\li720\tx4320\b0\fs20 LDR_SUCCESS\tab 0x0000\par
LDR_INPROGRESS\tab 0x0001\par
LDR_REQPIN\tab 0x0002\par
LDR_NOMOREHANDLES\tab 0x8100\par
LDR_NOSPACE\tab 0x8200\par
LDR_NOMOREFILES\tab 0x8300\par
LDR_EOFEXPECTED\tab 0x8400\par
LDR_ENDOFFILE\tab 0x8500\par
LDR_NOTLINEARFILE\tab 0x8600\par
LDR_FILENOTFOUND\tab 0x8700\par
LDR_HANDLEALREADYCLOSED\tab 0x8800\par
LDR_NOLINEARSPACE\tab 0x8900\par
LDR_UNDEFINEDERROR\tab 0x8A00\par
LDR_FILEISBUSY\tab 0x8B00\par
LDR_NOWRITEBUFFERS\tab 0x8C00\par
LDR_APPENDNOTPOSSIBLE\tab 0x8D00\par
LDR_FILEISFULL\tab 0x8E00\par
LDR_FILEEXISTS\tab 0x8F00\par
LDR_MODULENOTFOUND\tab 0x9000\par
LDR_OUTOFBOUNDARY\tab 0x9100\par
LDR_ILLEGALFILENAME\tab 0x9200\par
LDR_ILLEGALHANDLE\tab 0x9300\par
LDR_BTBUSY\tab 0x9400\par
LDR_BTCONNECTFAIL\tab 0x9500\par
LDR_BTTIMEOUT\tab 0x9600\par
LDR_FILETX_TIMEOUT\tab 0x9700\par
LDR_FILETX_DSTEXISTS\tab 0x9800\par
LDR_FILETX_SRCMISSING\tab 0x9900\par
LDR_FILETX_STREAMERROR\tab 0x9A00\par
LDR_FILETX_CLOSEERROR\tab 0x9B00\par
\pard\sb120\tqr\tx8640\b\fs24\page\super #$AK\nosupersub FreeMemory()\tab Value\par
\b0\fs20 Get the number of bytes of flash memory that are available for use.\par
\pard\li720\sb120\tqr\tx8640\f1 x = FreeMemory();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub CreateFile(filename, size, out handle)\tab Value\par
\b0\fs20 Create a new file with the specified filename and size and open it for writing. The file handle is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename and size parameters must be constants, constant expressions, or variables. A file created with a size of zero bytes cannot be written to since the NXC file writing functions do not grow the file if its capacity is exceeded during a write attempt.\par
\pard\li720\sb120\tqr\tx8640\f1 result = CreateFile("data.txt", 1024, handle);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OpenFileAppend(filename, out size, out handle)\tab Value\par
\b0\fs20 Open an existing file with the specified filename for writing. The file size is returned in the second parameter, which must be a variable. The file handle is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = OpenFileAppend("data.txt", fsize, handle);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OpenFileRead(filename, out size, out handle)\tab Value\par
\b0\fs20 Open an existing file with the specified filename for reading. The file size is returned in the second parameter, which must be a variable. The file handle is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = OpenFileRead("data.txt", fsize, handle);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub CloseFile(handle)\tab Value\par
\b0\fs20 Close the file associated with the specified file handle. The loader result code is returned as the value of the function call. The handle parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = CloseFile(handle);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ResolveHandle(filename, out handle, out bWriteable)\tab Value\par
\b0\fs20 Resolve a file handle from the specified filename. The file handle is returned in the second parameter, which must be a variable. A boolean value indicating whether the handle can be used to write to the file or not is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = ResolveHandle("data.txt", handle, bCanWrite);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RenameFile(oldfilename, newfilename)\tab Value\par
\b0\fs20 Rename a file from the old filename to the new filename. The loader result code is returned as the value of the function call. The filename parameters must be constants or variables.\par
\pard\li720\sb120\tqr\tx8640\f1 result = RenameFile("data.txt", "mydata.txt");\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub DeleteFile(filename)\tab Value\par
\b0\fs20 Delete the specified file. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = DeleteFile("data.txt");\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Read(handle, out value)\tab Value\par
\b0\fs20 Read a numeric value from the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a variable. The type of the value parameter determines the number of bytes of data read.\par
\pard\li720\sb120\tqr\tx8640\f1 result = Read(handle, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadLn(handle, out value)\tab Value\par
\b0\fs20 Read a numeric value from the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a variable. The type of the value parameter determines the number of bytes of data read. The ReadLn function reads two additional bytes from the file which it assumes are a carriage return and line feed pair.\par
\pard\li720\sb120\tqr\tx8640\f1 result = ReadLn(handle, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadBytes(handle, in/out length, out buf)\tab Value\par
\b0\fs20 Read the specified number of bytes from the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The length parameter must be a variable. The buf parameter must be an array or a string variable. The actual number of bytes read is returned in the length parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = ReadBytes(handle, len, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub Write(handle, value)\tab Value\par
\b0\fs20 Write a numeric value to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a constant, a constant expression, or a variable. The type of the value parameter determines the number of bytes of data written.\par
\pard\li720\sb120\tqr\tx8640\f1 result = Write(handle, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub WriteLn(handle, value)\tab Value\par
\b0\fs20 Write a numeric value to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a constant, a constant expression, or a variable. The type of the value parameter determines the number of bytes of data written. The WriteLn function also writes a carriage return and a line feed to the file following the numeric data.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteLn(handle, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub WriteString(handle, str, out count)\tab Value\par
\b0\fs20 Write the string to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The count parameter must be a variable. The str parameter must be a string variable or string constant. The actual number of bytes written is returned in the count parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteString(handle, "testing", count);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub WriteLnString(handle, str, out count)\tab Value\par
\b0\fs20 Write the string to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The count parameter must be a variable. The str parameter must be a string variable or string constant. This function also writes a carriage return and a line feed to the file following the string data. The total number of bytes written is returned in the count parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteLnString(handle, "testing", count);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub WriteBytes(handle, data, out count)\tab Value\par
\b0\fs20 Write the contents of the data array to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The count parameter must be a variable. The data parameter must be an array. The actual number of bytes written is returned in the count parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteBytes(handle, buffer, count);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub WriteBytesEx(handle, in/out length, buf)\tab Value\par
\b0\fs20 Write the specified number of bytes to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The length parameter must be a variable. The buf parameter must be an array or a string variable or string constant. The actual number of bytes written is returned in the length parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteBytesEx(handle, len, buffer);\par
\pard\f0\page\super #$AK\nosupersub The NXT command module encompasses support for the execution of user programs via the NXT virtual machine. It also implements the direct command protocol support that enables the NXT to respond to USB or Bluetooth requests from other devices such as a PC or another NXT brick.\par
\i\page\super\i0 #$AK\nosupersub The NXT button module encompasses support for the 4 buttons on the NXT brick. \par
\pard\sb120\tqr\tx8640 Valid button constant values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub ButtonCount(btn, reset)\tab Value\par
\b0\fs20 Return the number of times the specified button has been pressed since the last time the button press count was reset. Optionally clear the count after reading it. Valid values for the btn argument are listed \uldb above.\ulnone\v IDH_API_BUTTONMODULE\v0\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonCount(BTN1, true);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ButtonPressed(btn, reset)\tab Value\par
\b0\fs20 Return whether the specified button is pressed. Optionally clear the press count. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonPressed(BTN1, true);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadButtonEx(btn, reset, out pressed, out count)\tab Function\par
\b0\fs20 Read the specified button. Set the pressed and count parameters to the current state of the button. Optionally reset the press count after reading it. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 ReadButtonEx(BTN1, true, pressed, count);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ButtonPressCount(btn)\tab Value\par
\b0\fs20 Return the press count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonPressCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetButtonPressCount(btn, value)\tab Function\par
\b0\fs20 Set the press count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonPressCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ButtonLongPressCount(btn)\tab Value\par
\b0\fs20 Return the long press count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonLongPressCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetButtonLongPressCount(btn, value)\tab Function\par
\b0\fs20 Set the long press count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonLongPressCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ButtonShortReleaseCount(btn)\tab Value\par
\b0\fs20 Return the short release count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonShortReleaseCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetButtonShortReleaseCount(btn, value)\tab Function\par
\b0\fs20 Set the short release count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonShortReleaseCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ButtonLongReleaseCount(btn)\tab Value\par
\b0\fs20 Return the long release count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonLongReleaseCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetButtonLongReleaseCount(btn, value)\tab Function\par
\b0\fs20 Set the long release count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonLongReleaseCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ButtonReleaseCount(btn)\tab Value\par
\b0\fs20 Return the release count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonReleaseCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetButtonReleaseCount(btn, value)\tab Function\par
\b0\fs20 Set the release count of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonReleaseCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ButtonState(btn)\tab Value\par
\b0\fs20 Return the state of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 . \par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonState(BTN1);\par
\pard\sb120\tqr\tx8640\f0 Button state values are listed below.\par
\b\fs24\page\super #$AK\nosupersub SetButtonState(btn, value)\tab Function\par
\b0\fs20 Set the state of the specified button. Valid values for the btn argument are listed \uldb above\ulnone\v IDH_API_BUTTONMODULE\v0 . Button state values are listed \uldb above\ulnone\v IDH_API_ButtonState\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonState(BTN1, BTNSTATE_PRESSED_EV);\par
\pard\sb120\tqr\tx8640\f0\page\super #$AK\nosupersub The NXT UI module encompasses support for various aspects of the user interface for the NXT brick.\par
\b\fs24\page\super #$AK\nosupersub Volume()\tab Value\par
\b0\fs20 Return the user interface volume level. Valid values are from 0 to 4.\par
\pard\li720\sb120\tqr\tx8640\f1 x = Volume();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetVolume(value)\tab Function\par
\b0\fs20 Set the user interface volume level. Valid values are from 0 to 4.\par
\pard\li720\sb120\tqr\tx8640\f1 SetVolume(3);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BatteryLevel()\tab Value\par
\b0\fs20 Return the battery level in millivolts.\par
\pard\li720\sb120\tqr\tx8640\f1 x = BatteryLevel();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BluetoothState()\tab Value\par
\b0\fs20 Return the Bluetooth state.\par
\pard\li720\sb120\tqr\tx8640\f1 x = BluetoothState();\par
\pard\sb120\tqr\tx8640\f0 Valid UI Bluetooth state values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub SetBluetoothState(value)\tab Function\par
\b0\fs20 Set the Bluetooth state. Valid Bluetooth state values are listed \uldb above\ulnone\v IDH_API_BluetoothState\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetBluetoothState(UI_BT_STATE_OFF);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub CommandFlags()\tab Value\par
\b0\fs20 Return the command flags.\par
\pard\li720\sb120\tqr\tx8640\f1 x = CommandFlags();\par
\pard\sb120\tqr\tx8640\f0 Valid flag values are listed in the following table.\par
\lang1030\b\fs24\page\super #$AK\nosupersub SetCommandFlags(value)\tab Function\par
\lang1033\b0\fs20 Set the command flags. Valid command flag values are listed \uldb above\ulnone\v IDH_API_CommandFlags\v0 .\par
\pard\li720\sb120\tqr\tx8640\lang1030\f1 SetCommandFlags(UI_FLAGS_REDRAW_STATUS);\par
\pard\sb120\tqr\tx8640\lang1033\b\f0\fs24\page\super #$AK\nosupersub UIState()\tab Value\par
\b0\fs20 Return the user interface state.\par
\pard\li720\sb120\tqr\tx8640\f1 x = UIState();\par
\pard\sb120\tqr\tx8640\f0 Valid UI state values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub SetUIState(value)\tab Function\par
\b0\fs20 Set the user interface state. Valid user interface state values are listed \uldb above\ulnone\v IDH_API_UIState\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetUIState(UI_STATE_LOW_BATTERY);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub UIButton()\tab Value\par
\b0\fs20 Return user interface button information.\par
\pard\li720\sb120\tqr\tx8640\f1 x = UIButton();\par
\pard\sb120\tqr\tx8640\f0 Valid UI button values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub SetUIButton(value)\tab Function\par
\b0\fs20 Set user interface button information. Valid user interface button values are listed \uldb above\ulnone\v IDH_API_UIButton\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetUIButton(UI_BUTTON_ENTER);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub VMRunState()\tab Value\par
\b0\fs20 Return VM run state information. \par
\pard\li720\sb120\tqr\tx8640\f1 x = VMRunState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetVMRunState(value)\tab Function\par
\b0\fs20 Set VM run state information.\par
\pard\li720\sb120\tqr\tx8640\f1 SetVMRunState(0); // stopped\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BatteryState()\tab Value\par
\b0\fs20 Return battery state information (0..4). \par
\pard\li720\sb120\tqr\tx8640\f1 x = BatteryState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetBatteryState(value)\tab Function\par
\b0\fs20 Set battery state information.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBatteryState(4);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RechargeableBattery()\tab Value\par
\b0\fs20 Return whether the NXT has a rechargeable battery installed or not. \par
\pard\li720\sb120\tqr\tx8640\f1 x = RechargeableBattery();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ForceOff(n)\tab Function\par
\b0\fs20 Force the NXT to turn off if the specified value is greater than zero.\par
\pard\li720\sb120\tqr\tx8640\f1 ForceOff(true);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub UsbState()\tab Value\par
\b0\fs20 Return USB state information (0=disconnected, 1=connected, 2=working).\par
\pard\li720\sb120\tqr\tx8640\f1 x = UsbState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUsbState(value)\tab Function\par
\b0\fs20 Set USB state information (0=disconnected, 1=connected, 2=working).\par
\pard\li720\sb120\tqr\tx8640\f1 SetUsbState(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub OnBrickProgramPointer()\tab Value\par
\b0\fs20 Return the current OBP (on-brick program) step; \par
\pard\li720\sb120\tqr\tx8640\f1 x = OnBrickProgramPointer();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetOnBrickProgramPointer(value)\tab Function\par
\b0\fs20 Set the current OBP (on-brick program) step.\par
\pard\li720\sb120\tqr\tx8640\f1 SetOnBrickProgramPointer(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LongAbort()\tab Value (+)\par
\b0\fs20 Return the enhanced NBC/NXC firmware's long abort setting (true or false). If set to true then a program has access the escape button. Aborting a program requires a long press of the escape button\par
\pard\li720\sb120\tqr\tx8640\f1 x = LongAbort();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLongAbort(value)\tab Function (+)\par
\b0\fs20 Set the enhanced NBC/NXC firmware's long abort setting (true or false). If set to true then a program has access the escape button. Aborting a program requires a long press of the escape button.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLongAbort(true);\par
\pard\sb120\tqr\tx8640\f0\page\super #$AK\nosupersub The NXT low speed module encompasses support for digital I2C sensor communication.\par
Use the lowspeed (aka I2C) communication methods to access devices that use the I2C protocol on the NXT brick's four input ports.\par
You must set the input port's Type property to SENSOR_TYPE_LOWSPEED or SENSOR_TYPE_LOWSPEED_9V on a given port before using an I2C device on that port. Use SENSOR_TYPE_LOWSPEED_9V if your device requires 9V power from the NXT brick. Remember that you also need to set the input port's InvalidData property to true after setting a new Type, and then wait in a loop for the NXT firmware to set InvalidData back to false. This process ensures that the firmware has time to properly initialize the port, including the 9V power lines, if applicable. Some digital devices might need additional time to initialize after power up.\par
The SetSensorLowspeed API function sets the specified port to SENSOR_TYPE_LOWSPEED_9V and calls ResetSensor to perform the InvalidData reset loop described above.\par
When communicating with I2C devices, the NXT firmware uses a master/slave setup in which the NXT brick is always the master device. This means that the firmware is responsible for controlling the write and read operations. The NXT firmware maintains write and read buffers for each port, and the three main Lowspeed (I2C) methods described below enable you to access these buffers.\par
A call to LowspeedWrite starts an asynchronous transaction between the NXT brick and a digital I2C device. The program continues to run while the firmware manages sending bytes from the write buffer and reading the response bytes from the device. Because the NXT is the master device, you must also specify the number of bytes to expect from the device in response to each write operation. You can exchange up to 16 bytes in each direction per transaction.\par
After you start a write transaction with LowspeedWrite, use LowspeedStatus in a loop to check the status of the port. If LowspeedStatus returns a status code of 0 and a count of bytes available in the read buffer, the system is ready for you to use LowspeedRead to copy the data from the read buffer into the buffer you provide.\par
Note that any of these calls might return various status codes at any time. A status code of 0 means the port is idle and the last transaction (if any) did not result in any errors. Negative status codes and the positive status code 32 indicate errors. There are a few possible errors per call.\par
Valid low speed return values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub LowspeedWrite(port, returnlen, buffer)\tab Value\par
\b0\fs20 This method starts a transaction to write the bytes contained in the array buffer to the I2C device on the specified port. It also tells the I2C device the number of bytes that should be included in the response. The maximum number of bytes that can be written or read is 16. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads. Lowspeed return values are listed \uldb above\ulnone\v IDH_NXC_LowSpeed\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 x = LowspeedWrite(S1, 1, inbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LowspeedStatus(port, out bytesready)\tab Value\par
\b0\fs20 This method checks the status of the I2C communication on the specified port. If the last operation on this port was a successful LowspeedWrite call that requested response data from the device then bytesready will be set to the number of bytes in the internal read buffer. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads. Lowspeed return values are listed \uldb above\ulnone\v IDH_NXC_LowSpeed\v0 . If the return value is 0 then the last operation did not cause any errors. Avoid calls to LowspeedRead or LowspeedWrite while LowspeedStatus returns STAT_COMM_PENDING.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LowspeedStatus(S1, nRead);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LowspeedRead(port, buflen, out buffer)\tab Value\par
\b0\fs20 Read the specified number of bytes from the I2C device on the specified port and store the bytes read in the array buffer provided. The maximum number of bytes that can be written or read is 16. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads. Lowspeed return values are listed \uldb above\ulnone\v IDH_NXC_LowSpeed\v0 . If the return value is negative then the output buffer will be empty.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LowspeedRead(S1, 1, outbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub I2CWrite(port, returnlen, buffer)\tab Value\par
\b0\fs20 This is an alias for LowspeedWrite.\par
\pard\li720\sb120\tqr\tx8640\f1 x = I2CWrite(S1, 1, inbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub I2CStatus(port, out bytesready)\tab Value\par
\b0\fs20 This is an alias for LowspeedStatus.\par
\pard\hyphpar0\li720\ri720\sa120\expndtw-10\f1\fs22 x = I2CStatus(S1, nRead);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub I2CRead(port, buflen, out buffer)\tab Value\par
\b0\fs20 This is an alias for LowspeedRead.\par
\pard\li720\sb120\tqr\tx8640\f1 x = I2CRead(S1, 1, outbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub I2CBytes(port, inbuf, in/out count, out outbuf)\tab Value\par
\b0\fs20 This method writes the bytes contained in the input buffer (inbuf) to the I2C device on the specified port, checks for the specified number of bytes to be ready for reading, and then tries to read the specified number (count) of bytes from the I2C device into the output buffer (outbuf). The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. Returns true or false indicating whether the I2C read process succeeded or failed.\par
This is a higher-level wrapper around the three main I2C functions. It also maintains a "last good read" buffer and returns values from that buffer if the I2C communication transaction fails.\par
\pard\li720\sb120\tqr\tx8640\f1 x = I2CBytes(S4, writebuf, cnt, readbuf);\par
\pard\sb120\tqr\tx8640\f0 This method reads data from the lowspeed input buffer associated with the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 GetLSInputBuffer(S1, 0, 8, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSInputBuffer(port, offset, count, data)\tab Function\par
\b0\fs20 This method writes data to the lowspeed input buffer associated with the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSInputBuffer(S1, 0, 8, data);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetLSOutputBuffer(port, offset, count, out data)\tab Function\par
\b0\fs20 This method reads data from the lowspeed output buffer associated with the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 GetLSOutputBuffer(S1, 0, 8, outbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSOutputBuffer(port, offset, count, data)\tab Function\par
\b0\fs20 This method writes data to the lowspeed output buffer associated with the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSOutputBuffer(S1, 0, 8, data);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSInputBufferInPtr(port)\tab Value\par
\b0\fs20 This method returns the value of the input pointer for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSInputBufferInPtr(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSInputBufferInPtr(port)\tab Function\par
\b0\fs20 This method sets the value of the input pointer for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSInputBufferInPtr(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSInputBufferOutPtr(port)\tab Value\par
\b0\fs20 This method returns the value of the output pointer for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSInputBufferOutPtr(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSInputBufferOutPtr(port)\tab Function\par
\b0\fs20 This method sets the value of the output pointer for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSInputBufferOutPtr(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSInputBufferBytesToRx(port)\tab Value\par
\b0\fs20 This method returns the bytes to receive for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSInputBufferBytesToRx(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSInputBufferBytesToRx(port)\tab Function\par
\b0\fs20 This method sets the bytes to receive for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSInputBufferBytesToRx(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSOutputBufferInPtr(port)\tab Value\par
\b0\fs20 This method returns the value of the input pointer for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSOutputBufferInPtr(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSOutputBufferInPtr(port)\tab Function\par
\b0\fs20 This method sets the value of the input pointer for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSOutputBufferInPtr(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSOutputBufferOutPtr(port)\tab Value\par
\b0\fs20 This method returns the value of the output pointer for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSOutputBufferOutPtr(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSOutputBufferOutPtr(port)\tab Function\par
\b0\fs20 This method sets the value of the output pointer for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSOutputBufferOutPtr(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSOutputBufferBytesToRx(port)\tab Value\par
\b0\fs20 This method returns the bytes to receive for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSOutputBufferBytesToRx(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSOutputBufferBytesToRx(port)\tab Function\par
\b0\fs20 This method sets the bytes to receive for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSOutputBufferBytesToRx(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSMode(port)\tab Value\par
\b0\fs20 This method returns the mode of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSMode(S1);\par
\pard\sb120\tqr\tx8640\f0 Valid low speed mode values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub SetLSMode(port)\tab Function\par
\b0\fs20 This method sets the mode of the lowspeed communication over the specified port. The port must be a constant (S1..S4). Valid low speed mode values are listed \uldb above\ulnone\v IDH_API_LSMode\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSMode(S1, LOWSPEED_TRANSMITTING);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSChannelState(port)\tab Value\par
\b0\fs20 This method returns the channel state of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSChannelState(S1);\par
\pard\sb120\tqr\tx8640\f0 Valid low speed channel state values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub SetLSChannelState(port)\tab Function\par
\b0\fs20 This method sets the channel state of the lowspeed communication over the specified port. The port must be a constant (S1..S4). Valid low speed channel state values are listed \uldb above\ulnone\v IDH_API_LSChannelState\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSChannelState(S1, LOWSPEED_IDLE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSErrorType(port)\tab Value\par
\b0\fs20 This method returns the error type of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSErrorType(S1);\par
\pard\sb120\tqr\tx8640\f0 Valid low speed error type values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub SetLSErrorType(port)\tab Function\par
\b0\fs20 This method sets the error type of the lowspeed communication over the specified port. The port must be a constant (S1..S4). Valid low speed error type values are listed \uldb above\ulnone\v IDH_API_LSErrorType\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSErrorType(S1, LOWSPEED_CH_NOT_READY);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSState()\tab Value\par
\b0\fs20 This method returns the state of the lowspeed module.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSState();\par
\pard\sb120\tqr\tx8640\f0 Valid low speed state values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub SetLSState(n)\tab Function\par
\b0\fs20 This method sets the state of the lowspeed module. Valid low speed state values are listed \uldb above\ulnone\v IDH_API_LSState\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSState(COM_CHANNEL_THREE_ACTIVE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub LSSpeed()\tab Value\par
\b0\fs20 This method returns the speed of the lowspeed module.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSSpeed();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetLSSpeed(n)\tab Function\par
\b0\fs20 This method sets the speed of the lowspeed module.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSSpeed(100);\par
\pard\sb120\tqr\tx8640\f0\page\super #$AK\nosupersub The NXT comm module encompasses support for all forms of Bluetooth, USB, and HiSpeed communication.\par
You can use the Bluetooth communication methods to send information to other devices connected to the NXT brick. The NXT firmware also implements a message queuing or mailbox system which you can access using these methods.\par
Communication via Bluetooth uses a master/slave connection system. One device must be designated as the master device before you run a program using Bluetooth. If the NXT is the master device then you can configure up to three slave devices using connection 1, 2, and 3 on the NXT brick. If your NXT is a slave device then connection 0 on the brick must be reserved for the master device.\par
Programs running on the master NXT brick can send packets of data to any connected slave devices using the BluetoothWrite method. Slave devices write response packets to the message queuing system where they wait for the master device to poll for the response.\par
Using the direct command protocol, a master device can send messages to slave NXT bricks in the form of text strings addressed to a particular mailbox. Each mailbox on the slave NXT brick is a circular message queue holding up to five messages. Each message can be up to 58 bytes long.\par
To send messages from a master NXT brick to a slave brick, use BluetoothWrite on the master brick to send a MessageWrite direct command packet to the slave. Then, you can use ReceiveMessage on the slave brick to read the message. The slave NXT brick must be running a program when an incoming message packet is received. Otherwise, the slave NXT brick ignores the message and the message is dropped.\par
\b\fs24\page\super #$AK\nosupersub SendRemoteBool(connection, queue, bvalue)\tab Value\par
\b0\fs20 This method sends a boolean value to the device on the specified connection. The message containing the boolean value will be written to the specified queue on the remote brick.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendRemoteBool(1, queue, false);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SendRemoteNumber(connection, queue, value)\tab Value\par
\b0\fs20 This method sends a numeric value to the device on the specified connection. The message containing the numeric value will be written to the specified queue on the remote brick.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendRemoteNumber(1, queue, 123);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SendRemoteString(connection, queue, strval)\tab Value\par
\b0\fs20 This method sends a string value to the device on the specified connection. The message containing the string value will be written to the specified queue on the remote brick.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendRemoteString(1, queue, "hello world");\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SendResponseBool(queue, bvalue)\tab Value\par
\b0\fs20 This method sends a boolean value as a response to a received message. The message containing the boolean value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendResponseBool(queue, false);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SendResponseNumber(queue, value)\tab Value\par
\b0\fs20 This method sends a numeric value as a response to a received message. The message containing the numeric value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendResponseNumber(queue, 123);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SendResponseString(queue, strval)\tab Value\par
\b0\fs20 This method sends a string value as a response to a received message. The message containing the string value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendResponseString(queue, "hello world");\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReceiveRemoteBool(queue, remove, out bvalue)\tab Value\par
\b0\fs20 This method is used on a master brick to receive a boolean value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = ReceiveRemoteBool(queue, true, bvalue);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReceiveRemoteNumber(queue, remove, out value)\tab Value\par
\b0\fs20 This method is used on a master brick to receive a numeric value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = ReceiveRemoteBool(queue, true, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReceiveRemoteString(queue, remove, out strval)\tab Value\par
\b0\fs20 This method is used on a master brick to receive a string value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = ReceiveRemoteString(queue, true, strval);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReceiveRemoteMessageEx(queue, remove, out strval, out val, out bval)\tab Value\par
\b0\fs20 This method is used on a master brick to receive a string, boolean, or numeric value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = ReceiveRemoteMessageEx(queue, true, strval, val, bval);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SendMessage(queue, msg)\tab Value\par
\b0\fs20 This method writes the message buffer contents to the specified mailbox or message queue. The maximum message length is 58 bytes.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendMessage(mbox, data);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReceiveMessage(queue, remove, out buffer)\tab Value\par
\b0\fs20 This method retrieves a message from the specified queue and writes it to the buffer provided. Optionally removes the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RecieveMessage(mbox, true, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BluetoothStatus(connection)\tab Value\par
\b0\fs20 This method returns the status of the specified Bluetooth connection. Avoid calling BluetoothWrite or any other API function that writes data over a Bluetooth connection while BluetoothStatus returns STAT_COMM_PENDING.\par
\pard\li720\sb120\tqr\tx8640\f1 x = BluetoothStatus(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BluetoothWrite(connection, buffer)\tab Value\par
\b0\fs20 This method tells the NXT firmware to write the data in the buffer to the device on the specified Bluetooth connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = BluetoothWrite(1, data);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteMessageRead(connection, queue)\tab Value\par
\b0\fs20 This method sends a MessageRead direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteMessageRead(1, 5);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteMessageWrite(connection, queue, msg)\tab Value\par
\b0\fs20 This method sends a MessageWrite direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteMessageWrite(1, 5, "test");\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteStartProgram(connection, filename)\tab Value\par
\b0\fs20 This method sends a StartProgram direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteStartProgram(1, "myprog.rxe");\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteStopProgram(connection)\tab Value\par
\b0\fs20 This method sends a StopProgram direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteStopProgram(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemotePlaySoundFile(connection, filename, bLoop)\tab Value\par
\b0\fs20 This method sends a PlaySoundFile direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemotePlaySoundFile(1, "click.rso", false);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemotePlayTone(connection, frequency, duration)\tab Value\par
\b0\fs20 This method sends a PlayTone direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemotePlayTone(1, 440, 1000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteStopSound(connection)\tab Value\par
\b0\fs20 This method sends a StopSound direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteStopSound(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteKeepAlive(connection)\tab Value\par
\b0\fs20 This method sends a KeepAlive direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteKeepAlive(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteResetScaledValue(connection, port)\tab Value\par
\b0\fs20 This method sends a ResetScaledValue direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteResetScaledValue(1, S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteResetMotorPosition(connection, port, bRelative)\tab Value\par
\b0\fs20 This method sends a ResetMotorPosition direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteResetMotorPosition(1, OUT_A, true);\par
\pard\sb120\tqr\tx8640\lang1036\b\f0\fs24\page\super #$AK\nosupersub RemoteSetInputMode(connection, port, type, mode)\tab Value\par
\lang1033\b0\fs20 This method sends a SetInputMode direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteSetInputMode(1, S1, IN_TYPE_LOWSPEED, IN_MODE_RAW);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub RemoteSetOutputState(connection, port, speed, mode, regm, tpct, rs, tl)\tab Value\par
\b0\fs20 This method sends a SetOutputState direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteSetOutputState(1, OUT_A, 75, OUT_MODE_MOTORON, OUT_REGMODE_IDLE, 0, OUT_RUNSTATE_RUNNING, 0);\par
\pard\sb120\tqr\tx8640\f0\page\super #$AK\nosupersub Valid miscellaneous constant values are listed in the following table.\par
Valid BtState values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub GetUSBInputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the USB input buffer at the specified offset and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetUSBInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBInputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the USB input buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBInputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the USB input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBInputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub USBInputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the USB input buffer.\par
\pard\hyphpar0\li720\ri720\sa120\expndtw-10\f1\fs22 byte x = USBInputBufferInPtr();\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24\page\super #$AK\nosupersub SetUSBInputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the USB input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBInputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub USBInputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the USB input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBInputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetUSBOutputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the USB output buffer at the specified offset and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetUSBOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBOutputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the USB output buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBOutputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the USB output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBOutputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub USBOutputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the USB output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBOutputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBOutputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the USB output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBOutputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub USBOutputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the USB output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBOutputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetUSBPollBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the USB poll buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetUSBPollBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBPollBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the USB poll buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBPollBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBPollBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the USB poll buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBPollBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub USBPollBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the USB poll buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBPollBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBPollBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the USB poll buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBPollBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub USBPollBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the USB poll buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBPollBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetUSBState(n)\tab Function\par
\b0\fs20 This method sets the USB state to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBState(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub USBState()\tab Value\par
\b0\fs20 This method returns the USB state.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBPollBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetHSInputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the High Speed input buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetHSInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSInputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the High Speed input buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSInputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the High Speed input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSInputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HSInputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the High Speed input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSInputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSInputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the High Speed input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSInputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HSInputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the High Speed input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSInputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetHSOutputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the High Speed output buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetHSOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSOutputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the High Speed output buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSOutputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the Output pointer of the High Speed output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSOutputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HSOutputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the Output pointer of the High Speed output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSOutputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSOutputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the High Speed output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSOutputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HSOutputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the High Speed output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSOutputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSFlags(n)\tab Function\par
\b0\fs20 This method sets the High Speed flags to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSFlags(0);\par
\pard\sb120\tqr\tx8640\f0 Valid HsFlags values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub HSFlags()\tab Value\par
\b0\fs20 This method returns the value of the High Speed flags. Valid HsFlags values are listed \uldb above\ulnone\v IDH_API_SetHSFlags\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSFlags();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSSpeed(n)\tab Function\par
\b0\fs20 This method sets the High Speed speed to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSSpeed(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HSSpeed()\tab Value\par
\b0\fs20 This method returns the value of the High Speed speed.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSSpeed();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetHSState(n)\tab Function\par
\b0\fs20 This method sets the High Speed state to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSState(1);\par
\pard\sb120\tqr\tx8640\f0 Valid HsState values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub HSState()\tab Value\par
\b0\fs20 This method returns the value of the High Speed state. Valid HsState values are listed \uldb above\ulnone\v IDH_API_SetHSState\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetBTInputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the Bluetooth input buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBTInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetBTInputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the Bluetooth input buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetBTInputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the Bluetooth input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTInputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTInputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the Bluetooth input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTInputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetBTInputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the Bluetooth input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTInputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTInputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the Bluetooth input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTInputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetBTOutputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the Bluetooth output buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBTOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetBTOutputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the Bluetooth output buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetBTOutputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the Bluetooth output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTOutputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTOutputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the Bluetooth output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTOutputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetBTOutputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the Bluetooth output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTOutputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTOutputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the Bluetooth output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTOutputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTDeviceCount()\tab Value\par
\b0\fs20 This method returns the number of devices defined within the Bluetooth device table.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTDeviceCount();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTDeviceNameCount()\tab Value\par
\b0\fs20 This method returns the number of device names defined within the Bluetooth device table. This usually has the same value as BTDeviceCount but it can differ in some instances.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTDeviceNameCount();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTDeviceName(const idx)\tab Value\par
\b0\fs20 This method returns the name of the device at the specified index in the Bluetooth device table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 string name = BTDeviceName(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTConnectionName(const idx)\tab Value\par
\b0\fs20 This method returns the name of the device at the specified index in the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 string name = BTConnectionName(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTConnectionPinCode(const idx)\tab Value\par
\b0\fs20 This method returns the pin code of the device at the specified index in the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 string pincode = BTConnectionPinCode(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BrickDataName()\tab Value\par
\b0\fs20 This method returns the name of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 string name = BrickDataName();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetBTDeviceAddress(const idx, out data)\tab Function\par
\b0\fs20 This method reads the address of the device at the specified index within the Bluetooth device table and stores it in the data buffer provided. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBTDeviceAddress(0, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetBTConnectionAddress(const idx, out data)\tab Function\par
\b0\fs20 This method reads the address of the device at the specified index within the Bluetooth connection table and stores it in the data buffer provided. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBTConnectionAddress(0, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub GetBrickDataAddress(out data)\tab Function\par
\b0\fs20 This method reads the address of the NXT and stores it in the data buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBrickDataAddress(buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTDeviceClass(const idx)\tab Value\par
\b0\fs20 This method returns the class of the device at the specified index within the Bluetooth device table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 long class = BTDeviceClass(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTDeviceStatus(const idx)\tab Value\par
\b0\fs20 This method returns the status of the device at the specified index within the Bluetooth device table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 byte status = BTDeviceStatus(0);\par
\pard\sb120\tqr\tx8640\f0 Valid DeviceStatus values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub BTConnectionClass(const idx)\tab Value\par
\b0\fs20 This method returns the class of the device at the specified index within the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 long class = BTConnectionClass(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTConnectionHandleNum(const idx)\tab Value\par
\b0\fs20 This method returns the handle number of the device at the specified index within the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 byte handlenum = BTConnectionHandleNum(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTConnectionStreamStatus(const idx)\tab Value\par
\b0\fs20 This method returns the stream status of the device at the specified index within the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 byte streamstatus = BTConnectionStreamStatus(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BTConnectionLinkQuality(const idx)\tab Value\par
\b0\fs20 This method returns the link quality of the device at the specified index within the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 byte linkquality = BTConnectionLinkQuality(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BrickDataBluecoreVersion()\tab Value\par
\b0\fs20 This method returns the bluecore version of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 int bv = BrickDataBluecoreVersion();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub BrickDataBtStateStatus()\tab Value\par
\b0\fs20 This method returns the Bluetooth state status of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 int x = BrickDataBtStateStatus();\par
\pard\sb120\tqr\tx8640\f0 Valid BtStateStatus values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub BrickDataBtHardwareStatus()\tab Value\par
\b0\fs20 This method returns the Bluetooth hardware status of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 int x = BrickDataBtHardwareStatus();\par
\pard\sb120\tqr\tx8640\f0 Valid BtHwStatus values are listed in the following table.\par
\b\fs24\page\super #$AK\nosupersub BrickDataTimeoutValue()\tab Value\par
\b0\fs20 This method returns the timeout value of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 int x = BrickDataTimeoutValue();\par
\pard\tx3348\tx5223\f0\par
\pard\sb120\tqr\tx8640\page\super #$AK\nosupersub\b\fs24 SensorHTCompass(port)\tab Value\par
\b0\fs20 Read the compass heading value of the HiTechnic Compass sensor on the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorHTCompass(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorHTIRSeekerDir(port)\tab Value\par
\b0\fs20 Read the direction value of the HiTechnic IR Seeker on the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorHTIRSeekerDir(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorHTColorNum(port)\tab Value\par
\b0\fs20 Read the color number from the HiTechnic Color sensor on the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorHTColorNum(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SetSensorHTGyro(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as a HiTechnic Gyro sensor.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSensorHTGyro(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorHTGyro(port, offset)\tab Value\par
\b0\fs20 Read the HiTechnic Gyro sensor on the specified port. The offset value should be calculated by averaging several readings with an offset of zero while the sensor is perfectly still.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorHTGyro(S1, gyroOffset);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadSensorHTAccel(port, x, y, z)\tab Value\par
\b0\fs20 Read X, Y, and Z axis acceleration values from the HiTechnic Accelerometer sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTAccel(S1, x, y, z);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadSensorHTColor(port, ColorNum, Red, Green, Blue)\tab Value\par
\b0\fs20 Read color number, red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTColor(S1, c, r, g, b);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadSensorHTRawColor(port, Red, Green, Blue)\tab Value\par
\b0\fs20 Read the raw red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTRawColor(S1, r, g, b);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadSensorHTNormalizedColor(port, Idx, Red, Green, Blue)\tab Value\par
\b0\fs20 Read the color index and the normalized red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTNormalizedColor(S1, c, r, g, b);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadSensorHTIRSeeker(port, dir, s1, s3, s5, s7, s9)\tab Value\par
\b0\fs20 Read direction, and five signal strength values from the HiTechnic IRSeeker sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTIRSeeker(port, dir, s1, s3, s5, s7, s9);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTPowerFunctionCommand(port, channel, cmd1, cmd2)\tab Function\par
\b0\fs20 Execute a pair of Power Function motor commands on the specified channel using the HiTechnic iRLink device. Commands are HTPF_CMD_STOP, HTPF_CMD_REV, HTPF_CMD_FWD, and HTPF_CMD_BRAKE. Valid channels are HTPF_CHANNEL_1 through HTPF_CHANNEL_4.\par
\pard\li720\sb120\tqr\tx8640\f1 HTPowerFunctionCommand(S1, HTPF_CHANNEL_1, HTPF_CMD_STOP, HTPF_CMD_FWD);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetIRLinkPort(port)\tab Function\par
\b0\fs20 Set the global port in advance of using the HTRCX* and HTScout* API functions for sending RCX and Scout messages over the HiTechnic iRLink device.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetIRLinkPort(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXPoll(src, value)\tab Value\par
\b0\fs20 Send the Poll command to an RCX to read a signed 2-byte value at the specified source and value combination.\par
\pard\li720\sb120\tqr\tx8640\f1 x = HTRCXPoll(RCX_VariableSrc, 0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXBatteryLevel()\tab Value\par
\b0\fs20 Send the BatteryLevel command to an RCX to read the current battery level.\par
\pard\li720\sb120\tqr\tx8640\f1 x = HTRCXBatteryLevel();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXPing()\tab Function\par
\b0\fs20 Send the Ping command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPing();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXDeleteTasks()\tab Function\par
\b0\fs20 Send the DeleteTasks command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDeleteTasks();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXStopAllTasks()\tab Function\par
\b0\fs20 Send the StopAllTasks command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXStopAllTasks();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXPBTurnOff()\tab Function\par
\b0\fs20 Send the PBTurnOff command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPBTurnOff();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXDeleteSubs()\tab Function\par
\b0\fs20 Send the DeleteSubs command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDeleteSubs();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXClearSound()\tab Function\par
\b0\fs20 Send the ClearSound command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXClearMsg()\tab Function\par
\b0\fs20 Send the ClearMsg command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearMsg();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXMuteSound()\tab Function\par
\b0\fs20 Send the MuteSound command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXMuteSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXUnmuteSound()\tab Function\par
\b0\fs20 Send the UnmuteSound command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXUnmuteSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXClearAllEvents()\tab Function\par
\b0\fs20 Send the ClearAllEvents command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearAllEvents();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetOutput(outputs, mode)\tab Function\par
\b0\fs20 Send the SetOutput command to an RCX to configure the mode of the specified outputs\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetOutput(RCX_OUT_A, RCX_OUT_ON);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetDirection(outputs, dir)\tab Function\par
\b0\fs20 Send the SetDirection command to an RCX to configure the direction of the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetDirection(RCX_OUT_A, RCX_OUT_FWD);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetPower(outputs, pwrsrc, pwrval)\tab Function\par
\b0\fs20 Send the SetPower command to an RCX to configure the power level of the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetPower(RCX_OUT_A, RCX_ConstantSrc, RCX_OUT_FULL);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXOn(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to turn on the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOn(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXOff(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to turn off the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOff(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXFloat(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to float the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXFloat(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXToggle(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to toggle the direction of the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXToggle(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXFwd(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to set the specified outputs to the forward direction.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXFwd(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXRev(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to set the specified outputs to the reverse direction.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXRev(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXOnFwd(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to turn on the specified outputs in the forward direction.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOnFwd(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXOnRev(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to turn on the specified outputs in the reverse direction.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOnRev(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXOnFor(outputs, duration)\tab Function\par
\b0\fs20 Send commands to an RCX to turn on the specified outputs in the forward direction for the specified duration.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOnFor(RCX_OUT_A, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetTxPower(pwr)\tab Function\par
\b0\fs20 Send the SetTxPower command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetTxPower(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXPlaySound(snd)\tab Function\par
\b0\fs20 Send the PlaySound command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPlaySound(RCX_SOUND_UP);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXDeleteTask(n)\tab Function\par
\b0\fs20 Send the DeleteTask command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDeleteTask(3);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXStartTask(n)\tab Function\par
\b0\fs20 Send the StartTask command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXStartTask(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXStopTask(n)\tab Function\par
\b0\fs20 Send the StopTask command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXStopTask(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSelectProgram(prog)\tab Function\par
\b0\fs20 Send the SelectProgram command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSelectProgram(3);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXClearTimer(timer)\tab Function\par
\b0\fs20 Send the ClearTimer command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearTimer(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetSleepTime(t)\tab Function\par
\b0\fs20 Send the SetSleepTime command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetSleepTime(4);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXDeleteSub(s)\tab Function\par
\b0\fs20 Send the DeleteSub command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDeleteSub(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXClearSensor(port)\tab Function\par
\b0\fs20 Send the ClearSensor command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearSensor(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXPlayToneVar(varnum, duration)\tab Function\par
\b0\fs20 Send the PlayToneVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPlayToneVar(0, 50);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetWatch(hours, minutes)\tab Function\par
\b0\fs20 Send the SetWatch command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetWatch(3, 30);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetSensorType(port, type)\tab Function\par
\b0\fs20 Send the SetSensorType command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetSensorType(S1, SENSOR_TYPE_TOUCH);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetSensorMode(port, mode)\tab Function\par
\b0\fs20 Send the SetSensorMode command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetSensorMode(S1, SENSOR_MODE_BOOL);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXCreateDatalog(size)\tab Function\par
\b0\fs20 Send the CreateDatalog command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXCreateDatalog(50);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXAddToDatalog(src, value)\tab Function\par
\b0\fs20 Send the AddToDatalog command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXAddToDatalog(RCX_InputValueSrc, S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSendSerial(first, count)\tab Function\par
\b0\fs20 Send the SendSerial command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSendSerial(0, 10);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXRemote(cmd)\tab Function\par
\b0\fs20 Send the Remote command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXRemote(RCX_RemotePlayASound);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXEvent(src, value)\tab Function\par
\b0\fs20 Send the Event command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXEvent(RCX_ConstantSrc, 2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXPlayTone(freq, duration)\tab Function\par
\b0\fs20 Send the PlayTone command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPlayTone(440, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSelectDisplay(src, value)\tab Function\par
\b0\fs20 Send the SelectDisplay command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSelectDisplay(RCX_VariableSrc, 2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXPollMemory(address, count)\tab Function\par
\b0\fs20 Send the PollMemory command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPollMemory(0, 10);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetEvent(evt, src, type)\tab Function\par
\b0\fs20 Send the SetEvent command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetEvent(0, RCX_ConstantSrc, 5);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetGlobalOutput(outputs, mode)\tab Function\par
\b0\fs20 Send the SetGlobalOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetGlobalOutput(RCX_OUT_A, RCX_OUT_ON);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetGlobalDirection(outputs, dir)\tab Function\par
\b0\fs20 Send the SetGlobalDirection command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetGlobalDirection(RCX_OUT_A, RCX_OUT_FWD);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetMaxPower(outputs, pwrsrc, pwrval)\tab Function\par
\b0\fs20 Send the SetMaxPower command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetMaxPower(RCX_OUT_A, RCX_ConstantSrc, 5);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXEnableOutput(outputs)\tab Function\par
\b0\fs20 Send the EnableOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXEnableOutput(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXDisableOutput(outputs)\tab Function\par
\b0\fs20 Send the DisableOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDisableOutput(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXInvertOutput(outputs)\tab Function\par
\b0\fs20 Send the InvertOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXInvertOutput(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXObvertOutput(outputs)\tab Function\par
\b0\fs20 Send the ObvertOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXObvertOutput(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXCalibrateEvent(evt, low, hi, hyst)\tab Function\par
\b0\fs20 Send the CalibrateEvent command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXCalibrateEvent(0, 200, 500, 50);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the SetVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetVar(0, RCX_VariableSrc, 1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSumVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the SumVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSumVar(0, RCX_InputValueSrc, S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSubVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the SubVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSubVar(0, RCX_RandomSrc, 10);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXDivVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the DivVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDivVar(0, RCX_ConstantSrc, 2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXMulVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the MulVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXMulVar(0, RCX_VariableSrc, 4);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSgnVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the SgnVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSgnVar(0, RCX_VariableSrc, 0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXAbsVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the AbsVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXAbsVar(0, RCX_VariableSrc, 0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXAndVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the AndVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXAndVar(0, RCX_ConstantSrc, 0x7f);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXOrVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the OrVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOrVar(0, RCX_ConstantSrc, 0xCC);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSet(dstsrc, dstval, src, value)\tab Function\par
\b0\fs20 Send the Set command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSet(RCX_VariableSrc, 0, RCX_RandomSrc, 10000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXUnlock()\tab Function\par
\b0\fs20 Send the Unlock command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXUnlock();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXReset()\tab Function\par
\b0\fs20 Send the Reset command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXReset();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXBoot()\tab Function\par
\b0\fs20 Send the Boot command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXBoot();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetUserDisplay(src, value, precision)\tab Function\par
\b0\fs20 Send the SetUserDisplay command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetUserDisplay(RCX_VariableSrc, 0, 2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXIncCounter(counter)\tab Function\par
\b0\fs20 Send the IncCounter command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXIncCounter(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXDecCounter(counter)\tab Function\par
\b0\fs20 Send the DecCounter command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDecCounter(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXClearCounter(counter)\tab Function\par
\b0\fs20 Send the ClearCounter command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearCounter(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetPriority(p)\tab Function\par
\b0\fs20 Send the SetPriority command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetPriority(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTRCXSetMessage(msg)\tab Function\par
\b0\fs20 Send the SetMessage command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetMessage(20);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutCalibrateSensor()\tab Function\par
\b0\fs20 Send the CalibrateSensor command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutCalibrateSensor();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutMuteSound()\tab Function\par
\b0\fs20 Send the MuteSound command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutMuteSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutUnmuteSound()\tab Function\par
\b0\fs20 Send the UnmuteSound command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutUnmuteSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSelectSounds(group)\tab Function\par
\b0\fs20 Send the SelectSounds command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSelectSounds(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetLight(mode)\tab Function\par
\b0\fs20 Send the SetLight command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetLight(SCOUT_LIGHT_ON);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetCounterLimit(counter, src, value)\tab Function\par
\b0\fs20 Send the SetCounterLimit command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetCounterLimit(0, RCX_ConstantSrc, 2000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetTimerLimit(timer, src, value)\tab Function\par
\b0\fs20 Send the SetTimerLimit command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetTimerLimit(0, RCX_ConstantSrc, 10000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetSensorClickTime(src, value)\tab Function\par
\b0\fs20 Send the SetSensorClickTime command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetSensorClickTime(RCX_ConstantSrc, 200);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetSensorHysteresis(src, value)\tab Function\par
\b0\fs20 Send the SetSensorHysteresis command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetSensorHysteresis(RCX_ConstantSrc, 50);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetSensorLower Limit(src, value)\tab Function\par
\b0\fs20 Send the SetSensorLowerLimit command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetSensorLower Limit(RCX_ConstantSrc, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetSensorUpper Limit(src, value)\tab Function\par
\b0\fs20 Send the SetSensorUpperLimit command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetSensorUpper Limit(RCX_ConstantSrc, 400);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetEventFeedback(src, value)\tab Function\par
\b0\fs20 Send the SetEventFeedback command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetEventFeedback(RCX_ConstantSrc, 10);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSendVLL(src, value)\tab Function\par
\b0\fs20 Send the SendVLL command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSendVLL(RCX_ConstantSrc, 0x30);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetScoutRules(motion, touch, light, time, effect)\tab Function\par
\b0\fs20 Send the SetScoutRules command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetScoutRules(SCOUT_MR_FORWARD, SCOUT_TR_REVERSE, SCOUT_LR_IGNORE, SCOUT_TGS_SHORT, SCOUT_FXR_BUG);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub HTScoutSetScoutMode(mode)\tab Function\par
\b0\fs20 Send the SetScoutMode command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetScoutMode(SCOUT_MODE_POWER);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub ReadSensorMSRTClock(port, ss, mm, hh, dow, dd, MM, yy)\tab Function\par
\b0\fs20 Read real-time clock values from the Mindsensors RTClock sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 ReadSensorMSRTClock(S1, ss, mm, hh, dow, dd, mon, yy);\par
\pard\sb120\tqr\tx8640\b\f0\fs24\page\super #$AK\nosupersub SensorMSCompass(port)\tab Function\par
\b0\fs20 Return the Mindsensors Compass sensor value.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorMSCompass(S1);\par
\pard\f0\page\par
}
 