{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\fmodern\fprq1\fcharset0 Courier New;}{\f2\fmodern\fprq1\fcharset0 Courier;}}
{\colortbl ;\red0\green0\blue255;}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}{\s3 heading 3;}}
{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\qc\super\f0\fs20 #$K+\nosupersub\fs40 NXC Programmer's Guide\par
\fs28 Version 1.0.1 b33, by John Hansen\par
\pard\fs20\page\super #$K+\nosupersub\b\fs28 Contents\par
\b0\fs20 i \uldb Title page\ulnone\v IDH_NXCProgrammersGuide\v0\par
ii \uldb Contents\ulnone\v IDH_NXC_Contents\v0\par
1 \uldb Introduction\ulnone\v IDH_NXC_Introduction\v0\par
2 \uldb The NXC Language\ulnone\v IDH_NXC_Language\v0\par
2.1 \uldb Lexical Rules\ulnone\v IDH_NXC_LexicalRules\v0\par
2.1.1 \uldb Comments\ulnone\v IDH_NXC_Comments\v0\par
2.1.2 \uldb Whitespace\ulnone\v IDH_NXC_Whitespace\v0\par
2.1.3 \uldb Numerical Constants\ulnone\v IDH_NXC_NumericConstants\v0\par
2.1.4 \uldb Identifiers and Keywords\ulnone\v IDH_NXC_IdentKeywords\v0\par
2.2 \uldb Program Structure\ulnone\v IDH_NXC_ProgStructure\v0\par
2.2.1 \uldb Tasks\ulnone\v IDH_NXC_Tasks\v0\par
2.2.2 \uldb Functions\ulnone\v IDH_NXC_Functions\v0\par
2.2.3 \uldb Variables\ulnone\v IDH_NXC_Variables\v0\par
2.2.4 \uldb Structs\ulnone\v IDH_NXC_Structs\v0\par
2.2.5 \uldb Arrays\ulnone\v IDH_NXC_Arrays\v0\par
2.3 \uldb Statements\ulnone\v IDH_NXC_Statements\v0\par
2.3.1 \uldb Variable Declaration\ulnone\v IDH_NXC_VarDeclarations\v0\par
2.3.2 \uldb Assignment\ulnone\v IDH_NXC_Assignment\v0\par
2.3.3 \uldb Control Structures\ulnone\v IDH_NXC_ControlStructures\v0\par
2.3.4 \uldb The asm statement\ulnone\v IDH_NXC_TheAsmStatement\v0\par
2.3.5 \uldb Other Statements\ulnone\v IDH_NXC_OtherStatements\v0\par
2.4 \uldb Expressions\ulnone\v IDH_NXC_Expressions\v0\par
2.4.1 \uldb Conditions\ulnone\v IDH_NXC_Conditions\v0\par
2.5 \uldb The Preprocessor\ulnone\v IDH_NXC_Preprocessor\v0\par
2.5.1 \uldb #include\ulnone\v IDH_NXC_Include\v0\par
2.5.2 \uldb #define\ulnone\v IDH_NXC_Define\v0\par
2.5.3 \uldb ## (Concatenation)\ulnone\v IDH_NXC_Concatenation\v0\par
2.5.4 \uldb Conditional Compilation\ulnone\v IDH_NXC_CondCompilation\v0\par
3 \uldb NXC API\ulnone\v IDH_NXC_API\v0\par
3.1 General Features\par
3.1.1 \uldb Timing Functions\ulnone\v IDH_NXC_TimingFunctions\v0\par
3.1.2 \uldb Program Control Functions\ulnone\v IDH_NXC_ProgramControlFunctions\v0\par
3.1.3 \uldb String Functions\ulnone\v IDH_NXC_StringFunctions\v0\par
3.1.4 \uldb Array Functions\ulnone\v IDH_NXC_ArrayFunctions\v0\par
3.1.5 \uldb Numeric Functions\ulnone\v IDH_NXC_NumericFunctions\v0\par
3.1.6 \uldb Low-level System Functions\ulnone\v IDH_NXC_SystemFunctions\v0\par
3.2 \uldb Input Module\ulnone\v IDH_NXC_InputModule\v0\par
3.2.1 \uldb Types and Modes\ulnone\v IDH_NXC_SensorTypes\v0\par
3.2.2 \uldb Sensor Information\ulnone\v IDH_NXC_SensorInfo\v0\par
3.2.3 \uldb IOMap Offsets\ulnone\v IDH_NXC_InputIOMapOffsets\v0\par
3.3 \uldb Output Module\ulnone\v IDH_NXC_Outputs\v0\par
3.3.1 \uldb Convenience Calls\ulnone\v IDH_NXC_OutputsConvenience\v0\par
3.3.2 \uldb Primitive Calls\ulnone\v IDH_NXC_OutputsPrimitive\v0\par
3.3.3 \uldb IOMap Offsets\ulnone\v IDH_NXC_OutputIOMapOffsets\v0\par
3.4 \uldb IOMap Addresses\ulnone\v IDH_NXC_IOMapAddresses\v0\par
3.5 \uldb Sound Module\ulnone\v IDH_NXC_Sound\v0\par
3.5.1 \uldb High-level functions\ulnone\v IDH_NXC_SoundHighLevel\v0\par
3.5.2 \uldb Low-level functions\ulnone\v IDH_NXC_SoundLowLevel\v0\par
3.5.3 \uldb IOMap Offsets\ulnone\v IDH_NXC_SoundIOMapOffsets\v0\par
\lang1040 3.6 \uldb IO Control Module\ulnone\v IDH_NXC_IOCtrl\v0\par
3.6.1 \uldb IOMap Offsets\ulnone\v IDH_NXC_IOCtrlIOMapOffsets\v0\par
\lang1033 3.7 \uldb Display Module\ulnone\v IDH_NXC_Display\v0\par
3.7.1 \uldb High-level functions\ulnone\v IDH_NXC_DisplayHighLevel\v0\par
3.7.2 \uldb Low-level functions\ulnone\v IDH_NXC_DisplayLowLevel\v0\par
3.7.3 \uldb IOMap Offsets\ulnone\v IDH_NXC_DisplayIOMapOffsets\v0\par
3.8 \uldb Loader Module\ulnone\v IDH_NXC_Loader\v0\par
3.8.1 \uldb IOMap Offsets\ulnone\v IDH_NXC_LoaderIOMapOffsets\v0\par
3.9 \uldb Command Module\ulnone\v IDH_NXC_Command\v0\par
3.9.1 \uldb IOMap Offsets\ulnone\v IDH_NXC_CommandIOMapOffsets\v0\par
3.10 \uldb Button Module\ulnone\v IDH_NXC_Button\v0\par
3.10.1 \uldb High-level functions\ulnone\v IDH_NXC_ButtonHighLevel\v0\par
3.10.2 \uldb Low-level functions\ulnone\v IDH_NXC_ButtonLowLevel\v0\par
3.10.3 \uldb IOMap Offsets\ulnone\v IDH_NXC_ButtonIOMapOffsets\v0\par
3.11 \uldb UI Module\ulnone\v IDH_NXC_UserInterface\v0\par
3.11.1 \uldb IOMap Offsets\ulnone\v IDH_NXC_UIIOMapOffsets\v0\par
3.12 \uldb LowSpeed Module\ulnone\v IDH_NXC_LowSpeed\v0\par
3.12.1 \uldb High-level functions\ulnone\v IDH_NXC_LowSpeedHighLevel\v0\par
3.12.2 \uldb Low-level functions\ulnone\v IDH_NXC_LowSpeedLowLevel\v0\par
3.12.3 \uldb IOMap Offsets\ulnone\v IDH_NXC_LowSpeedIOMapOffsets\v0\par
3.13 \uldb Comm Module\ulnone\v IDH_NXC_Comm\v0\par
3.13.1 \uldb High-level functions\ulnone\v IDH_NXC_CommHighLevel\v0\par
3.13.2 \uldb Low-level functions\ulnone\v IDH_NXC_CommLowLevel\v0\par
3.13.2.1 \uldb Usb functions\ulnone\v IDH_NXC_CommUSB\v0\par
3.13.2.2 \uldb Hi-speed functions\ulnone\v IDH_NXC_CommHS\v0\par
3.13.2.3 \uldb Bluetooth functions\ulnone\v IDH_NXC_CommBT\v0\par
3.13.3 \uldb IOMap Offsets\ulnone\v IDH_NXC_CommIOMapOffsets\v0\par
3.14 \uldb HiTechnic API Functions\ulnone\v IDH_NXC_HiTechnic\v0\par
3.15 \uldb Mindsensors API Functions\ulnone\v IDH_NXC_Mindsensors\v0\par
\pard\keepn\s1\sb240\sa60\kerning28\b\fs28\page\super #$K+\nosupersub 1 Introduction\par
\pard\sa120\kerning0\b0\fs20 NXC stands for Not eXactly C. It is a simple language for programming the LEGO MINDSTORMS NXT product. The NXT has a bytecode interpreter (provided by LEGO), which can be used to execute programs. The NXC compiler translates a source program into NXT bytecodes, which can then be executed on the target itself. Although the preprocessor and control structures of NXC are very similar to C, NXC is not a general-purpose programming language - there are many restrictions that stem from limitations of the NXT bytecode interpreter.\par
Logically, NXC is defined as two separate pieces. The NXC language describes the syntax to be used in writing programs. The NXC Application Programming Interface (API) describes the system functions, constants, and macros that can be used by programs. This API is defined in a special file known as a "header file" which is, by default, automatically included when compiling a program.\par
This document describes both the NXC language and the NXC API. In short, it provides the information needed to write NXC programs. Since there are different interfaces for NXC, this document does not describe how to use any specific NXC implementation (such as the command-line compiler or Bricx Command Center). Refer to the documentation provided with the NXC tool, such as the NXC User Manual, for information specific to that implementation.\par
\pard For up-to-date information and documentation for NXC, visit the NXC website at http://bricxcc.sourceforge.net/nxc/.\par
\pard\keepn\s1\sb240\sa60\kerning28\b\fs28\page\super #$K+\nosupersub 2 The NXC Language\par
\pard\kerning0\b0\fs20 This section describes the NXC language itself. This includes the lexical rules used by the compiler, the structure programs, statements, and expressions, and the operation of the preprocessor.\par
NXC is a case-sensitive language just like C and C++. That means that the identifier "xYz" is not the same identifier as "Xyz". Similarly, the "if" statement begins with the keyword "if" but "iF", "If", or "IF" are all just valid identifiers \endash  not keywords.\par
\pard\keepn\s2\sb240\sa60\b\i\fs24\page\super #$K+\nosupersub 2.1 Lexical Rules\par
\pard\b0\i0\fs20 The lexical rules describe how NXC breaks a source file into individual tokens. This includes the way comments are written, then handling of whitespace, and valid characters for identifiers.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.1.1 Comments\par
\pard\fs20 Two forms of comments are supported in NXC. The first form (traditional C comments) begin with /* and end with */. They may span multiple lines, but do not nest:\par
\pard\fi-360\li1080\sb120\sa120\f1 /* this is a comment */\par
\pard\fi-360\li1080\sa120 /* this is a two\line line comment * /\par
/* another comment...\line /* trying to nest...\line  \tab ending the inner comment... */\line this text is no longer a comment! */\par
\pard\sb120\f0 The second form of comments begins with // and ends with a newline (sometimes known as C++ style comments).\par
\pard\li720\sb120\f1 // a single line comment\par
\pard\sb120\f0 Comments are ignored by the compiler. Their only purpose is to allow the programmer to document the source code.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.1.2 Whitespace\par
\pard\fs20 Whitespace (spaces, tabs, and newlines) is used to separate tokens and to make programs more readable. As long as the tokens are distinguishable, adding or subtracting whitespace has no effect on the meaning of a program. For example, the following lines of code both have the same meaning:\par
\pard\li720\sb120\f1 x=2;\par
\pard\li720 x = 2;\par
\pard\sb120\f0 Some of the C++ operators consist of multiple characters. In order to preserve these tokens whitespace must not be inserted within them. In the example below, the first line uses a right shift operator ('>>'), but in the second line the added space causes the '>' symbols to be interpreted as two separate tokens and thus generate an error.\par
\pard\li720\sb120\f1 x = 1 >> 4; / / set x to 1 right shifted by 4 bits\par
\pard\li720 x = 1 > > 4; // error\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 2.1.3 Numerical Constants\par
\pard\fs20 Numerical constants may be written in either decimal or hexadecimal form. Decimal constants consist of one or more decimal digits. Hexadecimal constants start with 0x or 0X followed by one or more hexadecimal digits.\par
\pard\li720\sb120\f1 x = 10; // set x to 10\par
\pard\li720 x = 0x10; // set x to 16 (10 hex)\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 2.1.4 Identifiers and Keywords\par
\pard\sa120\fs20 Identifiers are used for variable, task, function, and subroutine names. The first character of an identifier must be an upper or lower case letter or the underscore ('_'). Remaining characters may be letters, numbers, and an underscore. \par
A number of potential identifiers are reserved for use in the NXC language itself. These reserved words are called keywords and may not be used as identifiers. A complete list of keywords appears below:\par
\pard\li720\tx2520\tx4320\tx6480\f1 __RETURN__\tab __RETVAL__\tab __STRRETVAL__\tab __TMPBYTE__\par
__TMPWORD__\tab __TMPLONG__\tab abs\tab asm\par
bool\tab break\tab byte\tab case\par
char\tab const\tab continue\tab default\par
do\tab else\tab false\tab for\par
goto\tab if\tab inline\tab int\par
long\tab mutex\tab priority\tab repeat\par
return\tab safecall\tab short\tab sign\par
start\tab stop\tab string\tab struct\par
sub\tab switch\tab task\tab true\par
typedef\tab unsigned\tab until\tab void\par
while\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 2.2 Program Structure\par
\pard\b0\i0\fs20 An NXC program is composed of code blocks and variables. There are two distinct types of code blocks: tasks and functions. Each type of code block has its own unique features, but they share a common structure.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.2.1 Tasks\par
\pard\fs20 The NXT supports multi-tasking, so a task in NXC directly corresponds to an NXT thread. Tasks are defined using the task keyword using the following syntax:\par
\pard\li720\sb120\f1 task \i name\i0 ()\par
\pard\li720\{\par
\pard\fi720\li720 // the task's code is placed here\par
\pard\li720\}\par
\pard\sb120\f0 The name of the task may be any legal identifier. A program must always have at least one task - named "main" - which is started whenever the program is run. The maximum number of tasks is 256.\par
The body of a task consists of a list of statements. Scheduling dependant tasks using the Precedes or Follows API function is the primary mechanism supported by the NXT for starting other tasks concurrently. Tasks may also be started and stopped using the start and stop statements. There is also an NXC API command, StopAllTasks, which stops all currently running tasks. You can also stop all tasks using the Stop function. A task can stop itself via the ExitTo function or by task execution simply reaching the end of the task.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.2.2 Functions\par
\pard\fs20 It is often helpful to group a set of statements together into a single function, which can then be called as needed. NXC supports functions with arguments, but not return values. Functions are defined using the following syntax:\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\i\f2\fs22 [safecall] [inline] return_type\i0  \i name\i0 (\i argument_list\i0 )\line\{\line\tab // body of the function\line\}\par
\pard\sb120\expndtw0\f0\fs20 The return type should be the type of data returned. In the C programming language, functions are specified with the type of data they return. Functions that do not return data are specified to return void.\par
The argument list may be empty, or may contain one or more argument definitions. An argument is defined by its type followed by its name. Commas separate multiple arguments. All values are represented as bool, char, byte, int, short, long, unsigned int, unsigned long, strings, struct types, or arrays of any type. NXC also supports passing argument types by value, by constant value, by reference, and by constant reference. \par
When arguments are passed by value from the calling function to the callee the compiler must allocate a temporary variable to hold the argument. There are no restrictions on the type of value that may be used. However, since the function is working with a copy of the actual argument, the caller will not see any changes it makes to the value. In the example below, the function foo attempts to set the value of its argument to 2. This is perfectly legal, but since foo is working on a copy of the original argument, the variable y from main task remains unchanged.\par
\pard\li720\sb120\f1 void foo(int x)\par
\pard\li720\{\par
\pard\fi720\li720 x = 2;\par
\pard\li720\}\par
\par
task main()\par
\{\par
\pard\fi720\li720 int y = 1; // y is now equal to 1\par
foo(y); // y is still equal to 1!\par
\pard\li720\}\par
\pard\sb120\f0 The second type of argument, const arg_type, is also passed by value, but with the restriction that only constant values (e.g. numbers) may be used. This is rather important since there are a few NXT functions that only work with constant arguments.\par
\pard\li720\sb120\f1 void foo(const int x)\par
\pard\li720\{\par
\pard\fi720\li720 PlaySound(x); // ok\par
x = 1; // error - cannot modify argument\par
\pard\li720\}\par
\par
task main()\par
\{\par
\pard\fi720\li720 foo(2);   // ok\par
foo(4*5); // ok - expression is still constant\par
foo(x);   // error - x is not a constant\par
\pard\li720\}\par
\pard\sb120\f0 The third type, arg_type &, passes arguments by reference rather than by value. This allows the callee to modify the value and have those changes visible in the caller. However, only variables may be used when calling a function using arg_type & arguments:\par
\pard\li720\sb120\f1 void foo(int &x)\par
\pard\li720\{\par
\pard\fi720\li720 x = 2;\par
\pard\li720\}\par
\par
task main()\par
\{\par
\pard\fi720\li720 int y = 1; // y is equal to 1\par
foo(y);    // y is now equal to 2\par
foo(2);    // error - only variables allowed\par
\pard\li720\}\par
\pard\sb120\f0 The fourth type, const arg_type &, is rather unusual. It is also passed by reference, but with the restriction that the callee is not allowed to modify the value. Because of this restriction, the compiler is able to pass anything (not just variables) to functions using this type of argument. In general this is the most efficient way to pass arguments in NXC.\par
Functions must be invoked with the correct number (and type) of arguments. The example below shows several different legal and illegal calls to function foo:\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 void foo(int bar, const int baz)\line\{\line\tab // do something here...\line\}\line\line task main()\line\{\line\tab int x;\tab // declare variable x\line\line\tab foo(1, 2);\tab // ok\line\tab foo(x, 2);\tab // ok\line\tab foo(2, x);\tab // error - 2nd argument not constant!\line\tab foo(2);\tab // error - wrong number of arguments!\line\}\par
\pard\sb120\expndtw0\f0\fs20 NXC functions may optionally be marked as inline functions. This means that each call to a function will result in another copy of the function's code being included in the program. Unless used judiciously, inline functions can lead to excessive code size. \par
If a function is not marked as inline then an actual NXT subroutine is created and the call to the function in NXC code will result in a subroutine call to the NXT subroutine. The total number of non-inline functions (aka subroutines) and tasks must not exceed 256.\par
Another optional keyword that can be specified prior to the return type of a function is the safecall keyword. If a function is marked as safecall then the compiler will synchronize the execution of this function across multiple threads by wrapping each call to the function in Acquire and Release calls. If a second thread tries to call a safecall function while another thread is executing it the second thread will have to wait until the function returns to the first thread.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.2.3 Variables\par
\pard\sb120\sa120\fs20 All variables in NXC are of the following types: \par
\pard\li1548\tx3816\b Type Name\tab Information\par
\b0 bool\tab 8 bit unsigned\par
byte, unsigned char\tab 8 bit unsigned\par
char\tab 8 bit signed\par
unsigned int\tab 16 bit unsigned\par
short, int\tab 16 bit signed\par
unsigned long\tab 32 bit unsigned\par
long\tab 32 bit signed\par
mutex\tab Special type used for exclusive code access\par
string\tab Array of byte\par
struct\tab User-defined structure types\par
Arrays\tab Arrays of any type\par
\pard\sb120\sa120 Variables are declared using the keyword for the desired type followed by a comma-separated list of variable names and terminated by a semicolon (';'). Optionally, an initial value for each variable may be specified using an equals sign ('=') after the variable name. Several examples appear below:\par
\pard\li720\sb120\f1 int x;  \tab // declare x\par
bool y,z;\tab // declare y and z\par
long a=1,b;\tab // declare a and b, initialize a to 1\par
\pard\sb120\sa120\f0 Global variables are declared at the program scope (outside of any code block). Once declared, they may be used within all tasks, functions, and subroutines. Their scope begins at declaration and ends at the end of the program.\par
Local variables may be declared within tasks and functions. Such variables are only accessible within the code block in which they are defined. Specifically, their scope begins with their declaration and ends at the end of their code block. In the case of local variables, a compound statement (a group of statements bracketed by '\{' and '\}') is considered a block:\par
\pard\li720\f1 int x; // x is global\par
\par
task main()\par
\{\par
\pard\fi720\li720 int y; // y is local to task main\par
\pard\li1440 x = y; // ok\par
\pard\fi720\li720\{ // begin compound statement\par
\pard\fi720\li1440\lang3082 int z; // local z declared\par
y = z; // ok\par
\pard\fi720\li720\lang1033\}\par
y = z; // error - z no longer in scope\par
\pard\li720\}\par
\par
task foo()\par
\{\par
\pard\fi720\li720 x = 1; // ok\par
y = 2; // error - y is not global\par
\pard\li720\}\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 2.2.4 Structs\par
\pard\fs20 NXC supports user-defined aggregate types known as structs. These are declared very much like you declare structs in a C program.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct car\line\{\line   string car_type;\line   int manu_year;\line\};\line\line struct person\line\{\line   string name;\line   int age;\line   car vehicle;\line\};\line\line myType fred = 23;\line person myPerson;\par
\pard\sb120\expndtw0\f0\fs20 After you have defined the structure type you can use the new type to declare a variable or nested within another structure type declaration. Members (or fields) within the struct are accessed using a dot notation.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22   myPerson.age = 40;\line   \line   anotherPerson = myPerson;\line   \line   fooBar.car_type = "honda";\line   fooBar.manu_year = anotherPerson.age;\par
\pard\sb120\expndtw0\f0\fs20 You can assign structs of the same type but the compiler will complain if the types do not match.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.2.5 Arrays\par
\pard\fs20 NXC also support arrays. Arrays are declared the same way as ordinary variables, but with an open and close bracket following the variable name.\par
\pard\li720\sb120\f1 int my_array[]; // declare an array with zero elements\par
\pard\sb120\f0 To declare arrays with more than one dimension simply add more pairs of square brackets. The maximum number of dimensions supported in NXC is 4.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 bool my_array[][];  // declare a 2-dimensional array\par
\pard\sb120\expndtw0\f0\fs20 Global arrays with one dimension can be initialized at the point of declaration using the following syntax:\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 int X[] = \{1, 2, 3, 4\}, Y[]=\{10, 10\}; // 2 arrays\par
\pard\sb120\expndtw0\f0\fs20 The elements of an array are identified by their position within the array (called an index). The first element has an index of 0, the second has index 1, etc. For example:\par
\pard\li720\sb120\f1 my_array[0] = 123; // set first element to 123\par
\pard\li720 my_array[1] = my_array[2]; // copy third into second\par
\pard\sb120\f0 Currently there are some limitations on how arrays can be used. Some of these limitations will likely be removed in future versions of NXC.\par
To initialize local arrays or arrays with multiple dimensions it is necessary to use the ArrayInit function. The following example shows how to initialize a two-dimensional array using ArrayInit. It also demonstrates some of the supported array API functions and expressions.\par
\pard\hyphpar0\li720\sb120\expndtw-10\f2\fs22 task main()\line\{\line   int myArray[][];\line   int myVector[];\line   byte fooArray[][][];\line\line   ArrayInit(myVector, 0, 10); // 10 zeros in myVector\line   ArrayInit(myArray, myVector, 10); // 10 vectors myArray\line   ArrayInit(fooArray, myArray, 2); // 2 myArrays in fooArray\line\line   myVector = myArray[1]; // okay as of b25\line   fooArray[1] = myArray; // okay as of b25\line   myVector[4] = 34;\line   myArray[1] = myVector; // okay as of b25\line\line   int ax[], ay[];\line   ArrayBuild(ax, 5, 6);\line   ArrayBuild(ay, 2, 10, 6, 43);\line   int axlen = ArrayLen(ax);\line   ArraySubset(ax, ay, 1, 2); // ax = \{10, 6\}\line   if (ax == ay) \{ // array comparisons supported as of b25\line   \}\line\}\par
\pard\sb120\expndtw0\f0\fs20 NXC also supports specifying an initial size for both global and local arrays. The compiler automatically generates the required code to correctly initialize the array to zeros. If a global array declaration includes both a size and a set of initial values the size is ignored in favor of the specified values.\par
\pard\hyphpar0\li720\sb120\expndtw-10\f2\fs22 task main()\line\{\line   int myArray[10][10];\line   int myVector[10];\line\line //  ArrayInit(myVector, 0, 10); // 10 zeros in myVector\line //  ArrayInit(myArray, myVector, 10); // 10 vectors myArray\line\line /*\line  The calls to ArrayInit are not required since\line  we specified the equivalent initial sizes above.\line  In fact, the myVector array is not needed unless\line  we have a use for it other than to initialize myArray.\line */\line\}\par
\pard\keepn\s2\sb240\sa60\expndtw0\b\i\f0\fs24\page\super #$K+\nosupersub 2.3 Statements\par
\pard\b0\i0\fs20 The body of a code block (task or function) is composed of statements. Statements are terminated with a semi-colon (';').\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.3.1 Variable Declaration\par
\pard\fs20 Variable declaration, as described in the previous section, is one type of statement. It declares a local variable (with optional initialization) for use within the code block. The syntax for a variable declaration is:\par
\pard\li720\sb120\f1 int \i variables\i0 ;\par
\pard\sb120\f0 where variables is a comma separated list of names with optional initial values:\par
\pard\li720\sb120\i\f1 name\i0 [=expression]\par
\pard\sb120\f0 Arrays of variables may also be declared:\par
\pard\li720\sb120\f1 int \i array\i0 [n][=initializer for global one-dimension arrays];\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 2.3.2 Assignment\par
\pard\fs20 Once declared, variables may be assigned the value of an expression:\par
\pard\li720\sb120\i\f1 variable\i0  \i assign_operator\i0  \i expression\i0 ;\par
\pard\sb120\f0 There are thirteen different assignment operators. The most basic operator, '=', simply assigns the value of the expression to the variable. The other operators modify the variable's value in some other way as shown in the table below\par
\pard\li720\sb120\tx1980\b\f1 Operator\tab Action\par
\pard\li720\tx1980\b0 =\tab Set variable to expression\par
+=\tab Add expression to variable\par
-=\tab Subtract expression from variable\par
*=\tab Multiple variable by expression\par
/=\tab Divide variable by expression\par
%=\tab Set variable to remainder after dividing by expression\par
&=\tab Bitwise AND expression into variable\par
|=\tab Bitwise OR expression into variable\par
^=\tab Bitwise exclusive OR expression into variable\par
||=\tab Set variable to absolute value of expression\par
+-=\tab Set variable to sign (-1,+1,0) of expression\par
>>=\tab Right shift variable by a constant amount\par
<<=\tab Left shift variable by a constant amount\par
\pard\sb120\f0 Some examples:\par
\pard\li720\sb120\f1 x = 2; // set x to 2\par
\pard\li720 y = 7; // set y to 7\par
x += y; // x is 9, y is still 7\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 2.3.3 Control Structures\par
\pard\fs20 The simplest control structure is a compound statement. This is a list of statements enclosed within curly braces ('\f1\{\f0 ' and '\f1\}\f0 '):\par
\pard\li720\sb120\f1\{\par
\pard\fi720\li720 x = 1;\par
y = 2;\par
\pard\li720\}\par
\pard\sb120\f0 Although this may not seem very significant, it plays a crucial role in building more complicated control structures. Many control structures expect a single statement as their body. By using a compound statement, the same control structure can be used to control multiple statements.\par
The \f1 if\f0  statement evaluates a condition. If the condition is true it executes one statement (the consequence). An optional second statement (the alternative) is executed if the condition is false. The two syntaxes for an \f1 if\f0  statement are shown below.\par
\pard\li720\sb120\f1 if (\i condition\i0 ) \i consequence\i0\par
\pard\li720 if (\i condition\i0 ) \i consequence\i0  else \i alternative\i0\par
\pard\sb120\f0 Note that the condition is enclosed in parentheses. Examples are shown below. Note how a compound statement is used in the last example to allow two statements to be executed as the consequence of the condition.\par
\pard\li720\sb120\f1 if (x == 1) y = 2;\par
\pard\li720 if (x == 1) y = 3; else y = 4;\par
if (x == 1) \{y = 1; z = 2;\}\par
\pard\sb120\f0 The \f1 while\f0  statement is used to construct a conditional loop. The condition is evaluated, and if true the body of the loop is executed, then the condition is tested again. This process continues until the condition becomes false (or a \f1 break\f0  statement is executed). The syntax for a \f1 while\f0  loop appears below:\par
\pard\li720\sb120\f1 while (\i condition\i0 ) \i body\i0\par
\pard\sb120\f0 It is very common to use a compound statement as the body of a loop:\par
\pard\li720\sb120\lang3082\f1 while (x < 10)\par
\pard\li720\{\par
\pard\fi720\li720 x = x+1;\par
y = y*2;\par
\pard\li720\lang1033\}\par
\pard\sb120\f0 A variant of the \f1 while\f0  loop is the \f1 do-while\f0  loop. Its syntax is:\par
\pard\li720\sb120\f1 do \i body\i0  while (\i condition\i0 )\par
\pard\sb120\f0 The difference between a \f1 while\f0  loop and a \f1 do-while\f0  loop is that the \f1 do-while\f0  loop always executes the body at least once, whereas the \f1 while\f0  loop may not execute it at all. Another kind of loop is the \f1 for\f0  loop:\par
\pard\li720\sb120\f1 for (\i stmt1\i0 ; \i condition\i0 ; \i stmt2\i0 ) \i body\i0\par
\pard\sb120\f0 A \f1 for\f0  loop always executes stmt1, then it repeatedly checks the condition and while it remains true executes the body followed by stmt2. The \f1 for\f0  loop is equivalent to:\par
\pard\li720\sb120\i\f1 stmt1\i0 ;\par
\pard\li720 while (\i condition\i0 )\par
\{\par
\pard\fi720\li720\i body\par
stmt2\i0 ;\par
\pard\li720\}\par
\pard\sb120\f0 The repeat statement executes a loop a specified number of times:\par
\pard\li720\sb120\f1 repeat (\i expression\i0 ) \i body\i0\par
\pard\sb120\f0 The expression determines how many times the body will be executed. Note that it is only evaluated a single time, then the body is repeated that number of times. This is different from both the \f1 while\f0  and \f1 do-while\f0  loops which evaluate their condition each time through the loop.\par
A \f1 switch\f0  statement can be used to execute one of several different blocks of code depending on the value of an expression. Each block of code is preceded by one or more \f1 case\f0  labels. Each \f1 case\f0  must be a constant and unique within the \f1 switch\f0  statement. The \f1 switch\f0  statement evaluates the expression then looks for a matching \f1 case\f0  label. It will then execute any statements following the matching \f1 case\f0  until either a \f1 break\f0  statement or the end of the \f1 switch\f0  is reached. A single \f1 default\f0  label may also be used - it will match any value not already appearing in a \f1 case\f0  label. Technically, a \f1 switch\f0  statement has the following syntax:\par
\pard\li720\sb120\f1 switch (\i expression\i0 ) \i body\i0\par
\pard\sb120\f0 The \f1 case\f0  and \f1 default\f0  labels are not statements in themselves - they are \i labels\i0  that precede statements. Multiple labels can precede the same statement. These labels have the following syntax\par
\pard\li720\sb120\f1 case \i constant_expression\i0  :\par
\pard\li720 default :\par
\pard\sb120\f0 A typical switch statement might look like this:\par
\pard\li720\sb120\f1 switch(x)\par
\pard\li720\{\par
\pard\fi720\li720 case 1:\par
\pard\fi720\li1440 // do something when x is 1\par
break;\par
\pard\fi720\li720 case 2:\par
case 3:\par
\pard\fi720\li1440 // do something else when x is 2 or 3\par
break;\par
\pard\fi720\li720 default:\par
\pard\fi720\li1440 // do this when x is not 1, 2, or 3\par
\pard\fi720\li720 break;\par
\pard\li720\}\par
\pard\sb120\sa120\f0 NXC also supports using string types in the switch expression and constant strings in case labels.\par
The \f1 goto\f0  statement forces a program to jump to the specified location. Statements in a program can be labeled by preceding them with an identifier and a colon. A \f1 goto\f0  statement then specifies the label which the program should jump to. For example, this is how an infinite loop that increments a variable could be implemented using \f1 goto\f0 :\par
\pard\li720\f1 my_loop:\par
\pard\fi720\li720 x++;\par
goto my_loop;\par
\pard\f0\par
The \f1 goto\f0  statement should be used sparingly and cautiously. In almost every case, control structures such as \f1 if\f0 , \f1 while\f0 , and \f1 switch\f0  make a program much more readable and maintainable than using \f1 goto\f0 . \par
\pard\sb120 NXC also defines the \f1 until\f0  macro which provides a convenient alternative to the \f1 while\f0  loop. The actual definition of \f1 until\f0  is:\par
\pard\li720\sb120\f1 #define until(c) while (!(c))\par
\pard\sb120\f0 In other words, \f1 until\f0  will continue looping until the condition becomes true. It is most often used in conjunction with an empty body statement:\par
\pard\li720\sb120\f1 until(SENSOR_1 == 1); // wait for sensor to be pressed\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 2.3.4 The asm Statement\par
\pard\fs20 The asm statement is used to define many of the NXC API calls. The syntax of the statement is:\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 asm \{ \line  \i one or more lines of assembly language\i0\line\}\par
\pard\sb120\expndtw0\f0\fs20 The statement simply emits the body of the statement as NeXT Byte Codes (NBC) code and passes it directly to the NBC compiler backend. The asm statement can often be used to optimize code so that it executes as fast as possible on the NXT firmware.  The following example shows an asm block containing variable declarations, labels, and basic NBC statements as well as comments.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 asm \{ \line //      jmp __lbl00D5\line       dseg segment\line         sl0000 slong\line         sl0005 slong\line         bGTTrue byte\line       dseg ends\line       mov\tab sl0000, 0x0\line       mov\tab sl0005, sl0000\line       mov\tab sl0000, 0x1\line       cmp\tab GT, bGTTrue, sl0005, sl0000\line       set bGTTrue, FALSE\line       brtst\tab EQ, __lbl00D5, bGTTrue\line   __lbl00D5:\line\}\par
\pard\sb120\expndtw0\f0\fs20 A few NXC keywords have meaning only within an asm statement. These keywords provide a means for returning string or scalar values from asm statements and for using temporary integer variables of byte, word, and long sizes.\par
\pard\li720\sb120\tx2880\b ASM Keyword\tab Meaning\par
\b0 __RETURN__\tab Used to return a value other than __RETVAL__ or __STRRETVAL__\par
__RETVAL__\tab Writing to this 4-byte value returns it to the calling program\par
__STRRETVAL__\tab Writing to this string value returns it to the calling program\par
__TMPBYTE__\tab Use this temporary variable to write and return single byte values\par
__TMPWORD__\tab Use this temporary variable to write and return 2-byte values\par
__TMPLONG__\tab Use this temporary variable to write and return 4-byte values\par
\pard\sb120 The asm block statement and these special ASM keywords are used throughout the NXC API. See the NXCDefs.h header file for several examples of how they can be put to use. To keep the main NXC code as "C-like" as possible and for the sake of better readability NXC asm block statements can be wrapped in preprocessor macros and placed in custom header files which are included using #include. The following example demonstrates using macro wrappers around asm block statements.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 #define SetMotorSpeed(port, cc, thresh, fast, slow) \\\line   asm \{ \\\line   set theSpeed, fast \\\line   brcmp cc, EndIfOut__I__, SV, thresh \\\line   set theSpeed, slow \\\line EndIfOut__I__: \\\line   OnFwd(port, theSpeed) \\\line   __IncI__ \\\line\}\par
\pard\keepn\s3\sb240\sa60\expndtw0\f0\fs24\page\super #$K+\nosupersub 2.3.5 Other Statements\par
\pard\fs20 A function (or subroutine) call is a statement of the form:\par
\pard\li720\sb120\i\f1 name\i0 (\i arguments\i0 );\par
\pard\sb120\f0 The arguments list is a comma separated list of expressions. The number and type of arguments supplied must match the definition of the function itself. Tasks may be started or stopped with the following statements:\par
\pard\li720\sb120\f1 start \i task_name\i0 ;\par
\pard\li720 stop \i task_name\i0 ;\par
\pard\sb120\f0 You can adjust the priority of a task using the priority statement.\par
\pard\li720\sb120\f1 priority task_name, new_priority;\par
\pard\sb120\f0 Within loops (such as a \f1 while\f0  loop) the \f1 break\f0  statement can be used to exit the loop and the \f1 continue\f0  statement can be used to skip to the top of the next iteration of the loop. The \f1 break\f0  statement can also be used to exit a \f1 switch\f0  statement.\par
\pard\li720\sb120\f1 break;\par
\pard\li720 continue;\par
\pard\sb120\f0 It is possible to cause a function to return before it reaches the end of its code using the \f1 return\f0  statement with an optional return value.\par
\pard\li720\sb120\f1 return\f0  \f1 [expression];\par
\pard\sb120\f0 Many expressions are not legal statements. One notable exception is expressions involving the increment (++) or decrement (--) operators.\par
\pard\li720\sb120\f1 x++;\par
\pard\sb120\f0 The empty statement (just a bare semicolon) is also a legal statement.\par
\pard\keepn\s2\sb240\sa60\b\i\fs24\page\super #$K+\nosupersub 2.4 Expressions\par
\pard\sb120\b0\i0\fs20 Values are the most primitive type of expressions. More complicated expressions are formed from values using various operators. The NXC language only has two built in kinds of values: numerical constants and variables.\par
Numerical constants in the NXT are represented as integers. The type depends on the value of the constant. NXC internally uses 32 bit signed math for expression evaluation. Numeric constants can be written as either decimal (e.g. 123) or hexadecimal (e.g. 0xABC). Presently, there is very little range checking on constants, so using a value larger than expected may have unusual effects.\par
Two special values are predefined: true and false. The value of false is zero (0), while the value of true is one (1). The same values hold for relational operators (e.g. <): when the relation is false the value is 0, otherwise the value is 1.\par
Values may be combined using operators. Several of the operators may only be used in evaluating constant expressions, which means that their operands must either be constants, or expressions involving nothing but constants. The operators are listed here in order of precedence (highest to lowest).\par
\pard\li360\sb120\tx1440\tx4140\tx5580\tx7380\b Operator\tab Description\tab Associativity\tab Restriction\tab Example\par
\pard\li360\tx1440\tx4140\tx5580\tx7380\b0 abs()\tab Absolute value\tab n/a\tab\tab abs(x)\par
sign()\tab Sign of operand\tab n/a\tab\tab sign(x)\par
++, --\tab Increment, decrement\tab left\tab variables only\tab x++ or ++x\par
-\tab Unary minus\tab right\tab\tab -x\par
~\tab Bitwise negation (unary)\tab right\tab\tab ~123\par
!\tab Logical negation\tab right\tab\tab !x\par
*, /, %\tab Multiplication, division,modulo\tab left\tab\tab x * y\par
+, -\tab Addition, subtraction\tab left\tab\tab x + y\par
<<, >>\tab Left and right shift\tab left\tab\tab 123 << 4\par
<, >,<=, >=\tab relational operators\tab left\tab\tab x < y\par
==, !=\tab equal to, not equal to\tab left\tab\tab x == 1\par
&\tab Bitwise AND\tab left\tab\tab x & y\par
^\tab Bitwise XOR\tab left\tab\tab 123 ^ 4\par
|\tab Bitwise OR\tab left\tab\tab x | y\par
&&\tab Logical AND\tab left\tab\tab x && y\par
||\tab Logical OR\tab left\tab\tab x || y\par
? :\tab conditional value\tab n/a\tab\tab x==1 ? y : z\par
\pard\li360\sb120\tx1440\tx4140\tx5580\tx7380 Where needed, parentheses may be used to change the order of evaluation:\par
\pard\li720\sb120\tx1440\tx4140\tx5580\tx7380\f1 x = 2 + 3 * 4; // set x to 14\par
\pard\li720\tx1440\tx4140\tx5580\tx7380 y = (2 + 3) * 4; // set y to 20\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 2.4.1 Conditions\par
\pard\fs20 Conditions are generally formed by comparing two expressions. There are also two constant conditions - \f1 true\f0  and \f1 false\f0  - which always evaluate to true or false respectively. A condition may be negated with the negation operator, or two conditions combined with the AND and OR operators. The table below summarizes the different types of conditions.\par
\pard\fi-1800\li2520\sb120\tx2520\b Condition\tab Meaning\par
\pard\fi-1800\li2520\tx2520\b0 true\tab always true\par
false\tab always false\par
expr\tab true if expr is not equal to 0\par
expr1 == expr2\tab true if expr1 equals expr2\par
expr1 != expr2\tab true if expr1 is not equal to expr2\par
expr1 < expr2\tab true if one expr1 is less than expr2\par
expr1 <= expr2\tab true if expr1 is less than or equal to expr2\par
expr1 > expr2\tab true if expr1 is greater than expr2\par
expr1 >= expr2\tab true if expr1 is greater than or equal to expr2\par
! condition\tab logical negation of a condition - true if condition is false\par
cond1 && cond2\tab logical AND of two conditions (true if and only if both conditions are true)\par
cond1 || cond2\tab logical OR of two conditions (true if and only if at least one of the conditions are true)\par
\pard\keepn\s2\sb240\sa60\b\i\fs24\page\super #$K+\nosupersub 2.5 The Preprocessor\par
\pard\b0\i0\fs20 The preprocessor implements the following directives: \f1 #include\f0 , \f1 #define\f0 , \f1 #ifdef\f0 , \f1 #ifndef\f0 , \f1 #if\f0 , \f1 #elif\f0 , \f1 #else\f0 , \f1 #endif\f0 , \f1 #undef,##,\f0  \f1 #line\f0 , and \f1 #pragma\f0 . Its implementation is fairly close to a standard C preprocessor, so most things that work in a generic C preprocessor should have the expected effect in NXC. Significant deviations are listed below.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.5.1 #include\par
\pard\fs20 The \f1 #include\f0  command works as expected, with the caveat that the filename must be enclosed in double quotes. There is no notion of a system include path, so enclosing a filename in angle brackets is forbidden.\par
\pard\li720\sb120\f1 #include "foo.h" // ok\par
\pard\li720 #include <foo.h> // error!\par
\pard\sb120\f0 NXC programs can begin with #include "NXCDefs.h" but they don't need to. This standard header file includes many important constants and macros which form the core NXC API. Current versions of NXC no longer require that you manually include the NXCDefs.h header file. Unless you specifically tell the compiler to ignore the standard system files this header file will automatically be included for you.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.5.2 #define\par
\pard\fs20 The \f1 #define\f0  command is used for simple macro substitution. Redefinition of a macro is an error (unlike in C where it is a warning). Macros are normally terminated by the end of the line, but the newline may be escaped with the backslash ('\\') to allow multiline macros:\par
\pard\li720\sb120\f1 #define foo(x) do \{ bar(x); \\\par
\pard\fi720\li2160   baz(x); \} while( false)\par
\pard\sb120\f0 The \f1 #undef\f0  directive may be used to remove a macro\rquote s definition.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.5.3 ## (Concatenation)\par
\pard\sb120\fs20 The ## directive works similar to the C preprocessor. It is replaced by nothing, which causes tokens on either side to be concatenated together. Because it acts as a separator initially, it can be used within macro functions to produce identifiers via combination with parameter values.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 2.5.4 Conditional Compilation\par
\pard\fs20 Conditional compilation works similar to the C preprocessor. The following preprocessor directives may be used:\par
\pard\li720\sb120\f1 #if \i condition\i0\par
\pard\li720 #ifdef \i symbol\i0\par
#ifndef \i symbol\i0\par
#else\par
#elif \i condition\i0\par
#endif\par
\pard\sb120\f0 Conditions in \f1 #if\f0  directives use the same operators and precedence as in C. The \f1 defined()\f0  operator is supported.\par
\pard\keepn\s1\sb240\sa60\kerning28\b\fs28\page\super #$K+\nosupersub 3 NXC API\par
\pard\sb120\kerning0\b0\fs20 The NXC API defines a set of constants, functions, values, and macros that provide access to various capabilities of the NXT such as sensors, outputs, and communication. \par
The API consists of functions, values, and constants. A function is something that can be called as a statement. Typically it takes some action or configures some parameter. Values represent some parameter or quantity and can be used in expressions. Constants are symbolic names for values that have special meanings for the target. Often, a set of constants will be used in conjunction with a function.\par
\pard\keepn\s2\sb240\sa60\b\i\fs24\page\super #$K+\nosupersub 3.1.1 Timing Functions\par
\pard\sb120\tqr\tx8640\i0 Wait(time)\tab Function\par
\pard\sb120\b0\fs20 Make a task sleep for specified amount of time (in 1000ths of a second). The time argument may be an expression or a constant:\par
\pard\li720\sb120\f1 Wait(1000);\tab // wait 1 second\line Wait(Random(1000)); // wait random time up to 1 second\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CurrentTick()\tab Value\par
\pard\sb120\b0\fs20 Return an unsigned 32-bit value, which is the current system timing value (called a "tick") in milliseconds.\par
\pard\li720\sb120\f1 x = CurrentTick();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 FirstTick()\tab Value\par
\pard\sb120\b0\fs20 Return an unsigned 32-bit value, which is the system timing value (called a "tick") in milliseconds at the time that the program began running.\par
\pard\li720\sb120\f1 x = FirstTick();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SleepTime()\tab Value\par
\pard\sb120\b0\fs20 Return the number of minutes that the NXT will remain on before it automatically shuts down.\par
\pard\li720\sb120\f1 x = SleepTime();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SleepTimer()\tab Value\par
\pard\sb120\b0\fs20 Return the number of minutes left in the countdown to zero from the original SleepTime value. When the SleepTimer value reaches zero the NXT will shutdown.\par
\pard\li720\sb120\f1 x = SleepTimer();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ResetSleepTimer()\tab Function\par
\pard\sb120\b0\fs20 Reset the system sleep timer back to the SleepTime value. Executing this function periodically can keep the NXT from shutting down while a program is running.\par
\pard\li720\sb120\f1 ResetSleepTimer();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSleepTime(minutes)\tab Function\par
\b0\fs20 Set the sleep timeout the requested number of minutes. Specifying 0 minutes disables the sleep feature.\par
\pard\li720\sb120\f1 SetSleepTime(8);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SleepNow()\tab Function\par
\b0\fs20 Turn off the NXT immediately.\par
\pard\li720\sb120\tqr\tx8640\f1 SleepNow();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSleepTimer(minutes)\tab Function\par
\pard\sb120\b0\fs20 Set the system sleep timer to the specified number of minutes.\par
\pard\li720\sb120\f1 SetSleepTimer(3);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 3.1.2 Program Control Functions\par
\pard\sb120\tqr\tx8640\i0 Stop(bvalue)\tab Function\par
\pard\sb120\b0\fs20 Stop the running program if bvalue is true. This will halt the program completely, so any code following this command will be ignored.\par
\pard\li720\sb120\f1 Stop(x == 24); // stop the program if x==24\par
\pard\sb120\tqr\tx8640\b\f0\fs24 StopAllTasks()\tab Function\par
\pard\sb120\b0\fs20 Stop all currently running tasks. This will halt the program completely, so any code following this command will be ignored.\par
\pard\li720\sb120\f1 StopAllTasks(); // stop the program\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Acquire(mutex)\tab Function\par
\pard\sb120\b0\fs20 Acquire the specified mutex variable. If another task already has acquired the mutex then the current task will be suspended until the mutex is released by the other task. This function is used to ensure that the current task has exclusive access to a shared resource, such as the display or a motor. After the current task has finished using the shared resource the program should call Release to allow other tasks to acquire the mutex.\par
\pard\li720\sb120\f1 Acquire(motorMutex); // make sure we have exclusive access\line // use the motors\line Release(motorMutex);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Release(mutex)\tab Function\par
\pard\sb120\b0\fs20 Release the specified mutex variable. Use this to relinquish a mutex so that it can be acquired by another task. Release should always be called after a matching call to Acquire and as soon as possible after a shared resource is no longer needed.\par
\pard\li720\sb120\f1 Acquire(motorMutex); // make sure we have exclusive access\line // use the motors\line Release(motorMutex); // release mutex for other tasks\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Precedes(task1, task2, ..., taskN)\tab Function\par
\pard\sb120\b0\fs20 Schedule the specified tasks for execution once the current task has completed executing. The tasks will all execute simultaneously unless other dependencies prevent them from doing so. Generally this function should be called once within a task \endash  preferably at the start of the task definition.\par
\pard\li720\sb120\f1 Precedes(moving, drawing, playing); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 Follows(task1, task2, ..., taskN)\tab Function\par
\pard\sb120\b0\fs20 Schedule this task to follow the specified tasks so that it will execute once any of the specified tasks has completed executing. Generally this function should be called once within a task \endash  preferably at the start of the task definition. If multiple tasks declare that they follow the same task then they will all execute simultaneously unless other dependencies prevent them from doing so.\par
\pard\li720\sb120\f1 Follows(main); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 ExitTo(task)\tab Function\par
\pard\sb120\b0\fs20 Immediately exit the current task and start executing the specified task.\par
\pard\li720\sb120\f1 ExitTo(nextTask); \par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 3.1.3 String Functions\par
\pard\sb120\tqr\tx8640\i0 StrToNum(str)\tab Value\par
\pard\sb120\b0\fs20 Return the numeric value specified by the string passed to the function. If the content of the string is not a numeric value then this function returns zero.\par
\pard\li720\sb120\f1 x = StrToNum(strVal);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 StrLen(str)\tab Value\par
\pard\sb120\b0\fs20 Return the length of the specified string. The length of a string does not include the null terminator at the end of the string.\par
\pard\li720\sb120\f1 x = StrLen(msg); // return the length of msg\par
\pard\sb120\tqr\tx8640\b\f0\fs24 StrIndex(str, idx)\tab Value\par
\pard\sb120\b0\fs20 Return the numeric value of the character in the specified string at the specified index.\par
\pard\li720\sb120\f1 x = StrIndex(msg, 2); // return the value of msg[2]\par
\pard\sb120\tqr\tx8640\b\f0\fs24 NumToStr(value)\tab Value\par
\pard\sb120\b0\fs20 Return the string representation of the specified numeric value.\par
\pard\li720\sb120\f1 msg = NumToStr(-2); // returns "-2" in a string\par
\pard\sb120\tqr\tx8640\b\f0\fs24 FormatNum(fmtstr, value)\tab Value\par
\pard\sb120\b0\fs20 Return the formatted string using the format and value. Use standard numeric sprintf format specifiers within the format string.\par
\pard\li720\sb120\f1 msg = FormatNum("value = %d", x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 StrCat(str1, str2, ..., strN)\tab Value\par
\pard\sb120\b0\fs20 Return a string which is the result of concatenating all of the string arguments together.\par
\pard\li720\sb120\f1 msg = StrCat("test", "please"); // returns "testplease"\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SubStr(string, idx, len)\tab Value\par
\pard\sb120\b0\fs20 Return a sub-string from the specified input string starting at idx and including the specified number of characters.\par
\pard\li720\sb120\f1 msg = SubStr("test", 1, 2); // returns "es"\par
\pard\sb120\tqr\tx8640\b\f0\fs24 StrReplace(string, idx, newStr)\tab Value\par
\pard\sb120\b0\fs20 Return a string with the part of the string replaced (starting at the specified index) with the contents of the new string value provided in the third argument.\par
\pard\li720\sb120\f1 msg = StrReplace("testing", 3, "xx"); // returns "tesxxng"\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Flatten(value)\tab Value\par
\pard\sb120\b0\fs20 Return a string containing the byte representation of the specified value.\par
\pard\li720\sb120\f1 msg = Flatten(48); // returns "0" since 48 == ascii("0")\par
msg = Flatten(12337); // returns "10" (little-endian)\par
\pard\sb120\tqr\tx8640\b\f0\fs24 FlattenVar(anytype)\tab Value\par
\pard\sb120\b0\fs20 Return a string containing the byte representation of the specified variable.\par
\pard\li720\sb120\f1 stringValue = FlattenVar(myStruct);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 UnflattenVar(string, anytype)\tab Function\par
\pard\sb120\b0\fs20 Convert a string containing the byte representation of the specified variable back into the original variable type.\par
\pard\li720\sb120\f1 UnflattenVar(stringValue, myStruct);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ByteArrayToStr(arr)\tab Value\par
\pard\sb120\b0\fs20 Convert the specified array to a string by appending a null terminator to the end of the array elements. The array must be a one-dimensional array of byte.\par
\pard\li720\sb120\f1 myStr = ByteArrayToStr(myArray);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ByteArrayToStrEx(arr, out str)\tab Function\par
\pard\sb120\b0\fs20 Convert the specified array to a string by appending a null terminator to the end of the array elements. The array must be a one-dimensional array of byte.\par
\pard\li720\sb120\f1 ByteArrayToStrEx(myArray, myStr);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 3.1.4 Array Functions\par
\pard\sb120\tqr\tx8640\i0 StrToByteArray(str, out arr)\tab Function\par
\pard\sb120\b0\fs20 Convert the specified string to an array of byte by removing the null terminator at the end of the string. The output array variable must be a one-dimensional array of byte.\par
\pard\li720\sb120\f1 StrToByteArray(myStr, myArray);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ArrayLen(array)\tab Value\par
\pard\sb120\b0\fs20 Return the length of the specified array.\par
\pard\li720\sb120\f1 x = ArrayLen(myArray); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 ArrayInit(array, value, count)\tab Function\par
\pard\sb120\b0\fs20 Initialize the array to contain count elements with each element equal to the value provided. To initialize a multi-dimensional array, the value should be an array of N-1 dimensions, where N is the number of dimensions in the array being initialized.\par
\pard\li720\sb120\f1 ArrayInit(myArray, 0, 10); // 10 elements == zero\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ArraySubset(out aout, asrc, idx, len)\tab Function\par
\pard\sb120\b0\fs20 Copy a subset of the source array starting at the specified index and containing the specified number of elements into the destination array.\par
\pard\li720\sb120\f1 ArraySubset(myArray, srcArray, 2, 5); copy 5 elements\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ArrayBuild(out aout, src1 [, src2, \'85, srcN])\tab Function\par
\pard\sb120\b0\fs20 Build a new array from the specified source(s). The sources can be of any type. If a source is an array then all of its elements are added to the output array.\par
\pard\li720\sb120\f1 ArrayBuild(myArray, src1, src2);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 3.1.5 Numeric Functions\par
\pard\sb120\tqr\tx8640\i0 Random(n)\tab Value\par
\pard\sb120\b0\fs20 Return an unsigned 16-bit random number between 0 and n (exclusive). N can be a constant or a variable.\par
\pard\li720\sb120\f1 x = Random(10); // return a value of 0..9\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Random()\tab Value\par
\pard\sb120\b0\fs20 Return a signed 16-bit random number.\par
\pard\li720\sb120\f1 x = Random();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Sqrt(x)\tab Value\par
\pard\sb120\b0\fs20 Return the square root of the specified value.\par
\pard\li720\sb120\f1 x = Sqrt(x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Sin(degrees)\tab Value\par
\pard\sb120\b0\fs20 Return the sine of the specified degrees value. The result is 100 times the sine value (-100..100).\par
\pard\li720\sb120\f1 x = Sin(theta);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Cos(degrees)\tab Value\par
\pard\sb120\b0\fs20 Return the cosine of the specified degrees value. The result is 100 times the cosine value (-100..100).\par
\pard\li720\sb120\f1 x = Cos(y);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Asin(value)\tab Value\par
\pard\sb120\b0\fs20 Return the inverse sine of the specified value (-100..100). The result is degrees (-90..90).\par
\pard\li720\sb120\f1 deg = Asin(80);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Acos(value)\tab Value\par
\pard\sb120\b0\fs20 Return the inverse cosine of the specified value (-100..100). The result is degrees (0..180).\par
\pard\li720\sb120\f1 deg = Acos(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 bcd2dec(bcdValue)\tab Value\par
\pard\sb120\b0\fs20 Return the decimal equivalent of the binary coded decimal value provided.\par
\pard\li720\sb120\f1 dec = bcd2dec(0x3a);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 3.1.6 Low-level System Functions\par
\pard\sb120\b0\i0\fs20 There are several standard structures that are defined by the NXC API for use with calls to low-level system functions defined within the NXT firmware. These structures are the means for passing values into the system functions and for returning values from the system functions. In order to call a system function you will need to declare a variable of the required system function structure type, set the structure members as needed by the system function, call the function, and then read the results, if desired.\par
Many of these system functions are wrapped into higher level NXC API functions so that the details are hidden from view. Using these low-level API calls you can improve the speed of your programs a little.\par
If you install the NBC/NXC enhanced standard NXT firmware on your NXT all the screen drawing system function also supports clearing pixels in addition to setting them. To switch from setting pixels to clearing pixels just specify the DRAW_OPT_CLEAR_PIXELS value (0x0004) in the Options member of the structures. This value can be ORed together with the DRAW_OPT_CLEAR_WHOLE_SCREEN value (0x0001) if desired. Also, some of the system functions and their associated structures are only supported by the NBC/NXC enhanced standard NXT firmware.  These functions are marked with (+) to indicate this additional requirement.\par
The first two structures define types are used within several other structures required by the screen drawing system functions.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct LocationType \{\line   int X;\line   int Y;\line\};\par
struct SizeType \{\line   int Width;\line   int Height;\line\};\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysDrawText(DrawTextType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw text on the NXT LCD given the parameters you pass in via the DrawTextType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22  struct DrawTextType \{\line   char Result;\line   LocationType Location;\line   string Text;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 DrawTextType dtArgs;\line dtArgs.Location.X = 0;\line dtArgs.Location.Y = LCD_LINE1;\line dtArgs.Text = "Please Work";\line dtArgs.Options = 0x01; // clear before drawing\line SysDrawText(dtArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysDrawPoint(DrawPointType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a pixel on the NXT LCD given the parameters you pass in via the DrawPointType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct DrawPointType \{\line   char Result;\line   LocationType Location;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 DrawPointType dpArgs;\line dpArgs.Location.X = 20;\line dpArgs.Location.Y = 20;\line dpArgs.Options = 0x04; // clear this pixel\line SysDrawPoint(dpArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysDrawLine(DrawLineType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a line on the NXT LCD given the parameters you pass in via the DrawLineType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct DrawLineType \{\line   char Result;\line   LocationType StartLoc;\line   LocationType EndLoc;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 DrawLineType dlArgs;\line dlArgs.StartLoc.X = 20;\line dlArgs.StartLoc.Y = 20;\line dlArgs.EndLoc.X = 60;\line dlArgs.EndLoc.Y = 60;\line dlArgs.Options = 0x01; // clear before drawing\line SysDrawLine(dlArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysDrawCircle(DrawCircleType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a circle on the NXT LCD given the parameters you pass in via the DrawCircleType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct DrawCircleType \{\line   char Result;\line   LocationType Center;\line   byte Size;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 DrawCircleType dcArgs;\line dcArgs.Center.X = 20;\line dcArgs.Center.Y = 20;\line dcArgs.Size = 10; // radius\line dcArgs.Options = 0x01; // clear before drawing\line SysDrawCircle(dcArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysDrawRect(DrawRectType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a rectangle on the NXT LCD given the parameters you pass in via the DrawRectType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct DrawRectType \{\line   char Result;\line   LocationType Location;\line   SizeType Size;\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 DrawRectType drArgs;\line drArgs.Location.X = 20;\line drArgs.Location.Y = 20;\line drArgs.Size.Width = 20;\line drArgs.Size.Height = 10;\line drArgs.Options = 0x00; // do not clear before drawing\line SysDrawRect(drArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysDrawGraphic(DrawGraphicType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you draw a graphic image (RIC file) on the NXT LCD given the parameters you pass in via the DrawGraphicType structure.  The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct DrawGraphicType \{\line   char Result;\line   LocationType Location;\line   string Filename;\line   int Variables[];\line   unsigned long Options;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 DrawGraphicType dgArgs;\line dgArgs.Location.X = 20;\line dgArgs.Location.Y = 20;\line dgArgs.Filename = "image.ric";\line ArrayInit(dgArgs.Variables, 0, 10); // 10 zeros\line dgArgs.Variables[0] = 12;\line dgArgs.Variables[1] = 14; // etc...\line dgArgs.Options = 0x00; // do not clear before drawing\line SysDrawGraphic(dgArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysSetScreenMode(SetScreenModeType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you set the screen mode of the NXT LCD given the parameters you pass in via the SetScreenModeType structure. The standard NXT firmware only supports setting the ScreenMode to \f2\fs22 SCREEN_MODE_RESTORE\f0\fs20 , which has a value of 0x00. If you install the NBC/NXC enhanced standard NXT firmware this system function also supports setting the ScreenMode to \f2\fs22 SCREEN_MODE_CLEAR\f0\fs20 , which has a value of 0x01. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct SetScreenModeType \{\line   char Result;\line   unsigned long ScreenMode;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SetScreenModeType ssmArgs;\line ssmArgs.ScreenMode = 0x00; // restore default NXT screen\line SysSetScreenMode(ssmArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysSoundPlayFile(SoundPlayFileType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you play a sound file given the parameters you pass in via the SoundPlayFileType structure. The sound file can either be an RSO file containing PCM or compressed ADPCM samples or it can be an NXT melody (RMD) file containing frequency and duration values. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct SoundPlayFileType \{\line   char Result;\line   string Filename;\line   bool Loop;\line   byte SoundLevel;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SoundPlayFileType spfArgs;\line spfArgs.Filename = "hello.rso";\line spfArgs.Loop = false;\line spfArgs.SoundLevel = 3; \line SysSoundPlayFile(spfArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysSoundPlayTone(SoundPlayToneType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you play a tone given the parameters you pass in via the SoundPlayToneType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct SoundPlayToneType \{\line   char Result;\line   unsigned int Frequency;\line   unsigned int Duration;\line   bool Loop;\line   byte SoundLevel;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SoundPlayToneType sptArgs;\line sptArgs.Frequency = 440;\line sptArgs.Duration = 1000; // 1 second\line sptArgs.Loop = false;\line sptArgs.SoundLevel = 3; \line SysSoundPlayTone(sptArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysSoundGetState(SoundGetStateType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you retrieve information about the sound module state via the SoundGetStateType structure. Constants for sound state are \f2\fs22 SOUND_STATE_IDLE\f0\fs20 , \f2\fs22 SOUND_STATE_FILE\f0\fs20 , \f2\fs22 SOUND_STATE_TONE\f0\fs20 , and \f2\fs22 SOUND_STATE_STOP\f0\fs20 . Constants for sound flags are \f2\fs22 SOUND_FLAGS_IDLE\f0\fs20 , \f2\fs22 SOUND_FLAGS_UPDATE\f0\fs20 , and \f2\fs22 SOUND_FLAGS_RUNNING\f0\fs20 . The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct SoundGetStateType \{\line   byte State;\line   byte Flags;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SoundGetStateType sgsArgs;\line SysSoundGetState(sgsArgs);\line if (sgsArgs.State == SOUND_STATE_IDLE) \{/* do stuff */\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysSoundSetState(SoundSetStateType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you set sound module state settings via the SoundSetStateType structure. Constants for sound state are \f2\fs22 SOUND_STATE_IDLE\f0\fs20 , \f2\fs22 SOUND_STATE_FILE\f0\fs20 , \f2\fs22 SOUND_STATE_TONE\f0\fs20 , and \f2\fs22 SOUND_STATE_STOP\f0\fs20 . Constants for sound flags are \f2\fs22 SOUND_FLAGS_IDLE\f0\fs20 , \f2\fs22 SOUND_FLAGS_UPDATE\f0\fs20 , and \f2\fs22 SOUND_FLAGS_RUNNING\f0\fs20 . The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct SoundSetStateType \{\line   byte Result;\line   byte State;\line   byte Flags;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SoundSetStateType sssArgs;\line sssArgs.State = SOUND_STATE_STOP;\line SysSoundSetState(sssArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysReadButton(ReadButtonType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read button state information via the ReadButtonType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct ReadButtonType \{\line   char Result;\line   byte Index;\line   bool Pressed;\line   byte Count;\line   bool Reset; // reset count after reading?\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 ReadButtonType rbArgs;\line rbArgs.Index = BTNRIGHT;\line SysReadButton(rbArgs);\line if (rbArgs.Pressed) \{/* do something */\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysRandomNumber(RandomNumberType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you obtain a random number via the RandomNumberType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct RandomNumberType \{\line   int Result;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 RandomNumberType rnArgs;\line SysRandomNumber(rnArgs);\line int myRandomValue = rnArgs.Result;\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysGetStartTick(GetStartTickType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you obtain the tick value at the time your program began executing via the GetStartTickType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct GetStartTickType \{\line   unsigned long Result;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 GetStartTickType gstArgs;\line SysGetStartTick(gstArgs);\line unsigned long myStart = gstArgs.Result;\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysKeepAlive(KeepAliveType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you reset the sleep timer via the KeepAliveType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct KeepAliveType \{\line   unsigned long Result;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 KeepAliveType kaArgs;\line SysKeepAlive(kaArgs); // reset sleep timer\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileOpenWrite(FileOpenType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you create a file that you can write to using the values specified via the FileOpenType structure. The structure type declaration is shown below. Use the FileHandle return value for subsequent file write operations. The desired maximum file capacity in bytes is specified via the Length member.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileOpenType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Filename;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileOpenType foArgs;\line foArgs.Filename = "myfile.txt";\line foArgs.Length = 256; // create with capacity for 256 bytes\line SysFileOpenWrite(foArgs); // create the file\line if (foArgs.Result == NO_ERR) \{\line   // write to the file using FileHandle\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileOpenAppend(FileOpenType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you open an existing file that you can write to using the values specified via the FileOpenType structure. The structure type declaration is shown below. Use the FileHandle return value for subsequent file write operations.  The available length remaining in the file is returned via the Length member.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileOpenType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Filename;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileOpenType foArgs;\line foArgs.Filename = "myfile.txt";\line SysFileOpenAppend(foArgs); // open the file\line if (foArgs.Result == NO_ERR) \{\line   // write to the file using FileHandle\line   // up to the remaining available length in Length\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileOpenRead(FileOpenType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you open an existing file for reading using the values specified via the FileOpenType structure. The structure type declaration is shown below. Use the FileHandle return value for subsequent file read operations.  The number of bytes that can be read from the file is returned via the Length member.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileOpenType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Filename;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileOpenType foArgs;\line foArgs.Filename = "myfile.txt";\line SysFileOpenRead(foArgs); // open the file for reading\line if (foArgs.Result == NO_ERR) \{\line   // read data from the file using FileHandle\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileRead(FileReadWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read from a file using the values specified via the FileReadWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileReadWriteType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Buffer;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileReadWriteType frArgs;\line frArgs.FileHandle = foArgs.FileHandle;\line frArgs.Length = 12; // number of bytes to read\line SysFileRead(frArgs); \line if (frArgs.Result == NO_ERR) \{\line   TextOut(0, LCD_LINE1, frArgs.Buffer);\line   // show how many bytes were actually read\line   NumOut(0, LCD_LINE2, frArgs.Length);\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileWrite(FileReadWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write to a file using the values specified via the FileReadWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileReadWriteType \{\line   unsigned int Result;\line   byte FileHandle;\line   string Buffer;\line   unsigned long Length;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileReadWriteType fwArgs;\line fwArgs.FileHandle = foArgs.FileHandle;\line fwArgs.Buffer = "data to write";\line SysFileWrite(fwArgs); \line if (fwArgs.Result == NO_ERR) \{\line   // display number of bytes written\line   NumOut(0, LCD_LINE1, fwArgs.Length);\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileClose(FileCloseType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you close a file using the values specified via the FileCloseType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileCloseType \{\line   unsigned int Result;\line   byte FileHandle;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileCloseType fcArgs;\line fcArgs.FileHandle = foArgs.FileHandle;\line SysFileClose(fcArgs);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileResolveHandle(FileResolveHandleType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you resolve the handle of a file using the values specified via the FileResolveHandleType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileResolveHandleType \{\line   unsigned int Result;\line   byte FileHandle;\line   bool WriteHandle;\line   string Filename;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileResolveHandleType frhArgs;\line frhArgs.Filename = "myfile.txt";\line SysFileResolveHandle(frhArgs);\line if (frhArgs.Result == LDR_SUCCESS) \{\line   // use the FileHandle as needed\line   if (frhArgs.WriteHandle) \{\line     // file is open for writing\line   \}\line   else \{\line     // file is open for reading\line   \}\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileRename(FileRenameType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you rename a file using the values specified via the FileRenameType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileRenameType \{\line   unsigned int Result;\line   string OldFilename;\line   string NewFilename;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileRenameType frArgs;\line frArgs.OldFilename = "myfile.txt";\line frArgs.NewFilename = "myfile2.txt";\line SysFileRename(frArgs);\line if (frArgs.Result == LDR_SUCCESS) \{ /* do something */ \}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysFileDelete(FileDeleteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you delete a file using the values specified via the FileDeleteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct FileDeleteType \{\line   unsigned int Result;\line   string Filename;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 FileDeleteType fdArgs;\line fdArgs.Filename = "myfile.txt";\line SysFileDelete(fdArgs); // delete the file\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysCommLSWrite(CommLSWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write to an I2C (Lowspeed) sensor using the values specified via the CommLSWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct CommLSWriteType \{\line   char Result;\line   byte Port;\line   byte Buffer[];\line   byte ReturnLen;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 CommLSWriteType args;\line args.Port = S1;\line args.Buffer = myBuf;\line args.ReturnLen = 8;\line SysCommLSWrite(args);\line // check Result for error status\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysCommLSCheckStatus(CommLSCheckStatusType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you check the status of an I2C (Lowspeed) sensor transaction using the values specified via the CommLSCheckStatusType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct CommLSCheckStatusType \{\line   char Result;\line   byte Port;\line   byte BytesReady;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 CommLSCheckStatusType args;\line args.Port = S1;\line SysCommLSCheckStatus(args);\line // is the status (Result) IDLE?\line if (args.Result == LOWSPEED_IDLE) \{ /* proceed */ \}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysCommLSRead(CommLSReadType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read from an I2C (Lowspeed) sensor using the values specified via the CommLSReadType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct CommLSReadType \{\line   char Result;\line   byte Port;\line   byte Buffer[];\line   byte BufferLen;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 CommLSReadType args;\line args.Port = S1;\line args.Buffer = myBuf;\line args.BufferLen = 8;\line SysCommLSRead(args);\line // check Result for error status & use Buffer contents\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysMessageWrite(MessageWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write a message to a queue (aka mailbox) using the values specified via the MessageWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct MessageWriteType \{\line   char Result;\line   byte QueueID;\line   string Message;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 MessageWriteType args;\line args.QueueID = MAILBOX1; // 0\line args.Message = "testing";\line SysMessageWrite(args);\line // check Result for error status\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysMessageRead(MessageReadType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read a message from a queue (aka mailbox) using the values specified via the MessageReadType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct MessageReadType \{\line   char Result;\line   byte QueueID;\line   bool Remove;\line   string Message;\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 MessageReadType args;\line args.QueueID = MAILBOX1; // 0\line args.Remove = true;\line SysMessageRead(args);\line if (args.Result == NO_ERR) \{\line   TextOut(0, LCD_LINE1, args.Message);\line\}\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysCommBTWrite(CommBTWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write to a Bluetooth connection using the values specified via the CommBTWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct CommBTWriteType \{\line   char Result;\line   byte Connection;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 CommBTWriteType args;\line args.Connection = 1;\line args.Buffer = myData;\line SysCommBTWrite(args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysCommBTCheckStatus(CommBTCheckStatusType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you check the status of a Bluetooth connection using the values specified via the CommBTCheckStatusType structure. The structure type declaration is shown below.  Possible values for Result include \f2\fs22 ERR_INVALID_PORT\f0\fs20 , \f2\fs22 STAT_COMM_PENDING\f0\fs20 , \f2\fs22 ERR_COMM_CHAN_NOT_READY\f0\fs20 , and \f2\fs22 LDR_SUCCESS\f0\fs20  (0).\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct CommBTCheckStatusType \{\line   char Result;\line   byte Connection;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 CommBTCheckStatusType args;\line args.Connection = 1;\line SysCommBTCheckStatus(args);\line if (args.Result == LDR_SUCCESS) \{ /* do something */ \} \par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysIOMapRead(IOMapReadType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you read data from a firmware module's IOMap using the values specified via the IOMapReadType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct IOMapReadType \{\line   char Result;\line   string ModuleName;\line   unsigned int Offset;\line   unsigned int Count;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 IOMapReadType args;\line args.ModuleName = CommandModuleName;\line args.Offset = CommandOffsetTick;\line args.Count = 4; // this value happens to be 4 bytes long\line SysIOMapRead(args);\line if (args.Result == NO_ERR) \{ /* do something with data */ \} \par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysIOMapWrite(IOMapWriteType & args)\tab Function\par
\pard\sb120\b0\fs20 This function lets you write data to a firmware module's IOMap using the values specified via the IOMapWriteType structure. The structure type declaration is shown below.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct IOMapWriteType \{\line   char Result;\line   string ModuleName;\line   unsigned int Offset;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 IOMapWriteType args;\line args.ModuleName = SoundModuleName;\line args.Offset = SoundOffsetSampleRate;\line args.Buffer = theData;\line SysIOMapWrite(args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysIOMapReadByID(IOMapReadByIDType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you read data from a firmware module's IOMap using the values specified via the IOMapReadByIDType structure. The structure type declaration is shown below. This function can be as much as three times faster than using SysIOMapRead since it does not have to do a string lookup using the ModuleName.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct IOMapReadByIDType \{\line   char Result;\line   unsigned long ModuleID;\line   unsigned int Offset;\line   unsigned int Count;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 IOMapReadByIDType args;\line args.ModuleID = CommandModuleID;\line args.Offset = CommandOffsetTick;\line args.Count = 4; // this value happens to be 4 bytes long\line SysIOMapReadByID(args);\line if (args.Result == NO_ERR) \{ /* do something with data */ \} \par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysIOMapWriteByID(IOMapWriteByIDType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you write data to a firmware module's IOMap using the values specified via the IOMapWriteByIDType structure. The structure type declaration is shown below. This function can be as much as three times faster than using SysIOMapWrite since it does not have to do a string lookup using the ModuleName.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct IOMapWriteByIDType \{\line   char Result;\line   unsigned long ModuleID;\line   unsigned int Offset;\line   byte Buffer[];\line\};\par
\pard\sb120\expndtw0\f0\fs20 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 IOMapWriteByIDType args;\line args.ModuleID = SoundModuleID;\line args.Offset = SoundOffsetSampleRate;\line args.Buffer = theData;\line SysIOMapWriteByID(args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysDisplayExecuteFunction(DisplayExecuteFunctionType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you directly execute the Display module's primary drawing function using the values specified via the DisplayExecuteFunctionType structure. The structure type declaration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct DisplayExecuteFunctionType \{\line   byte Status;\line   byte Cmd;\line   bool On;\line   byte X1;\line   byte Y1;\line   byte X2;\line   byte Y2;\line\};\par
\pard\sb120\tx3060\tx5760\expndtw0\b\f0\fs20 Cmd\tab Meaning\tab Expected parameters\par
\pard\tx3060\tx5760\b0 DISPLAY_ERASE_ALL\tab erase entire screen\tab ()\par
DISPLAY_PIXEL\tab set pixel (on/off)\tab (true/false,X1,Y1,x,x)\par
DISPLAY_HORIZONTAL_LINE\tab draw horizontal line\tab (true/false,X1,Y1,X2,x)\par
DISPLAY_VERTICAL_LINE\tab draw vertical line\tab (true/false,X1,Y1,x,Y2)\par
DISPLAY_CHAR\tab draw char (actual font)\tab (true/false,X1,Y1,Char,x)\par
DISPLAY_ERASE_LINE\tab erase a single line\tab (x,LINE,x,x,x)\par
DISPLAY_FILL_REGION\tab fill screen region\tab (true/false,X1,Y1,X2,Y2)\par
DISPLAY_FILLED_FRAME\tab draw a frame (on / off)\tab (true/false,X1,Y1,X2,Y2)\par
\pard\sb120 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 DisplayExecuteFunctionType args;\line args.Cmd = DISPLAY_ERASE_ALL;\line SysDisplayExecuteFunction(args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysCommExecuteFunction(CommExecuteFunctionType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you directly execute the Comm module's primary function using the values specified via the CommExecuteFunctionType structure. The structure type declaration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct CommExecuteFunctionType \{\line   unsigned int Result;\line   byte Cmd;\line   byte Param1;\line   byte Param2;\line   byte Param3;\line   string Name;\line   unsigned int RetVal;\line\};\par
\pard\sb120\tx2520\tx5940\expndtw0\b\f0\fs20 Cmd\tab Meaning\tab (Param1,Param2,Param3,Name)\par
\pard\tx2520\tx5940\b0 INTF_SENDFILE\tab Send a file over a Bluetooth connection\tab (Connection,x,x,Filename)\par
INTF_SEARCH\tab Search for Bluetooth devices\tab (x,x,x,x)\par
INTF_STOPSEARCH\tab Stop searching for Bluetooth devices\tab (x,x,x,x)\par
INTF_CONNECT\tab Connect to a Bluetooth device\tab (DeviceIndex,Connection,x,x)\par
INTF_DISCONNECT\tab Disconnect a Bluetooth device\tab (Connection,x,x,x)\par
INTF_DISCONNECTALL\tab Disconnect all Bluetooth devices\tab (x,x,x,x)\par
INTF_REMOVEDEVICE\tab Remove device from My Contacts\tab (DeviceIndex,x,x,x)\par
INTF_VISIBILITY\tab Set Bluetooth visibility\tab (true/false,x,x,x)\par
INTF_SETCMDMODE\tab Set command mode\tab (x,x,x,x)\par
INTF_OPENSTREAM\tab Open a stream\tab (x,Connection,x,x)\par
INTF_SENDDATA\tab Send data\tab (Length, Connection, WaitForIt, Buffer)\par
INTF_FACTORYRESET\tab Bluetooth factory reset\tab (x,x,x,x)\par
INTF_BTON\tab Turn Bluetooth on\tab (x,x,x,x)\par
INTF_BTOFF\tab Turn Bluetooth off\tab (x,x,x,x)\par
INTF_SETBTNAME\tab Set Bluetooth name\tab (x,x,x,x)\par
INTF_EXTREAD\tab Handle external? read\tab (x,x,x,x)\par
INTF_PINREQ\tab Handle Blueooth PIN request\tab (x,x,x,x)\par
INTF_CONNECTREQ\tab Handle Bluetooth connect request\tab (x,x,x,x)\par
\pard\sb120 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 CommExecuteFunctionType args;\line args.Cmd = INTF_BTOFF;\line SysCommExecuteFunction(args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysLoaderExecuteFunction(LoaderExecuteFunctionType & args)\tab Function (+)\par
\pard\sb120\b0\fs20 This function lets you directly execute the Loader module's primary function using the values specified via the LoaderExecuteFunctionType structure. The structure type declaration is shown below.  The values for these fields are documented in the table below.  If a field member is shown as 'x' it is ignored by the specified display command.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 struct LoaderExecuteFunctionType \{\line   unsigned int Result;\line   byte Cmd;\line   string Filename;\line   byte Buffer[];\line   unsigned long Length;\line\};\par
\pard\sb120\tx3358\tx6228\expndtw0\b\f0\fs20 Cmd\tab Meaning\tab Expected Parameters\par
\pard\tx3358\tx6228\b0 LDR_CMD_OPENREAD\tab Open a file for reading\tab (Filename, Length)\par
LDR_CMD_OPENWRITE\tab Creat a file\tab (Filename, Length)\par
LDR_CMD_READ\tab Read from a file\tab (Filename, Buffer, Length)\par
LDR_CMD_WRITE\tab Write to a file\tab (Filename, Buffer, Length)\par
LDR_CMD_CLOSE\tab Close a file\tab (Filename)\par
\lang1040 LDR_CMD_DELETE\tab Delete a file\tab (Filename)\par
\lang1033 LDR_CMD_FINDFIRST\tab Start iterating files\tab (Filename, Buffer, Length)\par
LDR_CMD_FINDNEXT\tab Continue iterating files\tab (Filename, Buffer, Length)\par
LDR_CMD_OPENWRITELINEAR\tab Create a linear file\tab (Filename, Length)\par
LDR_CMD_OPENREADLINEAR\tab Read a linear file\tab (Filename, Buffer, Length)\par
LDR_CMD_OPENAPPENDDATA\tab Open a file for writing\tab (Filename, Length)\par
LDR_CMD_FINDFIRSTMODULE\tab Start iterating modules\tab (Filename, Buffer)\par
LDR_CMD_FINDNEXTMODULE\tab Continue iterating modules\tab (Buffer)\par
LDR_CMD_CLOSEMODHANDLE\tab Close module handle\tab ()\par
LDR_CMD_IOMAPREAD\tab Read IOMap data\tab (Filename, Buffer, Length)\par
LDR_CMD_IOMAPWRITE\tab Write IOMap data\tab (Filename, Buffer, Length)\par
LDR_CMD_DELETEUSERFLASH\tab Delete all files\tab ()\par
LDR_CMD_RENAMEFILE\tab Rename file\tab (Filename, Buffer, Length)\par
\pard\sb120 Declare a variable of this type, set its members, and then call the function, passing in your variable of this structure type.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 LoaderExecuteFunctionType args;\line args.Cmd = 0xA0; // delete user flash\line SysLoaderExecuteFunction(args);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SysCall(funcID, args)\tab Function\par
\pard\sb120\b0\fs20 This generic macro can be used to call any system function. No type checking is performed so you need to make sure you use the correct structure type given the selected system function ID. This is, however, the fastest possible way to call a system function in NXC. Function ID constants that can be used with this API call are: FileOpenRead, FileOpenWrite, FileOpenAppend, FileRead, FileWrite, FileClose, FileResolveHandle, FileRename, FileDelete, SoundPlayFile, SoundPlayTone, SoundGetState, SoundSetState, DrawText, DrawPoint, DrawLine, DrawCircle, DrawRect, DrawGraphic, SetScreenMode, ReadButton, CommLSWrite, CommLSRead, CommLSCheckStatus, RandomNumber, GetStartTick, MessageWrite, MessageRead, CommBTCheckStatus, CommBTWrite, KeepAlive, IOMapRead, IOMapWrite, IOMapReadByID, IOMapWriteByID, DisplayExecuteFunction, CommExecuteFunction, and LoaderExecuteFunction.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 DrawTextType dtArgs;\line dtArgs.Location.X = 0;\line dtArgs.Location.Y = LCD_LINE1;\line dtArgs.Text = "Please Work";\line SysCall(DrawText, dtArgs);\par
\pard\keepn\s2\sb240\sa60\expndtw0\b\i\f0\fs24\page\super #$K+\nosupersub 3.2 Input Module\par
\pard\b0\i0\fs20 The NXT input module encompasses all sensor inputs except for digital I2C (LowSpeed) sensors. \par
\pard\li360\sb120\b Module Constants\tab Value\par
\pard\li360\b0 InputModuleName\tab "Input.mod"\par
InputModuleID\tab 0x00030001\par
\pard\sb120 There are four sensors, which are internally numbered 0, 1, 2, and 3. This is potentially confusing since they are externally labeled on the NXT as sensors 1, 2, 3, and 4. To help mitigate this confusion, the sensor port names S1, S2, S3, and S4 have been defined. These sensor names may be used in any function that requires a sensor port as an argument. Alternatively, the NBC port name constants IN_1, IN_2, IN_3, and IN_4 may also be used when a sensor port is required.\par
Sensor value names SENSOR_1, SENSOR_2, SENSOR_3, and SENSOR_4 have also been defined. These names may also be used whenever a program wishes to read the current value of the sensor:\par
\pard\li720\sb120\f1 x = SENSOR_1; // read sensor and store value in x\par
\pard\keepn\s3\sb240\sa60\tqr\tx8640\f0\fs24\page\super #$K+\nosupersub 3.1.1 Types and Modes\par
\pard\sb120\fs20 The sensor ports on the NXT are capable of interfacing to a variety of different sensors. It is up to the program to tell the NXT what kind of sensor is attached to each port. Calling SetSensorType configures a sensor's type. There are 12 sensor types, each corresponding to a specific LEGO RCX or NXT sensor. A thirteenth type (SENSOR_TYPE_NONE) is used to indicate that no sensor has been configured. \par
In general, a program should configure the type to match the actual sensor. If a sensor port is configured as the wrong type, the NXT may not be able to read it accurately. Use either the Sensor Type constants or the NBC Sensor Type constants.\par
\pard\li360\sb120\tx3600\tx6300\b Sensor Type\tab NBC Sensor Type\tab Meaning\par
\pard\li360\tx3600\tx6300\b0 SENSOR_TYPE_NONE\tab IN_TYPE_NO_SENSOR\tab no sensor configured\par
SENSOR_TYPE_TOUCH\tab IN_TYPE_SWITCH\tab NXT or RCX touch sensor\par
SENSOR_TYPE_TEMPERATURE\tab IN_TYPE_TEMPERATURE\tab RCX temperature sensor\par
SENSOR_TYPE_LIGHT\tab IN_TYPE_REFLECTION\tab RCX light sensor\par
SENSOR_TYPE_ROTATION\tab IN_TYPE_ANGLE\tab RCX rotation sensor\par
SENSOR_TYPE_LIGHT_ACTIVE\tab IN_TYPE_LIGHT_ACTIVE\tab NXT light sensor with light\par
SENSOR_TYPE_LIGHT_INACTIVE\tab IN_TYPE_LIGHT_INACTIVE\tab NXT light sensor without light\par
SENSOR_TYPE_SOUND_DB\tab IN_TYPE_SOUND_DB\tab NXT sound sensor with dB scaling\par
SENSOR_TYPE_SOUND_DBA\tab IN_TYPE_SOUND_DBA\tab NXT sound sensor with dBA scaling\par
SENSOR_TYPE_CUSTOM\tab IN_TYPE_CUSTOM\tab Custom sensor (unused)\par
SENSOR_TYPE_LOWSPEED\tab IN_TYPE_LOWSPEED\tab I2C digital sensor\par
SENSOR_TYPE_LOWSPEED_9V\tab IN_TYPE_LOWSPEED_9V\tab I2C digital sensor (9V power)\par
SENSOR_TYPE_HIGHSPEED\tab IN_TYPE_HISPEED\tab Highspeed sensor (unused)\par
\pard\sb120 The NXT allows a sensor to be configured in different modes. The sensor mode determines how a sensor's raw value is processed. Some modes only make sense for certain types of sensors, for example SENSOR_MODE_ROTATION is useful only with rotation sensors. Call SetSensorMode to set the sensor mode. The possible modes are shown below. Use either the Sensor Mode constant or the NBC Sensor Mode constant.\par
\pard\li360\sb120\tx3420\tx6300\b Sensor Mode\tab NBC Sensor Mode\tab Meaning\par
\pard\li360\tx3420\tx6300\b0 SENSOR_MODE_RAW\tab IN_MODE_RAW\tab raw value from 0 to 1023\par
SENSOR_MODE_BOOL\tab IN_MODE_BOOLEAN\tab boolean value (0 or 1)\par
SENSOR_MODE_EDGE\tab IN_MODE_TRANSITIONCNT\tab counts number of boolean transitions\par
SENSOR_MODE_PULSE\tab IN_MODE_PERIODCOUNTER\tab counts number of boolean periods\par
SENSOR_MODE_PERCENT\tab IN_MODE_PCTFULLSCALE\tab value from 0 to 100\par
\lang1031 SENSOR_MODE_FAHRENHEIT\tab IN_MODE_FAHRENHEIT\tab degrees F\par
\lang1036 SENSOR_MODE_CELSIUS\tab IN_MODE_CELSIUS\tab degrees C\par
\lang1033 SENSOR_MODE_ROTATION\tab IN_MODE_ANGLESTEP\tab rotation (16 ticks per revolution) \par
\pard\sb120 When using the NXT, it is common to set both the type and mode at the same time. The SetSensor function makes this process a little easier by providing a single function to call and a set of standard type/mode combinations.\par
\pard\li720\sb120\tx3060\tx6120\b Sensor Configuration\tab Type\tab Mode\par
\pard\li720\tx3060\tx6120\b0 SENSOR_TOUCH\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_BOOL\par
SENSOR_LIGHT\tab SENSOR_TYPE_LIGHT\tab SENSOR_MODE_PERCENT\par
SENSOR_ROTATION\tab SENSOR_TYPE_ROTATION\tab SENSOR_MODE_ROTATION\par
\lang1036 SENSOR_CELSIUS\tab SENSOR_TYPE_TEMPERATURE\tab SENSOR_MODE_CELSIUS\par
\lang1031 SENSOR_FAHRENHEIT\tab SENSOR_TYPE_TEMPERATURE\tab SENSOR_MODE_FAHRENHEIT\par
\lang1033 SENSOR_PULSE\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_PULSE\par
SENSOR_EDGE\tab SENSOR_TYPE_TOUCH\tab SENSOR_MODE_EDGE\par
\pard\sb120\tqr\tx8640 The NXT provides a boolean conversion for all sensors - not just touch sensors. This boolean conversion is normally based on preset thresholds for the raw value. A "low" value (less than 460) is a boolean value of 1. A high value (greater than 562) is a boolean value of 0. This conversion can be modified: a slope value between 0 and 31 may be added to a sensor's mode when calling SetSensorMode. If the sensor's value changes more than the slope value during a certain time (3ms), then the sensor's boolean state will change. This allows the boolean state to reflect rapid changes in the raw value. A rapid increase will result in a boolean value of 0, a rapid decrease is a boolean value of 1.\par
Even when a sensor is configured for some other mode (i.e. SENSOR_MODE_PERCENT), the boolean conversion will still be carried out.\par
Each sensor has six fields that are used to define its state. The field constants are described in the following table. \par
\pard\li360\sb120\tx2880\b Sensor Field Constant\tab Meaning\par
\pard\li360\tx2880\b0 Type\tab The sensor type\par
InputMode\tab The sensor mode\par
RawValue\tab The raw sensor value\par
NormalizedValue\tab The normalized sensor value\par
ScaledValue\tab The scaled sensor value\par
InvalidData\tab Invalidates the current sensor value\par
\pard\sb120\tqr\tx8640\b\fs24 SetSensor(sensor, const configuration)\tab Function\par
\b0\fs20 Set the type and mode of the given sensor to the specified configuration, which must be a special constant containing \par
\pard\tqr\tx8640 both type and mode information. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSensor(S1, SENSOR_TOUCH);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSensorType(port, const type)\tab Function\par
\b0\fs20 Set a sensor's type, which must be one of the predefined sensor type constants. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSensorType(S1, SENSOR_TYPE_TOUCH);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSensorMode(port, const mode)\tab Function\par
\b0\fs20 Set a sensor's mode, which should be one of the predefined sensor mode constants. A slope parameter for boolean conversion, if desired, may be added to the mode. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\li720\sb120\tqr\tx8640\lang1036\f1 SetSensorMode(S1, SENSOR_MODE_RAW); // raw mode\par
\pard\li720\tqr\tx8640\lang1033 SetSensorMode(S1, SENSOR_MODE_RAW + 10) ; // slope 10\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSensorLight(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as a light sensor (active). The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SetSensorLight(S1);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SetSensorSound(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as a sound sensor (dB scaling). The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SetSensorSound(S1);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SetSensorTouch(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as a touch sensor. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SetSensorTouch(S1);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SetSensorLowspeed(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as an I2C digital sensor (9V powered). The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SetSensorLowspeed(S1);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SetInput(port, const field, value)\tab Function\par
\b0\fs20 Set the specified field of the sensor on the specified port to the value provided. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. The field must be a sensor field constant. Valid field constants are listed above. The value may be any valid expression.\par
\pard\hyphpar0\li720\ri720\sb120\expndtw-10\f2\fs22 SetInput(S1, Type, IN_TYPE_SOUND_DB);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 ClearSensor(port)\tab Function\par
\b0\fs20 Clear the value of a sensor - only affects sensors that are configured to measure a cumulative quantity such as rotation or a pulse count. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\f1 ClearSensor(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ResetSensor(port)\tab Function\par
\b0\fs20 Reset the value of a sensor. If the sensor type or mode has been modified then the sensor should be reset in order to ensure that values read from the sensor are valid. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 ResetSensor(x); // x = S1\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetCustomSensorZeroOffset(const port, value)\tab Function\par
\b0\fs20 Sets the custom sensor zero offset value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetCustomSensorZeroOffset(S1, 12);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetCustomSensorPercentFullScale(const port, value)\tab Function\par
\b0\fs20 Sets the custom sensor percent full scale value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetCustomSensorPercentFullScale(S1, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetCustomSensorActiveStatus(const port, value)\tab Function\par
\b0\fs20 Sets the custom sensor active status value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetCustomSensorActiveStatus(S1, true);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSensorDigiPinsDirection(const port, value)\tab Function\par
\b0\fs20 Sets the digital pins direction value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4). A value of 1 sets the direction to output. A value of 0 sets the direction to input.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSensorDigiPinsDirection(S1, 1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSensorDigiPinsStatus(const port, value)\tab Function\par
\b0\fs20 Sets the digital pins status value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetSensorDigiPinsStatus(S1, false);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSensorDigiPinsOutputLevel(const port, value)\tab Function\par
\b0\fs20 Sets the digital pins output level value of a sensor. The port must be specified using a constant (e.g., S1, S2, S3, or S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetSensorDigiPinsOutputLevel(S1, 100);\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 3.1.2 Sensor Information\par
\pard\sb120\tqr\tx8640\fs20 There are a number of values that can be inspected for each sensor. For all of these values the sensor must be specified by a constant port value (e.g., S1, S2, S3, or S4) unless otherwise specified.\par
\b\fs24 Sensor(n)\tab Value\par
\b0\fs20 Return the processed sensor reading for a sensor on port n, where n is 0, 1, 2, or 3 (or a sensor port name constant). This is the same value that is returned by the sensor value names (e.g. SENSOR_1). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = Sensor(S1); // read sensor 1\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorValue(n)\tab Value\par
\b0\fs20 Return the processed sensor reading for a sensor on port n, where n is 0, 1, 2, or 3 (or a sensor port name constant). This is the same value that is returned by the sensor value names (e.g. SENSOR_1). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorValue(S1); // read sensor 1\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorUS(n)\tab Value\par
\b0\fs20 Return the processed sensor reading for an ultrasonic sensor on port n, where n is 0, 1, 2, or 3 (or a sensor port name constant). Since an ultrasonic sensor is an I2C digital sensor its value cannot be read using the standard Sensor(n) value. A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorUS(S4); // read sensor 4\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorType(n)\tab Value\par
\b0\fs20 Return the configured type of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorType(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorMode(n)\tab Value\par
\b0\fs20 Return the current sensor mode for a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorMode(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorBoolean(n)\tab Value\par
\b0\fs20 Return the boolean value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). Boolean conversion is either done based on preset cutoffs, or a slope parameter specified by calling SetSensorMode.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorBoolean(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorValueBool(n)\tab Value\par
\b0\fs20 Return the boolean value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). Boolean conversion is either done based on preset cutoffs, or a slope parameter specified by calling SetSensorMode.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorValueBool(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorRaw(n) \tab Value\par
\b0\fs20 Return the raw value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorRaw(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorValueRaw(n) \tab Value\par
\b0\fs20 Return the raw value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorValueRaw(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorNormalized(n)\tab Value\par
\b0\fs20 Return the normalized value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorNormalized(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorScaled(n)\tab Value\par
\b0\fs20 Return the scaled value of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used. This is the same as the standard Sensor(n) value.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorScaled(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorInvalid(port)\tab Value\par
\b0\fs20 Return the value of the InvalidData flag of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorInvalid(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetInput(port, const field)\tab Value\par
\pard\b0\fs20 Return the value of the specified field of a sensor on port n, which must be 0, 1, 2, or 3 (or a sensor port name constant). A variable whose value is the desired sensor port may also be used. The field must be a sensor field constant. Valid field constants are listed in Table 11.\par
\pard\li720\sb120\tqr\tx8640\f1 x = GetInput(S1, Type);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CustomSensorZeroOffset(const port)\tab Value\par
\b0\fs20 Return the custom sensor zero offset value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = CustomSensorZeroOffset(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CustomSensorPercentFullScale(const port)\tab Value\par
\b0\fs20 Return the custom sensor percent full scale value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = CustomSensorPercentFullScale(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CustomSensorActiveStatus(const port)\tab Value\par
\b0\fs20 Return the custom sensor active status value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = CustomSensorActiveStatus(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorDigiPinsDirection(const port)\tab Value\par
\b0\fs20 Return the digital pins direction value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorDigiPinsDirection(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorDigiPinsStatus(const port)\tab Value\par
\b0\fs20 Return the digital pins status value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorDigiPinsStatus(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorDigiPinsOutputLevel(const port)\tab Value\par
\b0\fs20 Return the digital pins output level value of a sensor on port p, which must be 0, 1, 2, or 3 (or a sensor port name constant).\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorDigiPinsOutputLevel(S1);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 3.2.3 IOMap Offsets\par
\pard\li720\tx4320\tx6480\i0\fs20 Input Module Offsets\tab Value\tab Size\par
\b0 InputOffsetCustomZeroOffset(p)\tab (((p)*20)+0)\tab 2\par
InputOffsetADRaw(p)\tab (((p)*20)+2)\tab 2\par
InputOffsetSensorRaw(p)\tab (((p)*20)+4)\tab 2\par
InputOffsetSensorValue(p)\tab (((p)*20)+6)\tab 2\par
InputOffsetSensorType(p)\tab (((p)*20)+8)\tab 1\par
InputOffsetSensorMode(p)\tab (((p)*20)+9)\tab 1\par
InputOffsetSensorBoolean(p)\tab (((p)*20)+10)\tab 1\par
InputOffsetDigiPinsDir(p)\tab (((p)*20)+11)\tab 1\par
InputOffsetDigiPinsIn(p)\tab (((p)*20)+12)\tab 1\par
InputOffsetDigiPinsOut(p)\tab (((p)*20)+13)\tab 1\par
InputOffsetCustomPctFullScale(p)\tab (((p)*20)+14)\tab 1\par
InputOffsetCustomActiveStatus(p)\tab (((p)*20)+15)\tab 1\par
InputOffsetInvalidData(p)\tab (((p)*20)+16)\tab 1\par
\pard\keepn\s2\sb240\sa60\b\i\fs24\page\super #$K+\nosupersub 3.2 Output Module\par
\pard\b0\i0\fs20 The NXT output module encompasses all the motor outputs.\par
\pard\li360\sb120\tx2880\b Module Constants\tab Value\par
\pard\li360\tx2880\b0 OutputModuleName\tab "Output.mod"\par
OutputModuleID\tab 0x00020001\par
\pard\sb120 Nearly all of the NXC API functions dealing with outputs take either a single output or a set of outputs as their first argument. Depending on the function call, the output or set of outputs may be a constant or a variable containing an appropriate output port value. The constants OUT_A, OUT_B, and OUT_C are used to identify the three outputs. Unlike NQC, adding individual outputs together does not combine multiple outputs. Instead, the NXC API provides predefined combinations of outputs: OUT_AB, OUT_AC, OUT_BC, and OUT_ABC. Manually combining outputs involves creating an array and adding two or more of the three individual output constants to the array.\par
Power levels can range 0 (lowest) to 100 (highest). Negative power levels reverse the direction of rotation (i.e., forward at a power level of -100 actually means reverse at a power level of 100).\par
The outputs each have several fields that define the current state of the output port. These fields are defined in the table below.\par
\pard\fi-5040\li5040\sb120\tx1440\tx2160\tx3600\tx5040\b Field Constant\tab Type\tab Access\tab Range\tab Meaning\par
\pard\fi-5040\li5040\tx1440\tx2160\tx3600\tx5040\b0 UpdateFlags\tab ubyte\tab Read/Write\tab 0, 255\tab Use UF_UPDATE_MODE, UF_UPDATE_SPEED, UF_UPDATE_TACHO_LIMIT, and UF_UPDATE_PID_VALUES along with other fields to commit changes to the state of outputs. Set the appropriate flags after setting one or more of the output fields in order for the changes to actually go into affect.\par
OutputMode\tab ubyte\tab Read/Write\tab 0, 255\tab The OUT_MODE_MOTORON bit must be set in order for power to be applied to the motors. Add OUT_MODE_BRAKE to enable electronic braking. Braking means that the output voltage is not allowed to float between active PWM pulses. It improves the accuracy of motor output but uses more battery power.\par
\tab\tab\tab\tab To use motor regulation include OUT_MODE_REGULATED in the OutputMode value. Use UF_UPDATE_MODE with UpdateFlags to commit changes to this field.\par
Power\tab sbyte\tab Read/ Write\tab -100, 100\tab Specify the power level of the output. The absolute value of Power is a percentage of the full power of the motor. The sign of Power controls the rotation direction. Positive values tell the firmware to turn the motor forward, while negative values turn the motor backward. Use UF_UPDATE_POWER with UpdateFlags to commit changes to this field.\par
ActualSpeed\tab sbyte\tab Read\tab -100, 100\tab Return the percent of full power the firmware is applying to the output. This may vary from the Power value when auto-regulation code in the firmware responds to a load on the output.\par
TachoCount\tab slong\tab Read\tab signed long\tab Return the internal position counter value for the specified output. The internal count is reset automatically when a new goal is set using the TachoLimit and the UF_UPDATE_TACHO_LIMIT flag.\par
\tab\tab\tab\tab Set the UF_UPDATE_RESET_COUNT flag in UpdateFlags to reset TachoCount and cancel any TachoLimit.\par
\tab\tab\tab\tab The sign of TachoCount indicates the motor rotation direction.\par
TachoLimit\tab ulong\tab Read/ Write\tab unsigned long\tab Specify the number of degrees the motor should rotate.\par
\tab\tab\tab\tab Use UF_UPDATE_TACHO_LIMIT with the UpdateFlags field to commit changes to the TachoLimit. \par
\tab\tab\tab\tab The value of this field is a relative distance from the current motor position at the moment when the UF_UPDATE_TACHO_LIMIT flag is processed.\par
RunState\tab ubyte\tab Read/ Write\tab 0..255\tab Use this field to specify the running state of an output. Set the RunState to OUT_RUNSTATE_RUNNING to enable power to any output. Use OUT_RUNSTATE_RAMPUP to enable automatic ramping to a new Power level greater than the current Power level. Use OUT_RUNSTATE_RAMPDOWN to enable automatic ramping to a new Power level less than the current Power level.\par
\tab\tab\tab\tab Both the rampup and rampdown bits must be used in conjunction with appropriate TachoLimit and Power values. In this case the firmware smoothly increases or decreases the actual power to the new Power level over the total number of degrees of rotation specified in TachoLimit.\par
TurnRatio\tab sbyte\tab Read/ Write\tab -100, 100\tab Use this field to specify a proportional turning ratio. This field must be used in conjunction with other field values: OutputMode must include OUT_MODE_MOTORON and OUT_MODE_REGULATED, RegMode must be set to OUT_REGMODE_SYNC, RunState must not be OUT_RUNSTATE_IDLE, and Speed must be non-zero. \par
\tab\tab\tab\tab There are only three valid combinations of left and right motors for use with TurnRatio: OUT_AB, OUT_BC, and OUT_AC. In each of these three options the first motor listed is considered to be the left motor and the second motor is the right motor, regardless of the physical configuration of the robot.\par
\tab\tab\tab\tab Negative TurnRatio values shift power toward the left motor while positive values shift power toward the right motor. An absolute value of 50 usually results in one motor stopping. An absolute value of 100 usually results in two motors turning in opposite directions at equal power.\par
RegMode\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the regulation mode to use with the specified port(s). It is ignored if the OUT_MODE_REGULATED bit is not set in the OutputMode field. Unlike the OutputMode field, RegMode is not a bitfield. Only one RegMode value can be set at a time. \par
\tab\tab\tab\tab Speed regulation means that the firmware tries to maintain a certain speed based on the Power setting. The firmware adjusts the PWM duty cycle if the motor is affected by a physical load. This adjustment is reflected by the value of the ActualSpeed property. When using speed regulation, do not set Power to its maximum value since the firmware cannot adjust to higher power levels in that situation.\par
\tab\tab\tab\tab Synchronization means the firmware tries to keep two motors in synch regardless of physical loads. Use this mode to maintain a straight path for a mobile robot automatically. Also use this mode with the TurnRatio property to provide proportional turning. \par
\tab\tab\tab\tab Set OUT_REGMODE_SYNC on at least two motor ports in order for synchronization to function. Setting OUT_REGMODE_SYNC on all three motor ports will result in only the first two (OUT_A and OUT_B) being synchronized.\par
Overload\tab ubyte\tab Read\tab 0..1\tab This field will have a value of 1 (true) if the firmware speed regulation cannot overcome a physical load on the motor. In other words, the motor is turning more slowly than expected. \par
\tab\tab\tab\tab If the motor speed can be maintained in spite of loading then this field value is zero (false). \par
\tab\tab\tab\tab In order to use this field the motor must have a non-idle RunState, an OutputMode which includes OUT_MODE_MOTORON and OUT_MODE_REGULATED, and its RegMode must be set to OUT_REGMODE_SPEED.\par
RegPValue\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the proportional term used in the internal proportional-integral-derivative (PID) control algorithm.\par
\tab\tab\tab\tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.\par
RegIValue\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the integral term used in the internal proportional-integral-derivative (PID) control algorithm.\par
\tab\tab\tab\tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.\par
RegDValue\tab ubyte\tab Read/ Write\tab 0..255\tab This field specifies the derivative term used in the internal proportional-integral-derivative (PID) control algorithm.\par
\tab\tab\tab\tab Set UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously.\par
BlockTachoCount\tab slong\tab Read\tab full range of signed long\tab Return the block-relative position counter value for the specified port.\par
\tab\tab\tab\tab Refer to the UpdateFlags description for information about how to use block-relative position counts.\par
\tab\tab\tab\tab Set the UF_UPDATE_RESET_BLOCK_COUNT flag in UpdateFlags to request that the firmware reset the BlockTachoCount. \par
\tab\tab\tab\tab The sign of BlockTachoCount indicates the direction of rotation. Positive values indicate forward rotation and negative values indicate reverse rotation. Forward and reverse depend on the orientation of the motor.\par
RotationCount\tab slong\tab Read\tab signed long\tab Return the program-relative position counter value for the specified port.\par
\tab\tab\tab\tab Refer to the UpdateFlags description for information about how to use program-relative position counts.\par
\tab\tab\tab\tab Set the UF_UPDATE_RESET_ROTATION_COUNT flag in UpdateFlags to request that the firmware reset the RotationCount. \par
\tab\tab\tab\tab The sign of RotationCount indicates the direction of rotation. Positive values indicate forward rotation and negative values indicate reverse rotation. Forward and reverse depend on the orientation of the motor.\par
\pard\sb120 Valid UpdateFlags values are described in the following table.\par
\pard\fi-4320\li4320\sb120\tx4320\b UpdateFlags Constants\tab Meaning\par
\pard\fi-4320\li4320\tx4320\b0 UF_UPDATE_MODE\tab Commits changes to the OutputMode output property\par
UF_UPDATE_SPEED\tab Commits changes to the Power output property\par
UF_UPDATE_TACHO_LIMIT\tab Commits changes to the TachoLimit output property\par
UF_UPDATE_RESET_COUNT\tab Resets all rotation counters, cancels the current goal, and resets the rotation error-correction system\par
UF_UPDATE_PID_VALUES\tab Commits changes to the PID motor regulation properties\par
UF_UPDATE_RESET_BLOCK_COUNT\tab Resets the block-relative rotation counter\par
UF_UPDATE_RESET_ROTATION_COUNT\tab Resets the program-relative rotation counter\par
\pard\sb120 Valid OutputMode values are described in the following table.\par
\pard\sb120\tx3240\tx4320\b OutputMode Constants\tab Value\tab Meaning\par
\pard\tx3240\tx4320\b0 OUT_MODE_COAST\tab 0x00\tab No power and no braking so motors rotate freely\par
OUT_MODE_MOTORON\tab 0x01\tab Enables PWM power to the outputs given the Power setting\par
OUT_MODE_BRAKE\tab 0x02\tab Uses electronic braking to outputs\par
OUT_MODE_REGULATED\tab 0x04\tab Enables active power regulation using the RegMode value\par
OUT_MODE_REGMETHOD\tab 0xf0\tab\par
\pard\sb120 Valid RunState values are described in the following table.\par
\pard\fi-4320\li4320\sb120\tx3240\tx4320\b RunState Constants\tab Value\tab Meaning\par
\pard\fi-4320\li4320\tx3240\tx4320\b0 OUT_RUNSTATE_IDLE\tab 0x00\tab Disable all power to motors.\par
OUT_RUNSTATE_RAMPUP\tab 0x10\tab Enable ramping up from a current Power to a new (higher) Power over a specified TachoLimit goal.\par
OUT_RUNSTATE_RUNNING\tab 0x20\tab Enable power to motors at the specified Power level.\par
OUT_RUNSTATE_RAMPDOWN\tab 0x40\tab Enable ramping down from a current Power to a new (lower) Power over a specified TachoLimit goal.\par
\pard\sb120 Valid RegMode values are described in the following table.\par
\pard\sb120\tx3240\tx4320\b RegMode Constants\tab Value\tab Meaning\par
\pard\tx3240\tx4320\b0 OUT_REGMODE_IDLE\tab 0x00\tab No regulation\par
OUT_REGMODE_SPEED\tab 0x01\tab Regulate a motor's speed (Power)\par
OUT_REGMODE_SYNC\tab 0x02\tab Synchronize the rotation of two motors\par
\pard\keepn\s3\sb240\sa60\fs24\page\super #$K+\nosupersub 3.3.1 Convenience Calls\par
\pard\tqr\tx8640\fs20 Since control of outputs is such a common feature of programs, a number of convenience functions are provided that make it easy to work with the outputs. It should be noted that most of these commands do not provide any new functionality above lower level calls described in the following section. They are merely convenient ways to make programs more concise.\par
\pard\sb120\tqr\tx8640 The Ex versions of the motor functions use special reset constants. They are defined in the following table. The Var versions of the motor functions require that the outputs argument be a variable while the non-Var versions require that the outputs argument be a constant.\par
\pard\li720\sb120\tx4320\b Reset Constants\tab Value\par
\pard\li720\tx4320\b0 RESET_NONE\tab 0x00\par
RESET_COUNT\tab 0x08\par
RESET_BLOCK_COUNT\tab 0x20\par
RESET_ROTATION_COUNT\tab 0x40\par
RESET_BLOCKANDTACHO\tab 0x28\par
RESET_ALL\tab 0x68\par
\pard\li720\sb120\tx4320\b Output Port Constants\tab Value\par
\pard\li720\tx4320\b0 OUT_A\tab 0x00\par
OUT_B\tab 0x01\par
OUT_C\tab 0x02\par
OUT_AB\tab 0x03\par
OUT_AC\tab 0x04\par
OUT_BC\tab 0x05\par
OUT_ABC\tab 0x06\par
\pard\sb120\tqr\tx8640\b\fs24 Off(outputs)\tab Function\par
\b0\fs20 Turn the specified outputs off (with braking). Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 Off(OUT_A); // turn off output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OffEx(outputs, const reset)\tab Function\par
\b0\fs20 Turn the specified outputs off (with braking). Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OffEx(OUT_A, RESET_NONE); // turn off output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Coast(outputs)\tab Function\par
\b0\fs20 Turn off the specified outputs, making them coast to a stop. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 Coast(OUT_A); // coast output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CoastEx(outputs, const reset)\tab Function\par
\b0\fs20 Turn off the specified outputs, making them coast to a stop. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 CoastEx(OUT_A, RESET_NONE); // coast output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Float(outputs)\tab Function\par
\b0\fs20 Make outputs float. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Float is an alias for Coast.\par
\pard\li720\sb120\tqr\tx8640\f1 Float(OUT_A); // float output A\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnFwd(outputs, pwr)\tab Function\par
\b0\fs20 Set outputs to forward direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. \par
\pard\li720\sb120\tqr\tx8640\f1 OnFwd(OUT_A, 75);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnFwdEx(outputs, pwr, const reset)\tab Function\par
\b0\fs20 Set outputs to forward direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnFwdEx(OUT_A, 75, RESET_NONE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnRev(outputs, pwr)\tab Function\par
\b0\fs20 Set outputs to reverse direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnRev(OUT_A, 75);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnRevEx(outputs, pwr, const reset)\tab Function\par
\b0\fs20 Set outputs to reverse direction and turn them on. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnRevEx(OUT_A, 75, RESET_NONE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnFwdReg(outputs, pwr, regmode)\tab Function\par
\b0\fs20 Run the specified outputs forward using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Valid regulation modes are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnFwdReg(OUT_A, 75, OUT_REGMODE_SPEED); // regulate speed\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnFwdRegEx(outputs, pwr, regmode, const reset)\tab Function\par
\b0\fs20 Run the specified outputs forward using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Valid regulation modes are listed above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnFwdRegEx(OUT_A, 75, OUT_REGMODE_SPEED, RESET_NONE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnRevReg(outputs, pwr, regmode)\tab Function\par
\b0\fs20 Run the specified outputs in reverse using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Valid regulation modes are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnRevReg(OUT_A, 75, OUT_REGMODE_SPEED); // regulate speed\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnRevRegEx(outputs, pwr, regmode, const reset)\tab Function\par
\b0\fs20 Run the specified outputs in reverse using the specified regulation mode. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Valid regulation modes are listed above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnRevRegEx(OUT_A, 75, OUT_REGMODE_SPEED, RESET_NONE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnFwdSync(outputs, pwr, turnpct)\tab Function\par
\b0\fs20 Run the specified outputs forward with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnFwdSync(OUT_AB, 75, -100); // spin right\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnFwdSyncEx(outputs, pwr, turnpct, const reset)\tab Function\par
\b0\fs20 Run the specified outputs forward with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnFwdSyncEx(OUT_AB, 75, 0, RESET_NONE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnRevSync(outputs, pwr, turnpct)\tab Function\par
\b0\fs20 Run the specified outputs in reverse with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnRevSync(OUT_AB, 75, -100); // spin left\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnRevSyncEx(outputs, pwr, turnpct, const reset)\tab Function\par
\b0\fs20 Run the specified outputs in reverse with regulated synchronization using the specified turn ratio. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. The reset parameter controls whether any of the three position counters are reset. It must be a constant. Valid reset values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 OnRevSyncEx(OUT_AB, 75, -100, RESET_NONE); // spin left\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RotateMotor(outputs, pwr, angle)\tab Function\par
\b0\fs20 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 RotateMotor(OUT_A, 75, 45); // forward 45 degrees\par
RotateMotor(OUT_A, -75, 45); // reverse 45 degrees\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RotateMotorPID(outputs, pwr, angle, p, i, d)\tab Function\par
\b0\fs20 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. Also specify the proportional, integral, and derivative factors used by the firmware's PID motor control algorithm.\par
\pard\li720\sb120\tqr\tx8640\f1 RotateMotorPID(OUT_A, 75, 45, 20, 40, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RotateMotorEx(outputs, pwr, angle, turnpct, sync, stop)\tab Function\par
\b0\fs20 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. If a non-zero turn percent is specified then sync must be set to true or no turning will occur. Specify whether the motor(s) should brake at the end of the rotation using the stop parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 RotateMotorEx(OUT_AB, 75, 360, 50, true, true); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 RotateMotorExPID(outputs, pwr, angle, turnpct, sync, stop, p, i, d)\tab Function\par
\b0\fs20 Run the specified outputs forward for the specified number of degrees. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above. If a non-zero turn percent is specified then sync must be set to true or no turning will occur. Specify whether the motor(s) should brake at the end of the rotation using the stop parameter. Also specify the proportional, integral, and derivative factors used by the firmware's PID motor control algorithm.\par
\pard\li720\sb120\tqr\tx8640\f1 RotateMotorExPID(OUT_AB, 75, 360, 50, true, true, 30, 50, 90); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 ResetTachoCount(outputs)\tab Function\par
\b0\fs20 Reset the tachometer count and tachometer limit goal for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 ResetTachoCount(OUT_AB);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ResetBlockTachoCount(outputs)\tab Function\par
\b0\fs20 Reset the block-relative position counter for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 ResetBlockTachoCount(OUT_AB);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ResetRotationCount(outputs)\tab Function\par
\b0\fs20 Reset the program-relative position counter for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 ResetRotationCount(OUT_AB);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ResetAllTachoCounts(outputs)\tab Function\par
\b0\fs20 Reset all three position counters and reset the current tachometer limit goal for the specified outputs. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined above.\par
\pard\li720\sb120\tqr\tx8640\f1 ResetAllTachoCounts(OUT_AB);\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super #$K+\nosupersub 3.2.1 Primitive Calls\par
\pard\sb120\tqr\tx8640\b SetOutput(outputs, const field1, val1, \'85, const fieldN, valN)\tab Function\par
\pard\b0\fs20 Set the specified field of the outputs to the value provided. Outputs can be a constant or a variable containing the desired output ports. Predefined output port constants are defined in Table 20. The field must be a valid output field constant. This function takes a variable number of field/value pairs. The output field constants are described above.\par
\pard\li720\sb120\f1 SetOutput(OUT_AB, TachoLimit, 720); // set tacho limit\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetOutput(output, const field)\tab Value\par
\pard\sb120\b0\fs20 Get the value of the specified field for the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values. The field must be a valid output field constant. The output field constants are described above.\par
\pard\li720\sb120\f1 x = GetOutput(OUT_A, TachoLimit);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorMode(output)\tab Value\par
\pard\sb120\b0\fs20 Get the mode of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorMode(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorPower(output)\tab Value\par
\pard\sb120\b0\fs20 Get the power level of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorPower(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorActualSpeed(output)\tab Value\par
\pard\sb120\b0\fs20 Get the actual speed value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorActualSpeed(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorTachoCount(output)\tab Value\par
\pard\sb120\b0\fs20 Get the tachometer count value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorTachoCount(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorTachoLimit(output)\tab Value\par
\pard\sb120\b0\fs20 Get the tachometer limit value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorTachoLimit(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorRunState(output)\tab Value\par
\pard\sb120\b0\fs20 Get the RunState value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorRunState(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorTurnRatio(output)\tab Value\par
\pard\sb120\b0\fs20 Get the turn ratio value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorTurnRatio(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorRegulation(output)\tab Value\par
\pard\sb120\b0\fs20 Get the regulation value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorRegulation(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorOverload(output)\tab Value\par
\pard\sb120\b0\fs20 Get the overload value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorOverload(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorRegPValue(output)\tab Value\par
\pard\sb120\b0\fs20 Get the proportional PID value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorRegPValue(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorRegIValue(output)\tab Value\par
\pard\sb120\b0\fs20 Get the integral PID value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorRegIValue(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorRegDValue(output)\tab Value\par
\pard\sb120\b0\fs20 Get the derivative PID value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorRegDValue(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorBlockTachoCount(output)\tab Value\par
\pard\sb120\b0\fs20 Get the block-relative position counter value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorBlockTachoCount(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorRotationCount(output)\tab Value\par
\pard\sb120\b0\fs20 Get the program-relative position counter value of the specified output. Output can be OUT_A, OUT_B, OUT_C, or a variable containing one of these values.\par
\pard\li720\sb120\f1 x = MotorRotationCount(OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 MotorPwnFreq()\tab Value\par
\pard\sb120\b0\fs20 Get the current motor pulse width modulation frequency.\par
\pard\li720\sb120\f1 x = MotorPwnFreq();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetMotorPwnFreq(val)\tab Function\par
\pard\sb120\b0\fs20 Set the current motor pulse width modulation frequency.\par
\pard\li720\sb120\f1 SetMotorPwnFreq(x);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 3.3.3 IOMap Offsets\par
\pard\li720\tx4320\tx6480\i0\fs20 Output Module Offsets\tab Value\tab Size\par
\pard\s2\li720\tx4320\tx6480\b0 OutputOffsetTachoCount(p)\tab (((p)*32)+0)\tab 4\par
OutputOffsetBlockTachoCount(p)\tab (((p)*32)+4)\tab 4\par
OutputOffsetRotationCount(p)\tab (((p)*32)+8)\tab 4\par
OutputOffsetTachoLimit(p)\tab (((p)*32)+12)\tab 4\par
OutputOffsetMotorRPM(p)\tab (((p)*32)+16)\tab 2\par
OutputOffsetFlags(p)\tab (((p)*32)+18)\tab 1\par
OutputOffsetMode(p)\tab (((p)*32)+19)\tab 1\par
OutputOffsetSpeed(p)\tab (((p)*32)+20)\tab 1\par
OutputOffsetActualSpeed(p)\tab (((p)*32)+21)\tab 1\par
OutputOffsetRegPParameter(p)\tab (((p)*32)+22)\tab 1\par
OutputOffsetRegIParameter(p)\tab (((p)*32)+23)\tab 1\par
OutputOffsetRegDParameter(p)\tab (((p)*32)+24)\tab 1\par
OutputOffsetRunState(p)\tab (((p)*32)+25)\tab 1\par
OutputOffsetRegMode(p)\tab (((p)*32)+26)\tab 1\par
OutputOffsetOverloaded(p)\tab (((p)*32)+27)\tab 1\par
OutputOffsetSyncTurnParameter(p)\tab (((p)*32)+28)\tab 1\par
OutputOffsetPwnFreq\tab 96\tab 1\par
\pard\par
\pard\keepn\s2\sb240\sa60\b\i\fs24\page\super #$K+\nosupersub 3.4 IO Map Addresses\par
\pard\b0\i0\fs20 The NXT firmware provides a mechanism for reading and writing input (sensor) and output (motor) field values using low-level constants known as IO Map Addresses (IOMA). Valid IOMA constants are listed in the following table.\par
\pard\sb120\tx2880\tx5040\b IOMA Constant\tab Parameter\tab Meaning\par
\pard\tx2880\tx5040\b0 InputIOType(p)            \tab S1..S4\tab Input Type value\par
InputIOInputMode(p)       \tab S1..S4\tab Input InputMode value\par
InputIORawValue(p)        \tab S1..S4\tab Input RawValue value\par
InputIONormalizedValue(p) \tab S1..S4\tab Input NormalizedValue value\par
InputIOScaledValue(p)     \tab S1..S4\tab Input ScaledValue value\par
InputIOInvalidData(p)     \tab S1..S4\tab Input InvalidData value\par
OutputIOUpdateFlags(p)    \tab OUT_A..OUT_C\tab Output UpdateFlags value\par
OutputIOOutputMode(p)     \tab OUT_A..OUT_C\tab Output OutputMode value\par
OutputIOPower(p)          \tab OUT_A..OUT_C\tab Output Power value\par
OutputIOActualSpeed(p)    \tab OUT_A..OUT_C\tab Output ActualSpeed value\par
OutputIOTachoCount(p)     \tab OUT_A..OUT_C\tab Output TachoCount value\par
OutputIOTachoLimit(p)      \tab OUT_A..OUT_C\tab Output TachoLimit value\par
OutputIORunState(p)        \tab OUT_A..OUT_C\tab Output RunState value\par
OutputIOTurnRatio(p)       \tab OUT_A..OUT_C\tab Output TurnRatio value\par
OutputIORegMode(p)         \tab OUT_A..OUT_C\tab Output RegMode value\par
OutputIOOverload(p)        \tab OUT_A..OUT_C\tab Output Overload value\par
OutputIORegPValue(p)       \tab OUT_A..OUT_C\tab Output RegPValue value\par
OutputIORegIValue(p)       \tab OUT_A..OUT_C\tab Output RegIValue value\par
OutputIORegDValue(p)       \tab OUT_A..OUT_C\tab Output RegDValue value\par
OutputIOBlockTachoCount(p) \tab OUT_A..OUT_C\tab Output BlockTachoCount value\par
OutputIORotationCount(p)   \tab OUT_A..OUT_C\tab Output RotationCount value.\par
\par
\pard\sb120\tqr\tx8640\b\fs24 IOMA(const n)\tab Value\par
\b0\fs20 Get the specified IO Map Address value. Valid IO Map Address constants are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = IOMA(InputIORawValue(S3));\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetIOMA(const n, val)\tab Function\par
\b0\fs20 Set the specified IO Map Address to the value provided. Valid IO Map Address constants are listed above. The value must be a specified via a constant, a constant expression, or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 SetIOMA(OutputIOPower(OUT_A), x);\par
\pard\keepn\s2\b\i\f0\fs24\page\super #$K+\nosupersub 3.5 Sound Module\par
\pard\sb120\b0\i0\fs20 The NXT sound module encompasses all sound output features. The NXT provides support for playing basic tones as well as two different types of files. \par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 SoundModuleName\tab "Sound.mod"\par
SoundModuleID\tab 0x00080001\par
\pard\sb120 Sound files (.rso) are like .wav files. They contain thousands of sound samples that digitally represent an analog waveform. With sounds files the NXT can speak or play music or make just about any sound imaginable.\par
Melody files are like MIDI files. They contain multiple tones with each tone being defined by a frequency and duration pair. When played on the NXT a melody file sounds like a pure sine-wave tone generator playing back a series of notes. While not as fancy as sound files, melody files are usually much smaller than sound files.\par
When a sound or a file is played on the NXT, execution of the program does not wait for the previous playback to complete. To play multiple tones or files sequentially it is necessary to wait for the previous tone or file playback to complete first. This can be done via the Wait API function or by using the sound state value within a while loop.\par
The NXC API defines frequency and duration constants which may be used in calls to PlayTone or PlayToneEx. Frequency constants start with TONE_A3 (the 'A' pitch in octave 3) and go to TONE_B7 (the 'B' pitch in octave 7). Duration constants start with MS_1 (1 millisecond) and go up to MIN_1 (60000 milliseconds) with several constants in between. See NBCCommon.h for the complete list.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super\b #$K+\nosupersub 3.5.1 High-level functions\par
\pard\sb120\tqr\tx8640 PlayTone(frequency, duration)\tab Function\par
\b0\fs20 Play a single tone of the specified frequency and duration. The frequency is in Hz. The duration is in 1000ths of a second. All parameters may be any valid expression.\par
\pard\li720\sb120\tqr\tx8640\f1 PlayTone(440, 500);\tab // Play 'A' for one half second\par
\pard\sb120\tqr\tx8640\b\f0\fs24 PlayToneEx(frequency, duration, volume, bLoop)\tab Function\par
\b0\fs20 Play a single tone of the specified frequency, duration, and volume. The frequency is in Hz. The duration is in 1000ths of a second. Volume should be a number from 0 (silent) to 4 (loudest). All parameters may be any valid expression.\par
\pard\li720\sb120\tqr\tx8640\f1 PlayToneEx(440, 500, 2, false);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 PlayFile(filename)\tab Function\par
\b0\fs20 Play the specified sound file (.rso) or a melody file (.rmd). The filename may be any valid string expression.\par
\pard\li720\sb120\tqr\tx8640\f1 PlayFile("startup.rso");\par
\pard\sb120\tqr\tx8640\b\f0\fs24 PlayFileEx(filename, volume, bLoop)\tab Function\par
\b0\fs20 Play the specified sound file (.rso) or a melody file (.rmd). The filename may be any valid string expression. Volume should be a number from 0 (silent) to 4 (loudest). bLoop is a boolean value indicating whether to repeatedly play the file.\par
\pard\li720\sb120\tqr\tx8640\f1 PlayFileEx("startup.rso", 3, true);\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super\b #$K+\nosupersub 3.5.2 Low-level functions\par
\pard\sb120\tqr\tx8640\b0\fs20 Valid sound flags constants are listed in the following table.\par
\pard\sb120\tx2709\tx4059\b\fs22 Sound Flags Constants\tab Read/Write\tab Meaning\par
\pard\tx2709\tx4059\b0\fs20 SOUND_FLAGS_IDLE\tab Read\tab Sound is idle\par
SOUND_FLAGS_UPDATE\tab Write\tab Make changes take effect\par
SOUND_FLAGS_RUNNING\tab Read\tab Processing a tone or file\par
\pard\sb120\tqr\tx8640 Valid sound state constants are listed in the following table.\par
\pard\sb120\tx2439\tx3789\b\fs22 Sound State Constants\tab Read/Write\tab Meaning\par
\pard\tx2439\tx3789\b0\fs20 SOUND_STATE_IDLE\tab Read\tab Idle, ready for start sound\par
SOUND_STATE_FILE\tab Read\tab Processing file of sound/melody data\par
SOUND_STATE_TONE\tab Read\tab Processing play tone request\par
SOUND_STATE_STOP\tab Write\tab Stop sound immediately and close hardware\par
\pard\sb120\tqr\tx8640 Valid sound mode constants are listed in the following table.\par
\pard\sb120\tx2439\tx3789\b\fs22 Sound Mode Constants\tab Read/Write\tab Meaning\par
\pard\tx2439\tx3789\b0\fs20 SOUND_MODE_ONCE\tab Read\tab Only play file once\par
SOUND_MODE_LOOP\tab Read\tab Play file until writing SOUND_STATE_STOP into State.\par
SOUND_MODE_TONE\tab Read\tab Play tone specified in Frequency for Duration milliseconds.\par
\pard\sb120\tqr\tx8640 Miscellaneous sound constants are listed in the following table.\par
\pard\sb120\tx2539\tx3889\b\fs22 Misc. Sound Constants\tab Value\tab Meaning\par
\pard\tx2539\tx3889\b0\fs20 FREQUENCY_MIN\tab 220\tab Minimum frequency in Hz.\par
FREQUENCY_MAX\tab 14080\tab Maximum frequency in Hz.\par
SAMPLERATE_MIN\tab 2000\tab Minimum sample rate supported by NXT\par
SAMPLERATE_DEFAULT\tab 8000\tab Default sample rate\par
SAMPLERATE_MAX\tab 16000\tab Maximum sample rate supported by NXT\par
\pard\sb120\tqr\tx8640\b\fs24 SoundFlags()\tab Value\par
\b0\fs20 Return the current sound flags. Valid sound flags values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SoundFlags();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSoundFlags(n)\tab Function\par
\b0\fs20 Set the current sound flags. Valid sound flags values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSoundFlags(SOUND_FLAGS_UPDATE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SoundState()\tab Value\par
\b0\fs20 Return the current sound state. Valid sound state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SoundState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSoundModuleState(n)\tab Function\par
\b0\fs20 Set the current sound module state. Valid sound state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSoundModuleState(SOUND_STATE_STOP);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SoundMode()\tab Value\par
\b0\fs20 Return the current sound mode. Valid sound mode values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SoundMode();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSoundMode(n)\tab Function\par
\b0\fs20 Set the current sound mode. Valid sound mode values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSoundMode(SOUND_MODE_ONCE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SoundFrequency()\tab Value\par
\b0\fs20 Return the current sound frequency.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SoundFrequency();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSoundFrequency(n)\tab Function\par
\b0\fs20 Set the current sound frequency.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSoundFrequency(440);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SoundDuration()\tab Value\par
\b0\fs20 Return the current sound duration.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SoundDuration();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSoundDuration(n)\tab Function\par
\b0\fs20 Set the current sound duration.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSoundDuration(500);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SoundSampleRate()\tab Value\par
\b0\fs20 Return the current sound sample rate.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SoundSampleRate();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSoundSampleRate(n)\tab Function\par
\b0\fs20 Set the current sound sample rate.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSoundSampleRate(4000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SoundVolume()\tab Value\par
\b0\fs20 Return the current sound volume.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SoundVolume();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSoundVolume(n)\tab Function\par
\b0\fs20 Set the current sound volume.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSoundVolume(3);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 StopSound()\tab Function\par
\b0\fs20 Stop playback of the current tone or file.\par
\pard\li720\sb120\tqr\tx8640\f1 StopSound();\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super\b #$K+\nosupersub 3.5.2 IOMap Offsets\par
\pard\sb120\tx2654\tx3554 Sound Module Offsets\tab Value\tab Size\par
\pard\tx2654\tx3554\b0\fs20 SoundOffsetFreq\tab 0\tab 2\par
SoundOffsetDuration\tab 2\tab 2\par
SoundOffsetSampleRate\tab 4\tab 2\par
SoundOffsetSoundFilename\tab 6\tab 20\par
SoundOffsetFlags\tab 26\tab 1\par
SoundOffsetState\tab 27\tab 1\par
SoundOffsetMode\tab 28\tab 1\par
SoundOffsetVolume\tab 29\tab 1\par
\pard\sb120\tqr\tx8640\f1\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super #$K+\nosupersub 3.6 IO Control Module\tab\par
\pard\sb120\tqr\tx8640\b0\i0\fs20 The NXT ioctrl module encompasses low-level communication between the two processors that control the NXT. The NXC API exposes two functions that are part of this module.\par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 IOCtrlModuleName\tab "IOCtrl.mod"\par
IOCtrlModuleID\tab 0x00060001\par
\pard\sb120\tqr\tx8640\b\fs24 PowerDown()\tab Function\par
\b0\fs20 Turn off the NXT immediately.\par
\pard\li720\sb120\tqr\tx8640\f1 PowerDown();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RebootInFirmwareMode()\tab Function\par
\b0\fs20 Reboot the NXT in SAMBA or firmware download mode. This function is not likely to be used in a normal NXC program.\par
\pard\li720\sb120\tqr\tx8640\f1 RebootInFirmwareMode();\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super\i0 #$K+\nosupersub 3.6.1 IOMap Offsets\tab\par
\pard\li590\sb120\tx3348\tx4296 IOCtrl Module Offsets\tab Value\tab Size\par
\pard\li590\tx3348\tx4296\b0\fs20 IOCtrlOffsetPowerOn\tab 0\tab 2\par
\pard\keepn\s2\sb240\sa60\tqr\tx8640\b\i\fs24\page\super #$K+\nosupersub\i0 3.7 Display Module\i\par
\pard\b0\i0\fs20 The NXT display module encompasses support for drawing to the NXT LCD. The NXT supports drawing points, lines, rectangles, and circles on the LCD. It supports drawing graphic icon files on the screen as well as text and numbers.\par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 DisplayModuleName\tab "Display.mod"\par
DisplayModuleID\tab 0x000A0001\par
\pard\sb120\tqr\tx8640 The LCD screen has its origin (0, 0) at the bottom left-hand corner of the screen with the positive Y-axis extending upward and the positive X-axis extending toward the right. The NXC API provides constants for use in the NumOut and TextOut functions which make it possible to specify LCD line numbers between 1 and 8 with line 1 being at the top of the screen and line 8 being at the bottom of the screen. These constants (LCD_LINE1, LCD_LINE2, LCD_LINE3, LCD_LINE4, LCD_LINE5, LCD_LINE6, LCD_LINE7, LCD_LINE8) should be used as the Y coordinate in NumOut and TextOut calls. Values of Y other than these constants will be adjusted so that text and numbers are on one of 8 fixed line positions.\par
\pard\keepn\s3\sb240\sa60\b\fs24\page\super #$K+\nosupersub 3.7.1 High-level functions\par
\pard\sb120\tqr\tx8640 NumOut(x, y, value, clear = false)\tab Function\par
\b0\fs20 Draw a numeric value on the screen at the specified x and y location. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\f1 NumOut(0, LCD_LINE1, x); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 TextOut(x, y, msg, clear = false)\tab Function\par
\b0\fs20 Draw a text value on the screen at the specified x and y location. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\f1 TextOut(0, LCD_LINE3, "Hello World!"); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 GraphicOut(x, y, filename, clear = false)\tab Function\par
\b0\fs20 Draw the specified graphic icon file on the screen at the specified x and y location. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false. If the file cannot be found then nothing will be drawn and no errors will be reported.\par
\pard\li720\sb120\tqr\tx8640\f1 GraphicOut(40, 40, "image.ric"); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 GraphicOutEx(x, y, filename, vars, clear = false)\tab Function\par
\b0\fs20 Draw the specified graphic icon file on the screen at the specified x and y location. Use the values contained in the vars array to transform the drawing commands contained within the specified icon file. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false. If the file cannot be found then nothing will be drawn and no errors will be reported.\par
\pard\li720\sb120\tqr\tx8640\f1 GraphicOutEx(40, 40, "image.ric", variables);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CircleOut(x, y, radius, clear = false)\tab Function\par
\b0\fs20 Draw a circle on the screen with its center at the specified x and y location, using the specified radius. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\f1 CircleOut(40, 40, 10); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 LineOut(x1, y1, x2, y2, clear = false)\tab Function\par
\b0\fs20 Draw a line on the screen from x1, y1 to x2, y2. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\f1 LineOut(40, 40, 10, 10); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 PointOut(x, y, clear = false)\tab Function\par
\b0\fs20 Draw a point on the screen at x, y. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\f1 PointOut(40, 40); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 RectOut(x, y, width, height, clear = false)\tab Function\par
\b0\fs20 Draw a rectangle on the screen at x, y with the specified width and height. Optionally clear the screen first depending on the boolean value of the optional "clear" argument. If this argument is not specified it defaults to false.\par
\pard\li720\sb120\tqr\tx8640\f1 RectOut(40, 40, 30, 10); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 ResetScreen()\tab Function\par
\b0\fs20 Restore the standard NXT running program screen.\par
\pard\li720\sb120\tqr\tx8640\f1 ResetScreen(); \par
\pard\sb120\tqr\tx8640\b\f0\fs24 ClearScreen()\tab Function\par
\b0\fs20 Clear the NXT LCD to a blank screen.\par
\pard\li720\sb120\tqr\tx8640\f1 ClearScreen();\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super\b #$K+\nosupersub 3.7.2 Low-level functions\par
\pard\sb120\tqr\tx8640\b0\fs20 Valid display flag values are listed in the following table.\par
\pard\li720\sb120\tx3960\tx5400\b Display Flags Constant\tab Read/Write\tab Meaning\par
\pard\li720\tx3960\tx5400\b0 DISPLAY_ON\tab Write\tab Display is on\par
DISPLAY_REFRESH\tab Write\tab Enable refresh\par
DISPLAY_POPUP\tab Write\tab Use popup display memory\par
DISPLAY_REFRESH_DISABLED\tab Read\tab Refresh is disabled\par
DISPLAY_BUSY\tab Read\tab Refresh is in progress\par
\pard\sb120\tqr\tx8640\b\fs24 DisplayFlags()\tab Value\par
\pard\b0\fs20 Return the current display flags. Valid flag values are listed in Table 32.\par
\pard\li720\sb120\tqr\tx8640\f1 x = DisplayFlags();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetDisplayFlags(n)\tab Function\par
\pard\b0\fs20 Set the current display flags. Valid flag values are listed in Table 32.\par
\pard\li720\sb120\tqr\tx8640\f1 SetDisplayFlags(x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 DisplayEraseMask()\tab Value\par
\b0\fs20 Return the current display erase mask.\par
\pard\li720\sb120\tqr\tx8640\f1 x = DisplayEraseMask();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetDisplayEraseMask(n)\tab Function\par
\b0\fs20 Set the current display erase mask.\par
\pard\li720\sb120\tqr\tx8640\f1 SetDisplayEraseMask(x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 DisplayUpdateMask()\tab Value\par
\b0\fs20 Return the current display update mask.\par
\pard\li720\sb120\tqr\tx8640\f1 x = DisplayUpdateMask();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetDisplayUpdateMask(n)\tab Function\par
\b0\fs20 Set the current display update mask.\par
\pard\li720\sb120\tqr\tx8640\f1 SetDisplayUpdateMask(x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 DisplayDisplay()\tab Value\par
\b0\fs20 Return the current display memory address.\par
\pard\li720\sb120\tqr\tx8640\f1 x = DisplayDisplay();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetDisplayDisplay(n)\tab Function\par
\b0\fs20 Set the current display memory address.\par
\pard\li720\sb120\tqr\tx8640\f1 SetDisplayDisplay(x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 DisplayTextLinesCenterFlags()\tab Value\par
\b0\fs20 Return the current display text lines center flags.\par
\pard\li720\sb120\tqr\tx8640\f1 x = DisplayTextLinesCenterFlags();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetDisplayTextLinesCenterFlags(n)\tab Function\par
\b0\fs20 Set the current display text lines center flags.\par
\pard\li720\sb120\tqr\tx8640\f1 SetDisplayTextLinesCenterFlags(x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetDisplayNormal(x, line, count, data)\tab Function\par
\b0\fs20 Read "count" bytes from the normal display memory into the data array. Start reading from the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through TEXTLINE_8 for the "line" parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 GetDisplayNormal(0, TEXTLINE_1, 8, ScreenMem);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetDisplayNormal(x, line, count, data)\tab Function\par
\b0\fs20 Write "count" bytes to the normal display memory from the data array. Start writing at the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through TEXTLINE_8 for the "line" parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 SetDisplayNormal(0, TEXTLINE_1, 8, ScreenMem);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetDisplayPopup(x, line, count, data)\tab Function\par
\b0\fs20 Read "count" bytes from the popup display memory into the data array. Start reading from the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through TEXTLINE_8 for the "line" parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 GetDisplayPopup(0, TEXTLINE_1, 8, PopupMem);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetDisplayPopup(x, line, count, data)\tab Function\par
\b0\fs20 Write "count" bytes to the popup display memory from the data array. Start writing at the specified x, line coordinate. Each byte of data read from screen memory is a vertical strip of 8 bits at the desired location. Each bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through TEXTLINE_8 for the "line" parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 SetDisplayPopup(0, TEXTLINE_1, 8, PopupMem);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super\i0 #$K+\nosupersub 3.7.1 IOMap Offsets\tab\par
\pard\sb120\tx3348\tx5223 Display Module Offsets\tab Value\tab Size\par
\pard\tx3348\tx5223\b0\fs20 DisplayOffsetPFunc\tab 0\tab 4\par
DisplayOffsetEraseMask\tab 4\tab 4\par
DisplayOffsetUpdateMask\tab 8\tab 4\par
DisplayOffsetPFont\tab 12\tab 4\par
DisplayOffsetPTextLines(p)\tab (((p)*4)+16)\tab 4*8\par
DisplayOffsetPStatusText\tab 48\tab 4\par
DisplayOffsetPStatusIcons\tab 52\tab 4\par
DisplayOffsetPScreens(p)\tab (((p)*4)+56)\tab 4*3\par
DisplayOffsetPBitmaps(p)\tab (((p)*4)+68)\tab 4*4\par
DisplayOffsetPMenuText\tab 84\tab 4\par
DisplayOffsetPMenuIcons(p)\tab (((p)*4)+88)\tab 4*3\par
DisplayOffsetPStepIcons\tab 100\tab 4\par
DisplayOffsetDisplay\tab 104\tab 4\par
DisplayOffsetStatusIcons(p)\tab ((p)+108)\tab 1*4\par
DisplayOffsetStepIcons(p)\tab ((p)+112)\tab 1*5\par
DisplayOffsetFlags\tab 117\tab 1\par
DisplayOffsetTextLinesCenterFlags\tab 118\tab 1\par
DisplayOffsetNormal(l,w)\tab (((l)*100)+(w)+119)\tab 800\par
DisplayOffsetPopup(l,w)\tab (((l)*100)+(w)+919)\tab 800\par
\pard\keepn\s2\sb240\sa60\tqr\tx8640\b\i\fs24\page\super #$K+\nosupersub\i0 3.8 Loader Module\i\par
\pard\sb120\tqr\tx8640\b0\i0\fs20 The NXT loader module encompasses support for the NXT file system. The NXT supports creating files, opening existing files, reading, writing, renaming, and deleting files.\par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 LoaderModuleName\tab "Loader.mod"\par
LoaderModuleID\tab 0x00090001\par
\pard\sb120\tqr\tx8640 Files in the NXT file system must adhere to the 15.3 naming convention for a maximum filename length of 19 characters. While multiple files can be opened simultaneously, a maximum of 4 files can be open for writing at any given time.\par
When accessing files on the NXT, errors can occur. The NXC API defines several constants that define possible result codes. They are listed in the following table.\par
\pard\li720\sb120\tx4320\b\fs24 Loader Result Codes\tab Value\par
\pard\li720\tx4320\b0\fs20 LDR_SUCCESS\tab 0x0000\par
LDR_INPROGRESS\tab 0x0001\par
LDR_REQPIN\tab 0x0002\par
LDR_NOMOREHANDLES\tab 0x8100\par
LDR_NOSPACE\tab 0x8200\par
LDR_NOMOREFILES\tab 0x8300\par
LDR_EOFEXPECTED\tab 0x8400\par
LDR_ENDOFFILE\tab 0x8500\par
LDR_NOTLINEARFILE\tab 0x8600\par
LDR_FILENOTFOUND\tab 0x8700\par
LDR_HANDLEALREADYCLOSED\tab 0x8800\par
LDR_NOLINEARSPACE\tab 0x8900\par
LDR_UNDEFINEDERROR\tab 0x8A00\par
LDR_FILEISBUSY\tab 0x8B00\par
LDR_NOWRITEBUFFERS\tab 0x8C00\par
LDR_APPENDNOTPOSSIBLE\tab 0x8D00\par
LDR_FILEISFULL\tab 0x8E00\par
LDR_FILEEXISTS\tab 0x8F00\par
LDR_MODULENOTFOUND\tab 0x9000\par
LDR_OUTOFBOUNDARY\tab 0x9100\par
LDR_ILLEGALFILENAME\tab 0x9200\par
LDR_ILLEGALHANDLE\tab 0x9300\par
LDR_BTBUSY\tab 0x9400\par
LDR_BTCONNECTFAIL\tab 0x9500\par
LDR_BTTIMEOUT\tab 0x9600\par
LDR_FILETX_TIMEOUT\tab 0x9700\par
LDR_FILETX_DSTEXISTS\tab 0x9800\par
LDR_FILETX_SRCMISSING\tab 0x9900\par
LDR_FILETX_STREAMERROR\tab 0x9A00\par
LDR_FILETX_CLOSEERROR\tab 0x9B00\par
\pard\sb120\tqr\tx8640\b\fs24 FreeMemory()\tab Value\par
\b0\fs20 Get the number of bytes of flash memory that are available for use.\par
\pard\li720\sb120\tqr\tx8640\f1 x = FreeMemory();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CreateFile(filename, size, out handle)\tab Value\par
\b0\fs20 Create a new file with the specified filename and size and open it for writing. The file handle is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename and size parameters must be constants, constant expressions, or variables. A file created with a size of zero bytes cannot be written to since the NXC file writing functions do not grow the file if its capacity is exceeded during a write attempt.\par
\pard\li720\sb120\tqr\tx8640\f1 result = CreateFile("data.txt", 1024, handle);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OpenFileAppend(filename, out size, out handle)\tab Value\par
\b0\fs20 Open an existing file with the specified filename for writing. The file size is returned in the second parameter, which must be a variable. The file handle is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = OpenFileAppend("data.txt", fsize, handle);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OpenFileRead(filename, out size, out handle)\tab Value\par
\b0\fs20 Open an existing file with the specified filename for reading. The file size is returned in the second parameter, which must be a variable. The file handle is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = OpenFileRead("data.txt", fsize, handle);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CloseFile(handle)\tab Value\par
\b0\fs20 Close the file associated with the specified file handle. The loader result code is returned as the value of the function call. The handle parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = CloseFile(handle);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ResolveHandle(filename, out handle, out bWriteable)\tab Value\par
\b0\fs20 Resolve a file handle from the specified filename. The file handle is returned in the second parameter, which must be a variable. A boolean value indicating whether the handle can be used to write to the file or not is returned in the last parameter, which must be a variable. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = ResolveHandle("data.txt", handle, bCanWrite);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RenameFile(oldfilename, newfilename)\tab Value\par
\b0\fs20 Rename a file from the old filename to the new filename. The loader result code is returned as the value of the function call. The filename parameters must be constants or variables.\par
\pard\li720\sb120\tqr\tx8640\f1 result = RenameFile("data.txt", "mydata.txt");\par
\pard\sb120\tqr\tx8640\b\f0\fs24 DeleteFile(filename)\tab Value\par
\b0\fs20 Delete the specified file. The loader result code is returned as the value of the function call. The filename parameter must be a constant or a variable.\par
\pard\li720\sb120\tqr\tx8640\f1 result = DeleteFile("data.txt");\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Read(handle, out value)\tab Value\par
\b0\fs20 Read a numeric value from the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a variable. The type of the value parameter determines the number of bytes of data read.\par
\pard\li720\sb120\tqr\tx8640\f1 result = Read(handle, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReadLn(handle, out value)\tab Value\par
\b0\fs20 Read a numeric value from the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a variable. The type of the value parameter determines the number of bytes of data read. The ReadLn function reads two additional bytes from the file which it assumes are a carriage return and line feed pair.\par
\pard\li720\sb120\tqr\tx8640\f1 result = ReadLn(handle, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReadBytes(handle, in/out length, out buf)\tab Value\par
\b0\fs20 Read the specified number of bytes from the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The length parameter must be a variable. The buf parameter must be an array or a string variable. The actual number of bytes read is returned in the length parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = ReadBytes(handle, len, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 Write(handle, value)\tab Value\par
\b0\fs20 Write a numeric value to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a constant, a constant expression, or a variable. The type of the value parameter determines the number of bytes of data written.\par
\pard\li720\sb120\tqr\tx8640\f1 result = Write(handle, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 WriteLn(handle, value)\tab Value\par
\b0\fs20 Write a numeric value to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The value parameter must be a constant, a constant expression, or a variable. The type of the value parameter determines the number of bytes of data written. The WriteLn function also writes a carriage return and a line feed to the file following the numeric data.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteLn(handle, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 WriteString(handle, str, out count)\tab Value\par
\b0\fs20 Write the string to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The count parameter must be a variable. The str parameter must be a string variable or string constant. The actual number of bytes written is returned in the count parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteString(handle, "testing", count);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 WriteLnString(handle, str, out count)\tab Value\par
\b0\fs20 Write the string to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The count parameter must be a variable. The str parameter must be a string variable or string constant. This function also writes a carriage return and a line feed to the file following the string data. The total number of bytes written is returned in the count parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteLnString(handle, "testing", count);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 WriteBytes(handle, data, out count)\tab Value\par
\b0\fs20 Write the contents of the data array to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The count parameter must be a variable. The data parameter must be an array. The actual number of bytes written is returned in the count parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteBytes(handle, buffer, count);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 WriteBytesEx(handle, in/out length, buf)\tab Value\par
\b0\fs20 Write the specified number of bytes to the file associated with the specified handle. The loader result code is returned as the value of the function call. The handle parameter must be a variable. The length parameter must be a variable. The buf parameter must be an array or a string variable or string constant. The actual number of bytes written is returned in the length parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 result = WriteBytesEx(handle, len, buffer);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super\i0 #$K+\nosupersub 3.8.1 IOMap Offsets\tab\par
\pard\sb120\tx3348\tx4677 Loader Module Offsets\tab Value\tab Size\par
\pard\tx3348\tx4677\b0\fs20 LoaderOffsetPFunc\tab 0\tab 4\par
LoaderOffsetFreeUserFlash\tab 4\tab 4\par
\pard\keepn\s2\sb240\sa60\tqr\tx8640\b\i\fs24\page\super #$K+\nosupersub\i0 3.9 Command Module\i\par
\pard\b0\i0\fs20 The NXT command module encompasses support for the execution of user programs via the NXT virtual machine. It also implements the direct command protocol support that enables the NXT to respond to USB or Bluetooth requests from other devices such as a PC or another NXT brick.\par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 CommandModuleName\tab "Command.mod"\par
CommandModuleID\tab 0x00010001\par
\pard\keepn\s2\sb240\sa60\b\fs24\page\super #$K+\nosupersub 3.9.1 IOMap Offsets\tab\par
\pard\sb120\tx3348\tx4338 Command Module Offsets\tab Value\tab Size\par
\pard\tx3348\tx4338\b0\fs20 CommandOffsetFormatString\tab 0\tab 16\par
CommandOffsetPRCHandler\tab 16\tab 4\par
CommandOffsetTick\tab 20\tab 4\par
CommandOffsetOffsetDS\tab 24\tab 2\par
CommandOffsetOffsetDVA\tab 26\tab 2\par
CommandOffsetProgStatus\tab 28\tab 1\par
CommandOffsetAwake\tab 29\tab 1\par
CommandOffsetActivateFlag\tab 30\tab 1\par
CommandOffsetDeactivateFlag\tab 31\tab 1\par
CommandOffsetFileName\tab 32\tab 20\par
CommandOffsetMemoryPool\tab 52\tab 32k\par
\pard\keepn\s2\fi-576\li576\sb240\sa60\tx900\tqr\tx8640\b\i\fs24\page\super #$K+\nosupersub\i0 3.10 Button Module\i\par
\pard\b0\i0\fs20 The NXT button module encompasses support for the 4 buttons on the NXT brick. \par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 ButtonModuleName\tab "Button.mod"\par
ButtonModuleID\tab 0x00040001\par
\pard\keepn\s3\sb240\sa60\fs24\page\super\b #$K+\nosupersub 3.10.1 High-level functions\par
\pard\b0\fs20 Valid button constant values are listed in the following table.\par
\pard\sb120\tx3483\b Button Constants\tab Value\par
\pard\tx3483\b0 BTN1, BTNEXIT\tab 0\par
BTN2, BTNRIGHT\tab 1\par
BTN3, BTNLEFT\tab 2\par
BTN4, BTNCENTER\tab 3\par
NO_OF_BTNS\tab 4\par
\pard\sb120\tqr\tx8640\b\fs24 ButtonCount(btn, reset)\tab Value\par
\b0\fs20 Return the number of times the specified button has been pressed since the last time the button press count was reset. Optionally clear the count after reading it. Valid values for the btn argument are listed above\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonCount(BTN1, true);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ButtonPressed(btn, reset)\tab Value\par
\b0\fs20 Return whether the specified button is pressed. Optionally clear the press count. Valid values for the btn argument are listed above\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonPressed(BTN1, true);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReadButtonEx(btn, reset, out pressed, out count)\tab Function\par
\b0\fs20 Read the specified button. Set the pressed and count parameters with the current state of the button. Optionally reset the press count after reading it. Valid values for the btn argument are listed above\par
\pard\li720\sb120\tqr\tx8640\f1 ReadButtonEx(BTN1, true, pressed, count);\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super\b #$K+\nosupersub 3.10.2 Low-level functions\par
\pard\sb120\tqr\tx8640\b0\fs20 Valid button state values are listed in the following table.\par
\pard\sb120\tx3483\b Button State Constants\tab Value\par
\pard\tx3483\b0 BTNSTATE_PRESSED_EV\tab 0x01\par
BTNSTATE_SHORT_RELEASED_EV\tab 0x02\par
BTNSTATE_LONG_PRESSED_EV\tab 0x04\par
BTNSTATE_LONG_RELEASED_EV\tab 0x08\par
BTNSTATE_PRESSED_STATE\tab 0x80\par
\pard\sb120\tqr\tx8640\b\fs24 ButtonPressCount(btn)\tab Value\par
\b0\fs20 Return the press count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonPressCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetButtonPressCount(btn, value)\tab Function\par
\b0\fs20 Set the press count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonPressCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ButtonLongPressCount(btn)\tab Value\par
\b0\fs20 Return the long press count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonLongPressCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetButtonLongPressCount(btn, value)\tab Function\par
\b0\fs20 Set the long press count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonLongPressCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ButtonShortReleaseCount(btn)\tab Value\par
\b0\fs20 Return the short release count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonShortReleaseCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetButtonShortReleaseCount(btn, value)\tab Function\par
\b0\fs20 Set the short release count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonShortReleaseCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ButtonLongReleaseCount(btn)\tab Value\par
\b0\fs20 Return the long release count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonLongReleaseCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetButtonLongReleaseCount(btn, value)\tab Function\par
\b0\fs20 Set the long release count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonLongReleaseCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ButtonReleaseCount(btn)\tab Value\par
\b0\fs20 Return the release count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonReleaseCount(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetButtonReleaseCount(btn, value)\tab Function\par
\b0\fs20 Set the release count of the specified button. Valid values for the btn argument are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonReleaseCount(BTN1, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ButtonState(btn)\tab Value\par
\b0\fs20 Return the state of the specified button. Valid values for the btn argument are listed above. Button state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 value = ButtonState(BTN1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetButtonState(btn, value)\tab Function\par
\b0\fs20 Set the state of the specified button. Valid values for the btn argument are listed above. Button state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetButtonState(BTN1, BTNSTATE_PRESSED_EV);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super\i0 #$K+\nosupersub 3.10.3 IOMap Offsets\tab\par
\pard\sb120\tx3348\tx4477 Button Module Offsets\tab Value\tab Size\par
\pard\tx3348\tx4477\b0\fs20 ButtonOffsetPressedCnt(b)\tab (((b)*8)+0)\tab 1\par
ButtonOffsetLongPressCnt(b)\tab (((b)*8)+1)\tab 1\par
ButtonOffsetShortRelCnt(b)\tab (((b)*8)+2)\tab 1\par
ButtonOffsetLongRelCnt(b)\tab (((b)*8)+3)\tab 1\par
ButtonOffsetRelCnt(b)\tab (((b)*8)+4)\tab 1\par
ButtonOffsetState(b)\tab ((b)+32)\tab 1*4\par
\pard\keepn\s2\sb240\sa60\tqr\tx8640\b\i\fs24\page\super #$K+\nosupersub\i0 3.11 UI Module\i\par
\pard\sb120\tqr\tx8640\b0\i0\fs20 The NXT UI module encompasses support for various aspects of the user interface for the NXT brick.\par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 UIModuleName\tab "Ui.mod"\par
UIModuleID\tab 0x000C0001\par
\pard\par
\pard\sb120\tqr\tx8640 Valid flag values are listed in the following table.\par
\pard\sb120\tx4320\b UI Flags Constants\tab Value\par
\pard\tx4320\b0 UI_FLAGS_UPDATE\tab 0x01\par
UI_FLAGS_DISABLE_LEFT_RIGHT_ENTER\tab 0x02\par
UI_FLAGS_DISABLE_EXIT\tab 0x04\par
\lang1030 UI_FLAGS_REDRAW_STATUS\tab 0x08\par
UI_FLAGS_RESET_SLEEP_TIMER\tab 0x10\par
\lang1033 UI_FLAGS_EXECUTE_LMS_FILE\tab 0x20\par
UI_FLAGS_BUSY\tab 0x40\par
UI_FLAGS_ENABLE_STATUS_UPDATE\tab 0x80\par
\pard\sb120\tqr\tx8640 Valid UI state values are listed in the following table.\par
\pard\sb120\tx4320\b UI State Constants\tab Value\par
\pard\tx4320\b0 UI_STATE_INIT_DISPLAY\tab 0\par
UI_STATE_INIT_LOW_BATTERY\tab 1\par
UI_STATE_INIT_INTRO\tab 2\par
UI_STATE_INIT_WAIT\tab 3\par
UI_STATE_INIT_MENU\tab 4\par
UI_STATE_NEXT_MENU\tab 5\par
UI_STATE_DRAW_MENU\tab 6\par
UI_STATE_TEST_BUTTONS\tab 7\par
UI_STATE_LEFT_PRESSED\tab 8\par
UI_STATE_RIGHT_PRESSED\tab 9\par
UI_STATE_ENTER_PRESSED\tab 10\par
UI_STATE_EXIT_PRESSED\tab 11\par
UI_STATE_CONNECT_REQUEST\tab 12\par
UI_STATE_EXECUTE_FILE\tab 13\par
UI_STATE_EXECUTING_FILE\tab 14\par
UI_STATE_LOW_BATTERY\tab 15\par
UI_STATE_BT_ERROR\tab 16\par
\pard\sb120\tqr\tx8640 Valid UI button values are listed in the following table.\par
\pard\sb120\tx4320\b UI Button Constants\tab Value\par
\pard\tx4320\b0 UI_BUTTON_NONE\tab 1\par
UI_BUTTON_LEFT\tab 2\par
UI_BUTTON_ENTER\tab 3\par
UI_BUTTON_RIGHT\tab 4\par
UI_BUTTON_EXIT\tab 5\par
\pard\sb120\tqr\tx8640 Valid UI Bluetooth state values are listed in the following table.\par
\pard\sb120\tx4320\b UI Bluetooth State Constants\tab Value\par
\pard\tx4320\b0 UI_BT_STATE_VISIBLE\tab 0x01\par
UI_BT_STATE_CONNECTED\tab 0x02\par
UI_BT_STATE_OFF\tab 0x04\par
UI_BT_ERROR_ATTENTION\tab 0x08\par
UI_BT_CONNECT_REQUEST\tab 0x40\par
UI_BT_PIN_REQUEST\tab 0x80\par
\pard\sb120\tqr\tx8640\b\fs24 Volume()\tab Value\par
\b0\fs20 Return the user interface volume level. Valid values are from 0 to 4.\par
\pard\li720\sb120\tqr\tx8640\f1 x = Volume();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetVolume(value)\tab Function\par
\b0\fs20 Set the user interface volume level. Valid values are from 0 to 4.\par
\pard\li720\sb120\tqr\tx8640\f1 SetVolume(3);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BatteryLevel()\tab Value\par
\b0\fs20 Return the battery level in millivolts.\par
\pard\li720\sb120\tqr\tx8640\f1 x = BatteryLevel();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BluetoothState()\tab Value\par
\b0\fs20 Return the Bluetooth state. Valid Bluetooth state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = BluetoothState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetBluetoothState(value)\tab Function\par
\b0\fs20 Set the Bluetooth state. Valid Bluetooth state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBluetoothState(UI_BT_STATE_OFF);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 CommandFlags()\tab Value\par
\b0\fs20 Return the command flags. Valid command flag values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = CommandFlags();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetCommandFlags(value)\tab Function\par
\b0\fs20 Set the command flags. Valid command flag values are listed above.\par
\pard\li720\sb120\tqr\tx8640\lang1030\f1 SetCommandFlags(UI_FLAGS_REDRAW_STATUS);\par
\pard\sb120\tqr\tx8640\lang1033\b\f0\fs24 UIState()\tab Value\par
\b0\fs20 Return the user interface state. Valid user interface state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = UIState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUIState(value)\tab Function\par
\b0\fs20 Set the user interface state. Valid user interface state values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUIState(UI_STATE_LOW_BATTERY);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 UIButton()\tab Value\par
\b0\fs20 Return user interface button information. Valid user interface button values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 x = UIButton();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUIButton(value)\tab Function\par
\b0\fs20 Set user interface button information. Valid user interface button values are listed above.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUIButton(UI_BUTTON_ENTER);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 VMRunState()\tab Value\par
\b0\fs20 Return VM run state information. \par
\pard\li720\sb120\tqr\tx8640\f1 x = VMRunState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetVMRunState(value)\tab Function\par
\b0\fs20 Set VM run state information.\par
\pard\li720\sb120\tqr\tx8640\f1 SetVMRunState(0); // stopped\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BatteryState()\tab Value\par
\b0\fs20 Return battery state information (0..4). \par
\pard\li720\sb120\tqr\tx8640\f1 x = BatteryState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetBatteryState(value)\tab Function\par
\b0\fs20 Set battery state information.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBatteryState(4);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RechargeableBattery()\tab Value\par
\b0\fs20 Return whether the NXT has a rechargeable battery installed or not. \par
\pard\li720\sb120\tqr\tx8640\f1 x = RechargeableBattery();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ForceOff(n)\tab Function\par
\b0\fs20 Force the NXT to turn off if the specified value is greater than zero.\par
\pard\li720\sb120\tqr\tx8640\f1 ForceOff(true);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 UsbState()\tab Value\par
\b0\fs20 Return USB state information (0=disconnected, 1=connected, 2=working).\par
\pard\li720\sb120\tqr\tx8640\f1 x = UsbState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUsbState(value)\tab Function\par
\b0\fs20 Set USB state information (0=disconnected, 1=connected, 2=working).\par
\pard\li720\sb120\tqr\tx8640\f1 SetUsbState(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 OnBrickProgramPointer()\tab Value\par
\b0\fs20 Return the current OBP (on-brick program) step.\par
\pard\li720\sb120\tqr\tx8640\f1 x = OnBrickProgramPointer();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetOnBrickProgramPointer(value)\tab Function\par
\b0\fs20 Set the current OBP (on-brick program) step.\par
\pard\li720\sb120\tqr\tx8640\f1 SetOnBrickProgramPointer(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LongAbort()\tab Value (+)\par
\b0\fs20 Return the enhanced NBC/NXC firmware's long abort setting (true or false). If set to true then a program has access the escape button. Aborting a program requires a long press of the escape button.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LongAbort();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLongAbort(value)\tab Function (+)\par
\b0\fs20 Set the enhanced NBC/NXC firmware's long abort setting (true or false). If set to true then a program has access the escape button. Aborting a program requires a long press of the escape button.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLongAbort(true);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super\i0 #$K+\nosupersub 3.11.1 IOMap Offsets\tab\par
\pard\sb120\tx3348\tx4477 UI Module Offsets\tab Value\tab Size\par
\pard\tx3348\tx4477\b0\fs20 UIOffsetPMenu\tab 0\tab 4\par
UIOffsetBatteryVoltage\tab 4\tab 2\par
UIOffsetLMSfilename\tab 6\tab 20\par
UIOffsetFlags\tab 26\tab 1\par
UIOffsetState\tab 27\tab 1\par
UIOffsetButton\tab 28\tab 1\par
UIOffsetRunState\tab 29\tab 1\par
UIOffsetBatteryState\tab 30\tab 1\par
UIOffsetBluetoothState\tab 31\tab 1\par
UIOffsetUsbState\tab 32\tab 1\par
UIOffsetSleepTimeout\tab 33\tab 1\par
UIOffsetSleepTimer\tab 34\tab 1\par
UIOffsetRechargeable\tab 35\tab 1\par
UIOffsetVolume\tab 36\tab 1\par
UIOffsetError\tab 37\tab 1\par
UIOffsetOBPPointer\tab 38\tab 1\par
UIOffsetForceOff\tab 39\tab 1\par
\pard\keepn\s2\sb240\sa60\tqr\tx8640\b\i\fs24\page\super #$K+\nosupersub\i0 3.12 LowSpeed Module\i\par
\pard\sb120\tqr\tx8640\b0\i0\fs20 The NXT low speed module encompasses support for digital I2C sensor communication.\par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 LowSpeedModuleName\tab "Low Speed.mod"\par
LowSpeedModuleID\tab 0x000B0001\par
\pard\sb120\tqr\tx8640 Use the lowspeed (aka I2C) communication methods to access devices that use the I2C protocol on the NXT brick's four input ports.\par
You must set the input port's Type property to SENSOR_TYPE_LOWSPEED or SENSOR_TYPE_LOWSPEED_9V on a given port before using an I2C device on that port. Use SENSOR_TYPE_LOWSPEED_9V if your device requires 9V power from the NXT brick. Remember that you also need to set the input port's InvalidData property to true after setting a new Type, and then wait in a loop for the NXT firmware to set InvalidData back to false. This process ensures that the firmware has time to properly initialize the port, including the 9V power lines, if applicable. Some digital devices might need additional time to initialize after power up.\par
The SetSensorLowspeed API function sets the specified port to SENSOR_TYPE_LOWSPEED_9V and calls ResetSensor to perform the InvalidData reset loop described above.\par
When communicating with I2C devices, the NXT firmware uses a master/slave setup in which the NXT brick is always the master device. This means that the firmware is responsible for controlling the write and read operations. The NXT firmware maintains write and read buffers for each port, and the three main Lowspeed (I2C) methods described below enable you to access these buffers.\par
A call to LowspeedWrite starts an asynchronous transaction between the NXT brick and a digital I2C device. The program continues to run while the firmware manages sending bytes from the write buffer and reading the response bytes from the device. Because the NXT is the master device, you must also specify the number of bytes to expect from the device in response to each write operation. You can exchange up to 16 bytes in each direction per transaction.\par
After you start a write transaction with LowspeedWrite, use LowspeedStatus in a loop to check the status of the port. If LowspeedStatus returns a status code of 0 and a count of bytes available in the read buffer, the system is ready for you to use LowspeedRead to copy the data from the read buffer into the buffer you provide.\par
Note that any of these calls might return various status codes at any time. A status code of 0 means the port is idle and the last transaction (if any) did not result in any errors. Negative status codes and the positive status code 32 indicate errors. There are a few possible errors per call.\par
Valid low speed return values are listed in the following table.\par
\pard\fi-4507\li4507\sb120\tx3453\tx4491\b Low Speed Return Constants\tab Value\tab Meaning\par
\pard\fi-4507\li4507\tx3453\tx4491\b0 NO_ERR\tab 0\tab The operation succeeded.\par
STAT_COMM_PENDING\tab 32\tab The specified port is busy performing a communication transaction.\par
ERR_INVALID_SIZE\tab -19\tab The specified buffer or byte count exceeded the 16 byte limit.\par
ERR_COMM_CHAN_NOT_READY\tab -32\tab The specified port is busy or improperly configured.\par
ERR_COMM_CHAN_INVALID\tab -33\tab The specified port is invalid. It must be between 0 and 3.\par
ERR_COMM_BUS_ERR\tab -35\tab The last transaction failed, possibly due to a device failure.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super\b #$K+\nosupersub 3.12.1 High-level functions\par
\pard\sb120\tqr\tx8640 LowspeedWrite(port, returnlen, buffer)\tab Value\par
\b0\fs20 This method starts a transaction to write the bytes contained in the array buffer to the I2C device on the specified port. It also tells the I2C device the number of bytes that should be included in the response. The maximum number of bytes that can be written or read is 16. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads. Lowspeed return values are listed \uldb above\ulnone\v IDH_NXC_LowSpeed\v0 .\par
\pard\li720\sb120\tqr\tx8640\f1 x = LowspeedWrite(S1, 1, inbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LowspeedStatus(port, out bytesready)\tab Value\par
\b0\fs20 This method checks the status of the I2C communication on the specified port. If the last operation on this port was a successful LowspeedWrite call that requested response data from the device then bytesready will be set to the number of bytes in the internal read buffer. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads. Lowspeed return values are listed \uldb above\ulnone\v IDH_NXC_LowSpeed\v0 . If the return value is 0 then the last operation did not cause any errors. Avoid calls to LowspeedRead or LowspeedWrite while LowspeedStatus returns STAT_COMM_PENDING.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LowspeedStatus(S1, nRead);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LowspeedRead(port, buflen, out buffer)\tab Value\par
\b0\fs20 Read the specified number of bytes from the I2C device on the specified port and store the bytes read in the array buffer provided. The maximum number of bytes that can be written or read is 16. The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. Constants should be used where possible to avoid blocking access to I2C devices on other ports by code running on other threads. Lowspeed return values are listed \uldb above\ulnone\v IDH_NXC_LowSpeed\v0 . If the return value is negative then the output buffer will be empty.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LowspeedRead(S1, 1, outbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 I2CWrite(port, returnlen, buffer)\tab Value\par
\b0\fs20 This is an alias for LowspeedWrite.\par
\pard\li720\sb120\tqr\tx8640\f1 x = I2CWrite(S1, 1, inbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 I2CStatus(port, out bytesready)\tab Value\par
\b0\fs20 This is an alias for LowspeedStatus.\par
\pard\hyphpar0\li720\ri720\sl360\slmult1\expndtw-10\f2\fs22 x = I2CStatus(S1, nRead);\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 I2CRead(port, buflen, out buffer)\tab Value\par
\b0\fs20 This is an alias for LowspeedRead.\par
\pard\li720\sb120\tqr\tx8640\f1 x = I2CRead(S1, 1, outbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 I2CBytes(port, inbuf, in/out count, out outbuf)\tab Value\par
\b0\fs20 This method writes the bytes contained in the input buffer (inbuf) to the I2C device on the specified port, checks for the specified number of bytes to be ready for reading, and then tries to read the specified number (count) of bytes from the I2C device into the output buffer (outbuf). The port may be specified using a constant (e.g., S1, S2, S3, or S4) or a variable. Returns true or false indicating whether the I2C read process succeeded or failed.\par
This is a higher-level wrapper around the three main I2C functions. It also maintains a "last good read" buffer and returns values from that buffer if the I2C communication transaction fails.\par
\pard\li720\sb120\tqr\tx8640\f1 x = I2CBytes(S4, writebuf, cnt, readbuf);\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super\b #$K+\nosupersub 3.12.2 Low-level functions\par
\pard\sb120\tqr\tx8640\b0\fs20 Valid low speed state values are listed in the following table.\par
\pard\sb120\tx4320\b Low Speed State Constants\tab Value\par
\pard\tx4320\b0 COM_CHANNEL_NONE_ACTIVE\tab 0x00\par
COM_CHANNEL_ONE_ACTIVE\tab 0x01\par
COM_CHANNEL_TWO_ACTIVE\tab 0x02\par
COM_CHANNEL_THREE_ACTIVE\tab 0x04\par
COM_CHANNEL_FOUR_ACTIVE\tab 0x08\par
\pard\sb120\tqr\tx8640 Valid low speed channel state values are listed in the following table.\par
\pard\sb120\tx4320\b Low Speed Channel State Constants\tab Value\par
\pard\tx4320\b0 LOWSPEED_IDLE\tab 0\par
LOWSPEED_INIT\tab 1\par
LOWSPEED_LOAD_BUFFER\tab 2\par
LOWSPEED_COMMUNICATING\tab 3\par
LOWSPEED_ERROR\tab 4\par
LOWSPEED_DONE\tab 5\par
\pard\sb120\tqr\tx8640 Valid low speed mode values are listed in the following table.\par
\pard\sb120\tx4320\b Low Speed Mode Constants\tab Value\par
\pard\tx4320\b0 LOWSPEED_TRANSMITTING\tab 1\par
LOWSPEED_RECEIVING\tab 2\par
LOWSPEED_DATA_RECEIVED\tab 3\par
\pard\sb120\tqr\tx8640 Valid low speed error type values are listed in the following table.\par
\pard\sb120\tx4320\b Low Speed Error Type Constants\tab Value\par
\pard\tx4320\b0 LOWSPEED_NO_ERROR\tab 0\par
LOWSPEED_CH_NOT_READY\tab 1\par
LOWSPEED_TX_ERROR\tab 2\par
LOWSPEED_RX_ERROR\tab 3\par
\pard\sb120\tqr\tx8640\b\fs24 GetLSInputBuffer(port, offset, count, out data)\tab Function\par
\b0\fs20 This method reads data from the lowspeed input buffer associated with the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 GetLSInputBuffer(S1, 0, 8, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSInputBuffer(port, offset, count, data)\tab Function\par
\b0\fs20 This method writes data to the lowspeed input buffer associated with the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSInputBuffer(S1, 0, 8, data);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetLSOutputBuffer(port, offset, count, out data)\tab Function\par
\b0\fs20 This method reads data from the lowspeed output buffer associated with the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 GetLSOutputBuffer(S1, 0, 8, outbuffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSOutputBuffer(port, offset, count, data)\tab Function\par
\b0\fs20 This method writes data to the lowspeed output buffer associated with the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSOutputBuffer(S1, 0, 8, data);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSInputBufferInPtr(port)\tab Value\par
\b0\fs20 This method returns the value of the input pointer for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSInputBufferInPtr(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSInputBufferInPtr(port)\tab Function\par
\b0\fs20 This method sets the value of the input pointer for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSInputBufferInPtr(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSInputBufferOutPtr(port)\tab Value\par
\b0\fs20 This method returns the value of the output pointer for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSInputBufferOutPtr(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSInputBufferOutPtr(port)\tab Function\par
\b0\fs20 This method sets the value of the output pointer for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSInputBufferOutPtr(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSInputBufferBytesToRx(port)\tab Value\par
\b0\fs20 This method returns the bytes to receive for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSInputBufferBytesToRx(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSInputBufferBytesToRx(port)\tab Function\par
\b0\fs20 This method sets the bytes to receive for the lowspeed input buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSInputBufferBytesToRx(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSOutputBufferInPtr(port)\tab Value\par
\b0\fs20 This method returns the value of the input pointer for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSOutputBufferInPtr(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSOutputBufferInPtr(port)\tab Function\par
\b0\fs20 This method sets the value of the input pointer for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSOutputBufferInPtr(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSOutputBufferOutPtr(port)\tab Value\par
\b0\fs20 This method returns the value of the output pointer for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSOutputBufferOutPtr(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSOutputBufferOutPtr(port)\tab Function\par
\b0\fs20 This method sets the value of the output pointer for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSOutputBufferOutPtr(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSOutputBufferBytesToRx(port)\tab Value\par
\b0\fs20 This method returns the bytes to receive for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSOutputBufferBytesToRx(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSOutputBufferBytesToRx(port)\tab Function\par
\b0\fs20 This method sets the bytes to receive for the lowspeed output buffer associated with the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSOutputBufferBytesToRx(S1, x);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSMode(port)\tab Value\par
\b0\fs20 This method returns the mode of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSMode(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSMode(port)\tab Function\par
\b0\fs20 This method sets the mode of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSMode(S1, LOWSPEED_TRANSMITTING);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSChannelState(port)\tab Value\par
\b0\fs20 This method returns the channel state of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSChannelState(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSChannelState(port)\tab Function\par
\b0\fs20 This method sets the channel state of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSChannelState(S1, LOWSPEED_IDLE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSErrorType(port)\tab Value\par
\b0\fs20 This method returns the error type of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSErrorType(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSErrorType(port)\tab Function\par
\b0\fs20 This method sets the error type of the lowspeed communication over the specified port. The port must be a constant (S1..S4).\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSErrorType(S1, LOWSPEED_CH_NOT_READY);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSState()\tab Value\par
\b0\fs20 This method returns the state of the lowspeed module.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSState();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSState(n)\tab Function\par
\b0\fs20 This method sets the state of the lowspeed module.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSState(COM_CHANNEL_THREE_ACTIVE);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 LSSpeed()\tab Value\par
\b0\fs20 This method returns the speed of the lowspeed module.\par
\pard\li720\sb120\tqr\tx8640\f1 x = LSSpeed();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetLSSpeed(n)\tab Function\par
\b0\fs20 This method sets the speed of the lowspeed module.\par
\pard\li720\sb120\tqr\tx8640\f1 SetLSSpeed(100);\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super\i0 #$K+\nosupersub 3.12.3 IOMap Offsets\tab\par
\pard\sb120\tx3348\tx4677 LowSpeed Module Offsets\tab Value\tab Size\par
\pard\tx3348\tx4677\b0\fs20 LowSpeedOffsetInBufBuf(p)\tab (((p)*19)+0)\tab 16\par
LowSpeedOffsetInBufInPtr(p)\tab (((p)*19)+16)\tab 1\par
LowSpeedOffsetInBufOutPtr(p)\tab (((p)*19)+17)\tab 1\par
LowSpeedOffsetInBufBytesToRx(p)\tab (((p)*19)+18)\tab 58\par
LowSpeedOffsetOutBufBuf(p)\tab (((p)*19)+76)\tab 16\par
LowSpeedOffsetOutBufInPtr(p)\tab (((p)*19)+92)\tab 1\par
LowSpeedOffsetOutBufOutPtr(p)\tab (((p)*19)+93)\tab 1\par
LowSpeedOffsetOutBufBytesToRx(p)\tab (((p)*19)+94)\tab 58\par
LowSpeedOffsetMode(p)\tab ((p)+152)\tab 4\par
LowSpeedOffsetChannelState(p)\tab ((p)+156)\tab 4\par
LowSpeedOffsetErrorType(p)\tab ((p)+160)\tab 4\par
LowSpeedOffsetState\tab 164\tab 1\par
LowSpeedOffsetSpeed\tab 165\tab 1\par
LowSpeedOffsetSpare\tab 166\tab 1\par
\pard\keepn\s2\sb240\sa60\tqr\tx8640\b\i\fs24\page\super #$K+\nosupersub\i0 3.13 Comm Module\i\par
\pard\sb120\tqr\tx8640\b0\i0\fs20 The NXT comm module encompasses support for all forms of Bluetooth, USB, and HiSpeed communication.\par
\pard\li720\sb120\tx2880\b Module Constants\tab Value\par
\pard\li720\tx2880\b0 CommModuleName\tab "Comm.mod"\par
CommModuleID\tab 0x00050001\par
\pard\sb120\tqr\tx8640 You can use the Bluetooth communication methods to send information to other devices connected to the NXT brick. The NXT firmware also implements a message queuing or mailbox system which you can access using these methods.\par
Communication via Bluetooth uses a master/slave connection system. One device must be designated as the master device before you run a program using Bluetooth. If the NXT is the master device then you can configure up to three slave devices using connection 1, 2, and 3 on the NXT brick. If your NXT is a slave device then connection 0 on the brick must be reserved for the master device.\par
Programs running on the master NXT brick can send packets of data to any connected slave devices using the BluetoothWrite method. Slave devices write response packets to the message queuing system where they wait for the master device to poll for the response.\par
Using the direct command protocol, a master device can send messages to slave NXT bricks in the form of text strings addressed to a particular mailbox. Each mailbox on the slave NXT brick is a circular message queue holding up to five messages. Each message can be up to 58 bytes long.\par
To send messages from a master NXT brick to a slave brick, use BluetoothWrite on the master brick to send a MessageWrite direct command packet to the slave. Then, you can use ReceiveMessage on the slave brick to read the message. The slave NXT brick must be running a program when an incoming message packet is received. Otherwise, the slave NXT brick ignores the message and the message is dropped.\par
\pard\keepn\s3\sb240\sa60\fs24\page\super\b #$K+\nosupersub 3.13.1 High-level functions\par
\pard\sb120\tqr\tx8640 SendRemoteBool(connection, queue, bvalue)\tab Value\par
\b0\fs20 This method sends a boolean value to the device on the specified connection. The message containing the boolean value will be written to the specified queue on the remote brick.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendRemoteBool(1, queue, false);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SendRemoteNumber(connection, queue, value)\tab Value\par
\b0\fs20 This method sends a numeric value to the device on the specified connection. The message containing the numeric value will be written to the specified queue on the remote brick.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendRemoteNumber(1, queue, 123);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SendRemoteString(connection, queue, strval)\tab Value\par
\b0\fs20 This method sends a string value to the device on the specified connection. The message containing the string value will be written to the specified queue on the remote brick.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendRemoteString(1, queue, "hello world");\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SendResponseBool(queue, bvalue)\tab Value\par
\b0\fs20 This method sends a boolean value as a response to a received message. The message containing the boolean value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendResponseBool(queue, false);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SendResponseNumber(queue, value)\tab Value\par
\b0\fs20 This method sends a numeric value as a response to a received message. The message containing the numeric value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendResponseNumber(queue, 123);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SendResponseString(queue, strval)\tab Value\par
\b0\fs20 This method sends a string value as a response to a received message. The message containing the string value will be written to the specified queue (+10) on the slave brick so that it can be retrieved by the master brick via automatic polling.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendResponseString(queue, "hello world");\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReceiveRemoteBool(queue, remove, out bvalue)\tab Value\par
\b0\fs20 This method is used on a master brick to receive a boolean value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = ReceiveRemoteBool(queue, true, bvalue);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReceiveRemoteNumber(queue, remove, out value)\tab Value\par
\b0\fs20 This method is used on a master brick to receive a numeric value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = ReceiveRemoteBool(queue, true, value);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReceiveRemoteString(queue, remove, out strval)\tab Value\par
\b0\fs20 This method is used on a master brick to receive a string value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = ReceiveRemoteString(queue, true, strval);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReceiveRemoteMessageEx(queue, remove, out strval, out val, out bval)\tab Value\par
\b0\fs20 This method is used on a master brick to receive a string, boolean, or numeric value from a slave device communicating via a specific mailbox or message queue. Optionally remove the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = ReceiveRemoteMessageEx(queue, true, strval, val, bval);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SendMessage(queue, msg)\tab Value\par
\b0\fs20 This method writes the message buffer contents to the specified mailbox or message queue. The maximum message length is 58 bytes.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SendMessage(mbox, data);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReceiveMessage(queue, remove, out buffer)\tab Value\par
\b0\fs20 This method retrieves a message from the specified queue and writes it to the buffer provided. Optionally removes the last read message from the message queue depending on the value of the boolean remove parameter.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RecieveMessage(mbox, true, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BluetoothStatus(connection)\tab Value\par
\b0\fs20 This method returns the status of the specified Bluetooth connection. Avoid calling BluetoothWrite or any other API function that writes data over a Bluetooth connection while BluetoothStatus returns STAT_COMM_PENDING.\par
\pard\li720\sb120\tqr\tx8640\f1 x = BluetoothStatus(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BluetoothWrite(connection, buffer)\tab Value\par
\b0\fs20 This method tells the NXT firmware to write the data in the buffer to the device on the specified Bluetooth connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = BluetoothWrite(1, data);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteMessageRead(connection, queue)\tab Value\par
\b0\fs20 This method sends a MessageRead direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteMessageRead(1, 5);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteMessageWrite(connection, queue, msg)\tab Value\par
\b0\fs20 This method sends a MessageWrite direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteMessageWrite(1, 5, "test");\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteStartProgram(connection, filename)\tab Value\par
\b0\fs20 This method sends a StartProgram direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteStartProgram(1, "myprog.rxe");\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteStopProgram(connection)\tab Value\par
\b0\fs20 This method sends a StopProgram direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteStopProgram(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemotePlaySoundFile(connection, filename, bLoop)\tab Value\par
\b0\fs20 This method sends a PlaySoundFile direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemotePlaySoundFile(1, "click.rso", false);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemotePlayTone(connection, frequency, duration)\tab Value\par
\b0\fs20 This method sends a PlayTone direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemotePlayTone(1, 440, 1000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteStopSound(connection)\tab Value\par
\b0\fs20 This method sends a StopSound direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteStopSound(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteKeepAlive(connection)\tab Value\par
\b0\fs20 This method sends a KeepAlive direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteKeepAlive(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteResetScaledValue(connection, port)\tab Value\par
\b0\fs20 This method sends a ResetScaledValue direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteResetScaledValue(1, S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteResetMotorPosition(connection, port, bRelative)\tab Value\par
\b0\fs20 This method sends a ResetMotorPosition direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteResetMotorPosition(1, OUT_A, true);\par
\pard\sb120\tqr\tx8640\lang1036\b\f0\fs24 RemoteSetInputMode(connection, port, type, mode)\tab Value\par
\lang1033\b0\fs20 This method sends a SetInputMode direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteSetInputMode(1, S1, IN_TYPE_LOWSPEED, IN_MODE_RAW);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 RemoteSetOutputState(connection, port, speed, mode, regm, tpct, rs, tl)\tab Value\par
\b0\fs20 This method sends a SetOutputState direct command to the device on the specified connection. Use BluetoothStatus to determine when this write request is completed.\par
\pard\li720\sb120\tqr\tx8640\f1 x = RemoteSetOutputState(1, OUT_A, 75, OUT_MODE_MOTORON, OUT_REGMODE_IDLE, 0, OUT_RUNSTATE_RUNNING, 0);\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super\b #$K+\nosupersub 3.13.2 Low-level functions\par
\pard\sb120\tqr\tx8640\b0\fs20 Valid miscellaneous constant values are listed in the following table.\par
\pard\sb120\tx4320\b Comm Miscellaneous Constants\tab Value\par
\pard\tx4320\b0 SIZE_OF_USBBUF\tab 64\par
USB_PROTOCOL_OVERHEAD\tab 2\par
SIZE_OF_USBDATA\tab 62\par
SIZE_OF_HSBUF\tab 128\par
SIZE_OF_BTBUF\tab 128\par
BT_CMD_BYTE\tab 1\par
SIZE_OF_BT_DEVICE_TABLE\tab 30\par
SIZE_OF_BT_CONNECT_TABLE\tab 4\par
SIZE_OF_BT_NAME\tab 16\par
SIZE_OF_BRICK_NAME\tab 8\par
SIZE_OF_CLASS_OF_DEVICE\tab 4\par
SIZE_OF_BDADDR\tab 7\par
MAX_BT_MSG_SIZE\tab 60000\par
BT_DEFAULT_INQUIRY_MAX\tab 0\par
BT_DEFAULT_INQUIRY_TIMEOUT_LO\tab 15\par
LR_SUCCESS\tab 0x50\par
LR_COULD_NOT_SAVE\tab 0x51\par
LR_STORE_IS_FULL\tab 0x52\par
LR_ENTRY_REMOVED\tab 0x53\par
LR_UNKNOWN_ADDR\tab 0x54\par
USB_CMD_READY\tab 0x01\par
BT_CMD_READY\tab 0x02\par
HS_CMD_READY\tab 0x04\par
\pard\sb120\tqr\tx8640 Valid BtState values are listed in the following table.\par
\pard\sb120\tx4320\b Comm BtState Constants\tab Value\par
\pard\tx4320\b0 BT_ARM_OFF\tab 0\par
BT_ARM_CMD_MODE\tab 1\par
BT_ARM_DATA_MODE\tab 2\par
\pard\sb120\tqr\tx8640 Valid BtStateStatus values are listed in the following table.\par
\pard\sb120\tx4320\b Comm BtStateStatus Constants\tab Value\par
\pard\tx4320\b0 BT_BRICK_VISIBILITY\tab 0x01\par
BT_BRICK_PORT_OPEN\tab 0x02\par
BT_CONNECTION_0_ENABLE\tab 0x10\par
BT_CONNECTION_1_ENABLE\tab 0x20\par
BT_CONNECTION_2_ENABLE\tab 0x40\par
BT_CONNECTION_3_ENABLE\tab 0x80\par
\pard\sb120\tqr\tx8640 Valid BtHwStatus values are listed in the following table.\par
\pard\sb120\tx4320\b Comm BtHwStatus Constants\tab Value\par
\pard\tx4320\b0 BT_ENABLE\tab 0x00\par
BT_DISABLE\tab 0x01\par
\pard\sb120\tqr\tx8640 Valid HsFlags values are listed in the following table.\par
\pard\sb120\tx4320\b Comm HsFlags Constants\tab Value\par
\pard\tx4320\b0 HS_UPDATE\tab 1\par
\pard\sb120\tqr\tx8640 Valid HsState values are listed in the following table.\par
\pard\sb120\tx4320\b Comm HsState Constants\tab Value\par
\pard\tx4320\b0 HS_INITIALISE\tab 1\par
HS_INIT_RECEIVER\tab 2\par
HS_SEND_DATA\tab 3\par
HS_DISABLE\tab 4\par
\pard\sb120\tqr\tx8640 Valid DeviceStatus values are listed in the following table.\par
\pard\sb120\tx4320\b Comm DeviceStatus Constants\tab Value\par
\pard\tx4320\b0 BT_DEVICE_EMPTY\tab 0x00\par
BT_DEVICE_UNKNOWN\tab 0x01\par
BT_DEVICE_KNOWN\tab 0x02\par
BT_DEVICE_NAME\tab 0x40\par
BT_DEVICE_AWAY\tab 0x80\par
\pard\sb120\tqr\tx8640 Valid module interface values are listed in the following table.\par
\pard\sb120\tx4320\b Comm Module Interface Constants\tab Value\par
\pard\tx4320\b0 INTF_SENDFILE\tab 0\par
INTF_SEARCH\tab 1\par
INTF_STOPSEARCH\tab 2\par
INTF_CONNECT\tab 3\par
INTF_DISCONNECT\tab 4\par
INTF_DISCONNECTALL\tab 5\par
INTF_REMOVEDEVICE\tab 6\par
INTF_VISIBILITY\tab 7\par
INTF_SETCMDMODE\tab 8\par
INTF_OPENSTREAM\tab 9\par
INTF_SENDDATA\tab 10\par
INTF_FACTORYRESET\tab 11\par
INTF_BTON\tab 12\par
INTF_BTOFF\tab 13\par
INTF_SETBTNAME\tab 14\par
INTF_EXTREAD\tab 15\par
INTF_PINREQ\tab 16\par
INTF_CONNECTREQ\tab 17\par
\pard\keepn\s3\sb240\sa60\fs24\page\super\b #$K+\nosupersub\i 3.13.2.1 USB functions\par
\pard\sb120\tqr\tx8640\i0 GetUSBInputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the USB input buffer at the specified offset and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetUSBInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBInputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the USB input buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBInputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the USB input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBInputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 USBInputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the USB input buffer.\par
\pard\hyphpar0\li720\ri720\sl360\slmult1\expndtw-10\f2\fs22 byte x = USBInputBufferInPtr();\par
\pard\sb120\tqr\tx8640\expndtw0\b\f0\fs24 SetUSBInputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the USB input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBInputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 USBInputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the USB input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBInputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetUSBOutputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the USB output buffer at the specified offset and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetUSBOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBOutputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the USB output buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBOutputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the USB output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBOutputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 USBOutputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the USB output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBOutputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBOutputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the USB output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBOutputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 USBOutputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the USB output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBOutputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetUSBPollBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the USB poll buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetUSBPollBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBPollBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the USB poll buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBPollBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBPollBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the USB poll buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBPollBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 USBPollBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the USB poll buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBPollBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBPollBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the USB poll buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBPollBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 USBPollBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the USB poll buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBPollBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetUSBState(n)\tab Function\par
\b0\fs20 This method sets the USB state to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetUSBState(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 USBState()\tab Value\par
\b0\fs20 This method returns the USB state.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = USBPollBufferOutPtr();\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super\b #$K+\nosupersub\i 3.13.2.2 High Speed port functions\par
\pard\sb120\tqr\tx8640\i0 GetHSInputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the High Speed input buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetHSInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSInputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the High Speed input buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSInputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the High Speed input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSInputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HSInputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the High Speed input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSInputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSInputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the High Speed input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSInputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HSInputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the High Speed input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSInputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetHSOutputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the High Speed output buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetHSOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSOutputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the High Speed output buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSOutputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the Output pointer of the High Speed output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSOutputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HSOutputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the Output pointer of the High Speed output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSOutputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSOutputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the High Speed output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSOutputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HSOutputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the High Speed output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSOutputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSFlags(n)\tab Function\par
\b0\fs20 This method sets the High Speed flags to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSFlags(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HSFlags()\tab Value\par
\b0\fs20 This method returns the value of the High Speed flags.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSFlags();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSSpeed(n)\tab Function\par
\b0\fs20 This method sets the High Speed speed to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSSpeed(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HSSpeed()\tab Value\par
\b0\fs20 This method returns the value of the High Speed speed.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSSpeed();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetHSState(n)\tab Function\par
\b0\fs20 This method sets the High Speed state to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetHSState(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HSState()\tab Value\par
\b0\fs20 This method returns the value of the High Speed state.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = HSState();\par
\pard\keepn\s3\sb240\sa60\f0\fs24\page\super\b #$K+\nosupersub\i 3.13.2.3 Bluetooth functions\par
\pard\sb120\tqr\tx8640\i0 GetBTInputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the Bluetooth input buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBTInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetBTInputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the Bluetooth input buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTInputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetBTInputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the Bluetooth input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTInputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTInputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the Bluetooth input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTInputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetBTInputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the Bluetooth input buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTInputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTInputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the Bluetooth input buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTInputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetBTOutputBuffer(offset, count, out data)\tab Function\par
\b0\fs20 This method reads count bytes of data from the Bluetooth output buffer and writes it to the buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBTOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetBTOutputBuffer(offset, count, data)\tab Function\par
\b0\fs20 This method writes count bytes of data to the Bluetooth output buffer at the specified offset.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTOutputBuffer(0, 10, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetBTOutputBufferInPtr(n)\tab Function\par
\b0\fs20 This method sets the input pointer of the Bluetooth output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTOutputBufferInPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTOutputBufferInPtr()\tab Value\par
\b0\fs20 This method returns the value of the input pointer of the Bluetooth output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTOutputBufferInPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetBTOutputBufferOutPtr(n)\tab Function\par
\b0\fs20 This method sets the output pointer of the Bluetooth output buffer to the specified value.\par
\pard\li720\sb120\tqr\tx8640\f1 SetBTOutputBufferOutPtr(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTOutputBufferOutPtr()\tab Value\par
\b0\fs20 This method returns the value of the output pointer of the Bluetooth output buffer.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTOutputBufferOutPtr();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTDeviceCount()\tab Value\par
\b0\fs20 This method returns the number of devices defined within the Bluetooth device table.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTDeviceCount();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTDeviceNameCount()\tab Value\par
\b0\fs20 This method returns the number of device names defined within the Bluetooth device table. This usually has the same value as BTDeviceCount but it can differ in some instances.\par
\pard\li720\sb120\tqr\tx8640\f1 byte x = BTDeviceNameCount();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTDeviceName(const idx)\tab Value\par
\b0\fs20 This method returns the name of the device at the specified index in the Bluetooth device table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 string name = BTDeviceName(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTConnectionName(const idx)\tab Value\par
\b0\fs20 This method returns the name of the device at the specified index in the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 string name = BTConnectionName(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTConnectionPinCode(const idx)\tab Value\par
\b0\fs20 This method returns the pin code of the device at the specified index in the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 string pincode = BTConnectionPinCode(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BrickDataName()\tab Value\par
\b0\fs20 This method returns the name of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 string name = BrickDataName();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetBTDeviceAddress(const idx, out data)\tab Function\par
\b0\fs20 This method reads the address of the device at the specified index within the Bluetooth device table and stores it in the data buffer provided. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBTDeviceAddress(0, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetBTConnectionAddress(const idx, out data)\tab Function\par
\b0\fs20 This method reads the address of the device at the specified index within the Bluetooth connection table and stores it in the data buffer provided. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBTConnectionAddress(0, buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 GetBrickDataAddress(out data)\tab Function\par
\b0\fs20 This method reads the address of the NXT and stores it in the data buffer provided.\par
\pard\li720\sb120\tqr\tx8640\f1 GetBrickDataAddress(buffer);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTDeviceClass(const idx)\tab Value\par
\b0\fs20 This method returns the class of the device at the specified index within the Bluetooth device table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 long class = BTDeviceClass(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTDeviceStatus(const idx)\tab Value\par
\b0\fs20 This method returns the status of the device at the specified index within the Bluetooth device table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 byte status = BTDeviceStatus(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTConnectionClass(const idx)\tab Value\par
\b0\fs20 This method returns the class of the device at the specified index within the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 long class = BTConnectionClass(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTConnectionHandleNum(const idx)\tab Value\par
\b0\fs20 This method returns the handle number of the device at the specified index within the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 byte handlenum = BTConnectionHandleNum(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTConnectionStreamStatus(const idx)\tab Value\par
\b0\fs20 This method returns the stream status of the device at the specified index within the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 byte streamstatus = BTConnectionStreamStatus(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BTConnectionLinkQuality(const idx)\tab Value\par
\b0\fs20 This method returns the link quality of the device at the specified index within the Bluetooth connection table. The index must be a constant.\par
\pard\li720\sb120\tqr\tx8640\f1 byte linkquality = BTConnectionLinkQuality(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BrickDataBluecoreVersion()\tab Value\par
\b0\fs20 This method returns the bluecore version of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 int bv = BrickDataBluecoreVersion();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BrickDataBtStateStatus()\tab Value\par
\b0\fs20 This method returns the Bluetooth state status of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 int x = BrickDataBtStateStatus();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BrickDataBtHardwareStatus()\tab Value\par
\b0\fs20 This method returns the Bluetooth hardware status of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 int x = BrickDataBtHardwareStatus();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 BrickDataTimeoutValue()\tab Value\par
\b0\fs20 This method returns the timeout value of the NXT.\par
\pard\li720\sb120\tqr\tx8640\f1 int x = BrickDataTimeoutValue();\par
\pard\keepn\s2\sb240\sa60\b\i\f0\fs24\page\super\i0 #$K+\nosupersub 3.13.3 IOMap Offsets\par
\pard\sb120\tx4247\tx5676 Comm Module Offsets\tab Value\tab Size\par
\pard\tx4247\tx5676\b0\fs20 CommOffsetPFunc\tab 0\tab 4\par
CommOffsetPFuncTwo\tab 4\tab 4\par
CommOffsetBtDeviceTableName(p)\tab (((p)*31)+8)\tab 16\par
CommOffsetBtDeviceTableClassOfDevice(p)\tab (((p)*31)+24)\tab 4\par
CommOffsetBtDeviceTableBdAddr(p)\tab (((p)*31)+28)\tab 7\par
CommOffsetBtDeviceTableDeviceStatus(p)\tab (((p)*31)+35)\tab 1\par
CommOffsetBtConnectTableName(p)\tab (((p)*47)+938)\tab 16\par
CommOffsetBtConnectTableClassOfDevice (p)\tab (((p)*47)+954)\tab 4\par
CommOffsetBtConnectTablePinCode(p)\tab (((p)*47)+958)\tab 16\par
CommOffsetBtConnectTableBdAddr(p)\tab (((p)*47)+974)\tab 7\par
CommOffsetBtConnectTableHandleNr(p)\tab (((p)*47)+981)\tab 1\par
CommOffsetBtConnectTableStreamStatus(p)\tab (((p)*47)+982)\tab 1\par
CommOffsetBtConnectTableLinkQuality(p)\tab (((p)*47)+983)\tab 1\par
CommOffsetBrickDataName\tab 1126\tab 16\par
CommOffsetBrickDataBluecoreVersion\tab 1142\tab 2\par
CommOffsetBrickDataBdAddr\tab 1144\tab 7\par
CommOffsetBrickDataBtStateStatus\tab 1151\tab 1\par
CommOffsetBrickDataBtHwStatus\tab 1152\tab 1\par
CommOffsetBrickDataTimeOutValue\tab 1153\tab 1\par
CommOffsetBtInBufBuf\tab 1157\tab 128\par
CommOffsetBtInBufInPtr\tab 1285\tab 1\par
CommOffsetBtInBufOutPtr\tab 1286\tab 1\par
CommOffsetBtOutBufBuf\tab 1289\tab 128\par
CommOffsetBtOutBufInPtr\tab 1417\tab 1\par
CommOffsetBtOutBufOutPtr\tab 1418\tab 1\par
CommOffsetHsInBufBuf\tab 1421\tab 128\par
CommOffsetHsInBufInPtr\tab 1549\tab 1\par
CommOffsetHsInBufOutPtr\tab 1550\tab 1\par
CommOffsetHsOutBufBuf\tab 1553\tab 128\par
CommOffsetHsOutBufInPtr\tab 1681\tab 1\par
CommOffsetHsOutBufOutPtr\tab 1682\tab 1\par
CommOffsetUsbInBufBuf\tab 1685\tab 64\par
CommOffsetUsbInBufInPtr\tab 1749\tab 1\par
CommOffsetUsbInBufOutPtr\tab 1750\tab 1\par
CommOffsetUsbOutBufBuf\tab 1753\tab 64\par
CommOffsetUsbOutBufInPtr\tab 1817\tab 1\par
CommOffsetUsbOutBufOutPtr\tab 1818\tab 1\par
CommOffsetUsbPollBufBuf\tab 1821\tab 64\par
CommOffsetUsbPollBufInPtr\tab 1885\tab 1\par
CommOffsetUsbPollBufOutPtr\tab 1886\tab 1\par
CommOffsetBtDeviceCnt\tab 1889\tab 1\par
CommOffsetBtDeviceNameCnt\tab 1890\tab 1\par
CommOffsetHsFlags\tab 1891\tab 1\par
CommOffsetHsSpeed\tab 1892\tab 1\par
CommOffsetHsState\tab 1893\tab 1\par
CommOffsetUsbState\tab 1894\tab 1\par
\pard\keepn\s2\sb240\sa60\tqr\tx8640\b\i\fs24\page\super #$K+\nosupersub\i0 3.14 \i HiTechnic API Functions\par
\pard\sb120\tqr\tx8640\i0 SensorHTCompass(port)\tab Value\par
\b0\fs20 Read the compass heading value of the HiTechnic Compass sensor on the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorHTCompass(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorHTIRSeekerDir(port)\tab Value\par
\b0\fs20 Read the direction value of the HiTechnic IR Seeker on the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorHTIRSeekerDir(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorHTColorNum(port)\tab Value\par
\b0\fs20 Read the color number from the HiTechnic Color sensor on the specified port.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorHTColorNum(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SetSensorHTGyro(port)\tab Function\par
\b0\fs20 Configure the sensor on the specified port as a HiTechnic Gyro sensor.\par
\pard\li720\sb120\tqr\tx8640\f1 SetSensorHTGyro(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorHTGyro(port, offset)\tab Value\par
\b0\fs20 Read the HiTechnic Gyro sensor on the specified port. The offset value should be calculated by averaging several readings with an offset of zero while the sensor is perfectly still.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorHTGyro(S1, gyroOffset);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReadSensorHTAccel(port, x, y, z)\tab Value\par
\b0\fs20 Read X, Y, and Z axis acceleration values from the HiTechnic Accelerometer sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTAccel(S1, x, y, z);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReadSensorHTColor(port, ColorNum, Red, Green, Blue)\tab Value\par
\b0\fs20 Read color number, red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTColor(S1, c, r, g, b);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReadSensorHTRawColor(port, Red, Green, Blue)\tab Value\par
\b0\fs20 Read the raw red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTRawColor(S1, r, g, b);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReadSensorHTNormalizedColor(port, Idx, Red, Green, Blue)\tab Value\par
\b0\fs20 Read the color index and the normalized red, green, and blue values from the HiTechnic Color sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTNormalizedColor(S1, c, r, g, b);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 ReadSensorHTIRSeeker(port, dir, s1, s3, s5, s7, s9)\tab Value\par
\b0\fs20 Read direction, and five signal strength values from the HiTechnic IRSeeker sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 bVal = ReadSensorHTIRSeeker(port, dir, s1, s3, s5, s7, s9);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTPowerFunctionCommand(port, channel, cmd1, cmd2)\tab Function\par
\b0\fs20 Execute a pair of Power Function motor commands on the specified channel using the HiTechnic iRLink device. Commands are HTPF_CMD_STOP, HTPF_CMD_REV, HTPF_CMD_FWD, and HTPF_CMD_BRAKE. Valid channels are HTPF_CHANNEL_1 through HTPF_CHANNEL_4.\par
\pard\li720\sb120\tqr\tx8640\f1 HTPowerFunctionCommand(S1, HTPF_CHANNEL_1, HTPF_CMD_STOP, HTPF_CMD_FWD);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetIRLinkPort(port)\tab Function\par
\b0\fs20 Set the global port in advance of using the HTRCX* and HTScout* API functions for sending RCX and Scout messages over the HiTechnic iRLink device.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetIRLinkPort(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXPoll(src, value)\tab Value\par
\b0\fs20 Send the Poll command to an RCX to read a signed 2-byte value at the specified source and value combination.\par
\pard\li720\sb120\tqr\tx8640\f1 x = HTRCXPoll(RCX_VariableSrc, 0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXBatteryLevel()\tab Value\par
\b0\fs20 Send the BatteryLevel command to an RCX to read the current battery level.\par
\pard\li720\sb120\tqr\tx8640\f1 x = HTRCXBatteryLevel();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXPing()\tab Function\par
\b0\fs20 Send the Ping command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPing();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXDeleteTasks()\tab Function\par
\b0\fs20 Send the DeleteTasks command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDeleteTasks();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXStopAllTasks()\tab Function\par
\b0\fs20 Send the StopAllTasks command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXStopAllTasks();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXPBTurnOff()\tab Function\par
\b0\fs20 Send the PBTurnOff command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPBTurnOff();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXDeleteSubs()\tab Function\par
\b0\fs20 Send the DeleteSubs command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDeleteSubs();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXClearSound()\tab Function\par
\b0\fs20 Send the ClearSound command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXClearMsg()\tab Function\par
\b0\fs20 Send the ClearMsg command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearMsg();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXMuteSound()\tab Function\par
\b0\fs20 Send the MuteSound command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXMuteSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXUnmuteSound()\tab Function\par
\b0\fs20 Send the UnmuteSound command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXUnmuteSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXClearAllEvents()\tab Function\par
\b0\fs20 Send the ClearAllEvents command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearAllEvents();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetOutput(outputs, mode)\tab Function\par
\b0\fs20 Send the SetOutput command to an RCX to configure the mode of the specified outputs\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetOutput(RCX_OUT_A, RCX_OUT_ON);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetDirection(outputs, dir)\tab Function\par
\b0\fs20 Send the SetDirection command to an RCX to configure the direction of the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetDirection(RCX_OUT_A, RCX_OUT_FWD);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetPower(outputs, pwrsrc, pwrval)\tab Function\par
\b0\fs20 Send the SetPower command to an RCX to configure the power level of the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetPower(RCX_OUT_A, RCX_ConstantSrc, RCX_OUT_FULL);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXOn(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to turn on the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOn(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXOff(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to turn off the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOff(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXFloat(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to float the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXFloat(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXToggle(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to toggle the direction of the specified outputs.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXToggle(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXFwd(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to set the specified outputs to the forward direction.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXFwd(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXRev(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to set the specified outputs to the reverse direction.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXRev(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXOnFwd(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to turn on the specified outputs in the forward direction.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOnFwd(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXOnRev(outputs)\tab Function\par
\b0\fs20 Send commands to an RCX to turn on the specified outputs in the reverse direction.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOnRev(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXOnFor(outputs, duration)\tab Function\par
\b0\fs20 Send commands to an RCX to turn on the specified outputs in the forward direction for the specified duration.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOnFor(RCX_OUT_A, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetTxPower(pwr)\tab Function\par
\b0\fs20 Send the SetTxPower command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetTxPower(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXPlaySound(snd)\tab Function\par
\b0\fs20 Send the PlaySound command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPlaySound(RCX_SOUND_UP);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXDeleteTask(n)\tab Function\par
\b0\fs20 Send the DeleteTask command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDeleteTask(3);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXStartTask(n)\tab Function\par
\b0\fs20 Send the StartTask command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXStartTask(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXStopTask(n)\tab Function\par
\b0\fs20 Send the StopTask command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXStopTask(1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSelectProgram(prog)\tab Function\par
\b0\fs20 Send the SelectProgram command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSelectProgram(3);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXClearTimer(timer)\tab Function\par
\b0\fs20 Send the ClearTimer command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearTimer(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetSleepTime(t)\tab Function\par
\b0\fs20 Send the SetSleepTime command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetSleepTime(4);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXDeleteSub(s)\tab Function\par
\b0\fs20 Send the DeleteSub command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDeleteSub(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXClearSensor(port)\tab Function\par
\b0\fs20 Send the ClearSensor command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearSensor(S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXPlayToneVar(varnum, duration)\tab Function\par
\b0\fs20 Send the PlayToneVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPlayToneVar(0, 50);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetWatch(hours, minutes)\tab Function\par
\b0\fs20 Send the SetWatch command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetWatch(3, 30);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetSensorType(port, type)\tab Function\par
\b0\fs20 Send the SetSensorType command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetSensorType(S1, SENSOR_TYPE_TOUCH);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetSensorMode(port, mode)\tab Function\par
\b0\fs20 Send the SetSensorMode command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetSensorMode(S1, SENSOR_MODE_BOOL);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXCreateDatalog(size)\tab Function\par
\b0\fs20 Send the CreateDatalog command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXCreateDatalog(50);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXAddToDatalog(src, value)\tab Function\par
\b0\fs20 Send the AddToDatalog command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXAddToDatalog(RCX_InputValueSrc, S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSendSerial(first, count)\tab Function\par
\b0\fs20 Send the SendSerial command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSendSerial(0, 10);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXRemote(cmd)\tab Function\par
\b0\fs20 Send the Remote command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXRemote(RCX_RemotePlayASound);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXEvent(src, value)\tab Function\par
\b0\fs20 Send the Event command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXEvent(RCX_ConstantSrc, 2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXPlayTone(freq, duration)\tab Function\par
\b0\fs20 Send the PlayTone command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPlayTone(440, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSelectDisplay(src, value)\tab Function\par
\b0\fs20 Send the SelectDisplay command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSelectDisplay(RCX_VariableSrc, 2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXPollMemory(address, count)\tab Function\par
\b0\fs20 Send the PollMemory command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXPollMemory(0, 10);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetEvent(evt, src, type)\tab Function\par
\b0\fs20 Send the SetEvent command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetEvent(0, RCX_ConstantSrc, 5);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetGlobalOutput(outputs, mode)\tab Function\par
\b0\fs20 Send the SetGlobalOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetGlobalOutput(RCX_OUT_A, RCX_OUT_ON);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetGlobalDirection(outputs, dir)\tab Function\par
\b0\fs20 Send the SetGlobalDirection command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetGlobalDirection(RCX_OUT_A, RCX_OUT_FWD);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetMaxPower(outputs, pwrsrc, pwrval)\tab Function\par
\b0\fs20 Send the SetMaxPower command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetMaxPower(RCX_OUT_A, RCX_ConstantSrc, 5);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXEnableOutput(outputs)\tab Function\par
\b0\fs20 Send the EnableOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXEnableOutput(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXDisableOutput(outputs)\tab Function\par
\b0\fs20 Send the DisableOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDisableOutput(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXInvertOutput(outputs)\tab Function\par
\b0\fs20 Send the InvertOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXInvertOutput(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXObvertOutput(outputs)\tab Function\par
\b0\fs20 Send the ObvertOutput command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXObvertOutput(RCX_OUT_A);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXCalibrateEvent(evt, low, hi, hyst)\tab Function\par
\b0\fs20 Send the CalibrateEvent command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXCalibrateEvent(0, 200, 500, 50);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the SetVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetVar(0, RCX_VariableSrc, 1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSumVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the SumVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSumVar(0, RCX_InputValueSrc, S1);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSubVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the SubVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSubVar(0, RCX_RandomSrc, 10);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXDivVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the DivVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDivVar(0, RCX_ConstantSrc, 2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXMulVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the MulVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXMulVar(0, RCX_VariableSrc, 4);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSgnVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the SgnVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSgnVar(0, RCX_VariableSrc, 0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXAbsVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the AbsVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXAbsVar(0, RCX_VariableSrc, 0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXAndVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the AndVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXAndVar(0, RCX_ConstantSrc, 0x7f);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXOrVar(varnum, src, value)\tab Function\par
\b0\fs20 Send the OrVar command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXOrVar(0, RCX_ConstantSrc, 0xCC);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSet(dstsrc, dstval, src, value)\tab Function\par
\b0\fs20 Send the Set command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSet(RCX_VariableSrc, 0, RCX_RandomSrc, 10000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXUnlock()\tab Function\par
\b0\fs20 Send the Unlock command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXUnlock();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXReset()\tab Function\par
\b0\fs20 Send the Reset command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXReset();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXBoot()\tab Function\par
\b0\fs20 Send the Boot command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXBoot();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetUserDisplay(src, value, precision)\tab Function\par
\b0\fs20 Send the SetUserDisplay command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetUserDisplay(RCX_VariableSrc, 0, 2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXIncCounter(counter)\tab Function\par
\b0\fs20 Send the IncCounter command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXIncCounter(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXDecCounter(counter)\tab Function\par
\b0\fs20 Send the DecCounter command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXDecCounter(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXClearCounter(counter)\tab Function\par
\b0\fs20 Send the ClearCounter command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXClearCounter(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetPriority(p)\tab Function\par
\b0\fs20 Send the SetPriority command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetPriority(2);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTRCXSetMessage(msg)\tab Function\par
\b0\fs20 Send the SetMessage command to an RCX.\par
\pard\li720\sb120\tqr\tx8640\f1 HTRCXSetMessage(20);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutCalibrateSensor()\tab Function\par
\b0\fs20 Send the CalibrateSensor command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutCalibrateSensor();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutMuteSound()\tab Function\par
\b0\fs20 Send the MuteSound command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutMuteSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutUnmuteSound()\tab Function\par
\b0\fs20 Send the UnmuteSound command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutUnmuteSound();\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSelectSounds(group)\tab Function\par
\b0\fs20 Send the SelectSounds command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSelectSounds(0);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetLight(mode)\tab Function\par
\b0\fs20 Send the SetLight command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetLight(SCOUT_LIGHT_ON);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetCounterLimit(counter, src, value)\tab Function\par
\b0\fs20 Send the SetCounterLimit command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetCounterLimit(0, RCX_ConstantSrc, 2000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetTimerLimit(timer, src, value)\tab Function\par
\b0\fs20 Send the SetTimerLimit command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetTimerLimit(0, RCX_ConstantSrc, 10000);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetSensorClickTime(src, value)\tab Function\par
\b0\fs20 Send the SetSensorClickTime command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetSensorClickTime(RCX_ConstantSrc, 200);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetSensorHysteresis(src, value)\tab Function\par
\b0\fs20 Send the SetSensorHysteresis command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetSensorHysteresis(RCX_ConstantSrc, 50);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetSensorLower Limit(src, value)\tab Function\par
\b0\fs20 Send the SetSensorLowerLimit command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetSensorLower Limit(RCX_ConstantSrc, 100);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetSensorUpper Limit(src, value)\tab Function\par
\b0\fs20 Send the SetSensorUpperLimit command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetSensorUpper Limit(RCX_ConstantSrc, 400);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetEventFeedback(src, value)\tab Function\par
\b0\fs20 Send the SetEventFeedback command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetEventFeedback(RCX_ConstantSrc, 10);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSendVLL(src, value)\tab Function\par
\b0\fs20 Send the SendVLL command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSendVLL(RCX_ConstantSrc, 0x30);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetScoutRules(motion, touch, light, time, effect)\tab Function\par
\b0\fs20 Send the SetScoutRules command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\f1 HTScoutSetScoutRules(SCOUT_MR_FORWARD, SCOUT_TR_REVERSE, SCOUT_LR_IGNORE, SCOUT_TGS_SHORT, SCOUT_FXR_BUG);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 HTScoutSetScoutMode(mode)\tab Function\par
\b0\fs20 Send the SetScoutMode command to a Scout.\par
\pard\li720\sb120\tqr\tx8640\lang1036\f1 HTScoutSetScoutMode(SCOUT_MODE_POWER);\par
\pard\keepn\s2\sb240\sa60\tqr\tx8640\b\i\f0\fs24\page\super #$K+\nosupersub\i0 3.15 \i Mindsensors API Functions\par
\pard\sb120\tqr\tx8640\lang1033\i0 ReadSensorMSRTClock(port, ss, mm, hh, dow, dd, MM, yy)\tab Function\par
\b0\fs20 Read real-time clock values from the Mindsensors RTClock sensor. Returns a boolean value indicating whether or not the operation completed successfully.\par
\pard\li720\sb120\tqr\tx8640\f1 ReadSensorMSRTClock(S1, ss, mm, hh, dow, dd, mon, yy);\par
\pard\sb120\tqr\tx8640\b\f0\fs24 SensorMSCompass(port)\tab Function\par
\b0\fs20 Return the Mindsensors Compass sensor value.\par
\pard\li720\sb120\tqr\tx8640\f1 x = SensorMSCompass(S1);\par
\pard\f0\page\par
}
 